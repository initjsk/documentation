/*
   A module that specifies and defines general purpose functions over sequences.

   All functions are explicit and executable. Where a non-executable condition adds value, it
   is included as a comment.
*/
module Seq
imports from Numeric all
exports functions sum: seq of real +> real
                  prod: seq of real +> real
                  min: seq1 of real +> real
                  max: seq1 of real +> real
                  inSeq[@a]: @a * seq of @a +> bool
                  prefix[@a]: seq of @a * seq of @a +> bool
                  suffix[@a]: seq of @a * seq of @a +> bool
                  infix[@a]: seq of @a * seq of @a +> bool
                  subseq[@a]: seq1 of @a * nat1 * nat +> seq of @a
                  xform[@a,@b]: (@a +> @b) * seq of @a +> seq of @b
                  fold[@a]: (@a * @a +> @a) * @a * seq of @a +> @a
                  fold1[@a]: (@a * @a +> @a) * seq1 of @a +> @a
                  zip[@a,@b]: seq of @a * seq of @b +> seq of (@a * @b)
                  unzip[@a,@b]: seq of (@a * @b) +> seq of @a * seq of @b
                  isDistinct[@a]: seq of @a +> bool
                  app[@a]: seq of @a * seq of @a +> seq of @a
                  setOf[@a]: seq of @a +> set of @a

definitions

functions

  -- The sum of a sequence of numerics.
  sum: seq of real +> real
  sum(s) == fold[real](Numeric`add,0,s);

  -- The product of a sequence of numerics.
  prod: seq of real +> real
  prod(s) == fold[real](Numeric`mult,1,s);

  -- The minimum of a sequence of numerics.
  min: seq1 of real +> real
  min(s) == fold1[real](Numeric`min,s)
  post RESULT in set elems s and forall e in set elems s & RESULT <= e;

  -- The maximum of a sequence of numerics.
  max: seq1 of real +> real
  max(s) == fold1[real](Numeric`max,s)
  post RESULT in set elems s and forall e in set elems s & RESULT >= e;

  -- Does an element appear in a sequence?
  inSeq[@a]: @a * seq of @a +> bool
  inSeq(e,s) == e in set elems s;

  -- Is one sequence a prefix of another?
  prefix[@a]: seq of @a * seq of @a +> bool
  prefix(pref,full) == len pref <= len full and forall i in set inds pref & pref(i) = full(i);

  -- Is one sequence a suffix of another?
  suffix[@a]: seq of @a * seq of @a +> bool
  suffix(suff,full) == prefix[@a](reverse suff, reverse full);

  -- Is one sequence a subsequence of another sequence?
  infix[@a]: seq of @a * seq of @a +> bool
  infix(inf,full) == exists i in set inds full & i <= len full-len inf+1 and prefix[@a](inf, subseq[@a](full, i, len inf));

  -- Extract a subsequence from a sequence. The starting index and the length of the subsequence
  -- are specified.
  subseq[@a]: seq1 of @a * nat1 * nat +> seq of @a
  subseq(sq, start, slen) == [ sq(i) | i in set inds sq & start <= i and i < start+slen ]
  pre start+slen-1 <= len sq;

  -- Apply a function to all elements of a sequence.
  xform[@a,@b]: (@a+>@b) * seq of @a +> seq of @b
  xform(f,s) == cases s:
                  []    -> [],
                  [e]   -> [f(e)],
                  s1^s2 -> xform[@a,@b](f,s1) ^ xform[@a,@b](f,s2)
                end
  post len RESULT = len s and forall i in set inds s & RESULT(i) = f(s(i))
  measure size3;

  -- Fold (iterate, accumulate, reduce) a binary function over a sequence.
  -- The function is assumed to be associative and have an identity element.
  fold[@a]: (@a * @a +> @a) * @a * seq of @a +> @a
  fold(f, e, s) == cases s:
                     []    -> e,
                     [x]   -> x,
                     s1^s2 -> f(fold[@a](f,e,s1), fold[@a](f,e,s2))
                   end
  --pre (exists x:@a & forall y:@a & f(x,y) = y and f(y,x) = y)
  --and forall x,y,z:@a & f(x,f(y,z)) = f(f(x,y),z)
  measure size2;

  -- Fold (iterate, accumulate, reduce) a binary function over a non-empty set.
  -- The function is assumed to be associative.
  fold1[@a]: (@a * @a +> @a) * seq1 of @a +> @a
  fold1(f, s) == cases s:
                   [e]   -> e,
                   s1^s2 -> f(fold1[@a](f,s1), fold1[@a](f,s2))
                 end
  --pre forall x,y,z:@a & f(x,f(y,z)) = f(f(x,y),z)
  measure size1;

  -- Pair the corresponding elements of two lists of equal length.
  zip[@a,@b]: seq of @a * seq of @b +> seq of (@a * @b)
  zip(s,t) == cases mk_(s,t):
                mk_([],[])         -> [],
                mk_([x]^s1,[y]^t1) -> [mk_(x,y)] ^ zip[@a,@b](s1,t1)
              end
  pre len s = len t
  post len RESULT = len s and forall i in set inds RESULT & RESULT(i) = mk_(s(i), t(i))
  measure size3;

  -- Split a list of pairs into a list of firsts and a list of seconds.
  unzip[@a,@b]: seq of (@a * @b) +> seq of @a * seq of @b
  unzip(s) == cases s:
                []         -> [],
                [mk_(x,y)] -> mk_([x],[y]),
                s1^s2      -> let mk_(t1,u1) = unzip[@a,@b](s1),
                                  mk_(t2,u2) = unzip[@a,@b](s2)
                              in mk_(t1^t2, u1^u2)
              end
  post let mk_(t,u) = RESULT
       in len t = len s and len u = len s and
          forall i in set inds s & t(i) = s(i).#1 and u(i) = s(i).#2
  measure size;

  -- Are the elements of a list distinct (no duplicates).
  isDistinct[@a]: seq of @a +> bool
  isDistinct(s) == len s = card elems s;

  -- The following functions wrap primitives for convenience, to allow them for example to
  -- serve as function arguments.

  -- Concatenation of two sequences.
  app[@a]: seq of @a * seq of @a +> seq of @a
  app(m,n) == m^n;

  -- Set of sequence elements.
  setOf[@a]: seq of @a +> set of @a
  setOf(s) == elems(s);

  -- Measure functions.

  size[@a,@b]: seq of ? -> nat
  size(s) == len s;

  size1[@a]: ? * seq of @a -> nat
  size1(-, s) == len s;

  size2[@a]: ? * ? * seq of @a -> nat
  size2(-, -, s) == len s;

  size3[@a,@b]: ? * seq of @a -> nat
  size3(-, s) == len s;

end Seq