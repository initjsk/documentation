{\rtf1\ansi\ansicpg1252\uc1\deff0\stshfdbch0\stshfloch0\stshfhich0\stshfbi0\deflang1030\deflangfe1030{\fonttbl{\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}{\f5\fmodern\fcharset0\fprq1{\*\panose 02070409020205020404}Courier{\*\falt Courier New};}{\f36\froman\fcharset238\fprq2 Times New Roman CE;}
{\f37\froman\fcharset204\fprq2 Times New Roman Cyr;}{\f39\froman\fcharset161\fprq2 Times New Roman Greek;}{\f40\froman\fcharset162\fprq2 Times New Roman Tur;}{\f41\froman\fcharset177\fprq2 Times New Roman (Hebrew);}
{\f42\froman\fcharset178\fprq2 Times New Roman (Arabic);}{\f43\froman\fcharset186\fprq2 Times New Roman Baltic;}{\f44\froman\fcharset163\fprq2 Times New Roman (Vietnamese);}{\f46\fswiss\fcharset238\fprq2 Arial CE;}
{\f47\fswiss\fcharset204\fprq2 Arial Cyr;}{\f49\fswiss\fcharset161\fprq2 Arial Greek;}{\f50\fswiss\fcharset162\fprq2 Arial Tur;}{\f51\fswiss\fcharset177\fprq2 Arial (Hebrew);}{\f52\fswiss\fcharset178\fprq2 Arial (Arabic);}
{\f53\fswiss\fcharset186\fprq2 Arial Baltic;}{\f54\fswiss\fcharset163\fprq2 Arial (Vietnamese);}{\f56\fmodern\fcharset238\fprq1 Courier New CE;}{\f57\fmodern\fcharset204\fprq1 Courier New Cyr;}{\f59\fmodern\fcharset161\fprq1 Courier New Greek;}
{\f60\fmodern\fcharset162\fprq1 Courier New Tur;}{\f61\fmodern\fcharset177\fprq1 Courier New (Hebrew);}{\f62\fmodern\fcharset178\fprq1 Courier New (Arabic);}{\f63\fmodern\fcharset186\fprq1 Courier New Baltic;}
{\f64\fmodern\fcharset163\fprq1 Courier New (Vietnamese);}}{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;
\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}{\stylesheet{
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1030\langfe1030\cgrid\langnp1030\langfenp1030 \snext0 \styrsid15412100 Normal;}{
\s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 \b\f1\fs28\lang1030\langfe1030\kerning28\cgrid\langnp1030\langfenp1030 \sbasedon0 \snext0 heading 1;}{\*\cs10 \additive 
\ssemihidden \styrsid15412100 Default Paragraph Font;}{\*
\ts11\tsrowd\trftsWidthB3\trpaddl108\trpaddr108\trpaddfl3\trpaddft3\trpaddfb3\trpaddfr3\trcbpat1\trcfpat1\tscellwidthfts0\tsvertalt\tsbrdrt\tsbrdrl\tsbrdrb\tsbrdrr\tsbrdrdgl\tsbrdrdgr\tsbrdrh\tsbrdrv 
\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs20\lang1024\langfe1024\cgrid\langnp1024\langfenp1024 \snext11 \ssemihidden Normal Table;}{\s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1500\cbpat8 
\f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1030 \snext15 VDM;}{\*\cs16 \additive \f5 \sbasedon10 VDM_COV;}{\*\cs17 \additive \f5\cf16 \sbasedon10 VDM_NCOV;}{\s18\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 
\shading1500\cbpat8 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1030 \sbasedon15 \snext18 VDM_TC_TABLE;}{\s19\ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 
\f2\fs24\lang2057\langfe1030\cgrid\langnp2057\langfenp1030 \sbasedon0 \snext19 Plain Text;}}{\*\latentstyles\lsdstimax156\lsdlockeddef0}{\*\rsidtbl \rsid4993607\rsid15412100}{\*\generator Microsoft Word 11.0.5604;}{\info
{\title Default Rose-VDM++ Link forward engineering file}{\author IFAD VDM Tools}{\operator Peter Gorm Larsen}{\creatim\yr1998\mo10\dy16\hr14\min8}{\revtim\yr2006\mo1\dy2\hr8\min14}{\version34}{\edmins166}{\nofpages6}{\nofwords1544}{\nofchars9419}
{\*\company IFAD}{\nofcharsws10942}{\vern24689}}\margl1134\margr1134\margt1701\margb1701 \widowctrl\ftnbj\aenddoc\hyphhotz425\noxlattoyen\expshrtn\noultrlspc\dntblnsbdb\nospaceforul\linkstyles\hyphcaps0\formshade\horzdoc\dghspace120\dgvspace120
\dghorigin1701\dgvorigin1984\dghshow0\dgvshow3\jcompress\viewkind4\viewscale100\pgbrdrhead\pgbrdrfoot\nolnhtadjtbl\rsidroot15412100 \fet0\sectd \linex0\headery709\footery709\colsx709\endnhere\sectdefaultcl\sftnbj {\*\pnseclvl1
\pnucrm\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl2\pnucltr\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl3\pndec\pnstart1\pnindent720\pnhang {\pntxta .}}{\*\pnseclvl4\pnlcltr\pnstart1\pnindent720\pnhang {\pntxta )}}{\*\pnseclvl5
\pndec\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl6\pnlcltr\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl7\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}{\*\pnseclvl8\pnlcltr\pnstart1\pnindent720\pnhang 
{\pntxtb (}{\pntxta )}}{\*\pnseclvl9\pnlcrm\pnstart1\pnindent720\pnhang {\pntxtb (}{\pntxta )}}\pard\plain \s1\ql \li0\ri0\sb240\sa60\keepn\widctlpar\aspalpha\aspnum\faauto\outlinelevel0\adjustright\rin0\lin0\itap0 
\b\f1\fs28\lang1030\langfe1030\kerning28\cgrid\langnp1030\langfenp1030 {\lang2057\langfe1030\langnp2057\insrsid15412100 The }{\lang2057\langfe1030\langnp2057\insrsid15412100\charrsid15412100 Station}{\lang2057\langfe1030\langnp2057\insrsid15412100  Class

\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1030\langfe1030\cgrid\langnp1030\langfenp1030 {\lang2057\langfe1030\langnp2057\insrsid15412100\charrsid15412100 
\par }\pard\plain \s15\ql \li0\ri0\widctlpar\faauto\adjustright\rin0\lin0\itap0 \shading1500\cbpat8 \f2\fs20\lang1024\langfe1024\cgrid\noproof\langnp1033\langfenp1030 {\insrsid15412100 class Station
\par 
\par instance variables
\par   lay : Layout;
\par   pointdir : map TrackId to Track`Direction;
\par   trainmap : map Train`TrainId to Train;
\par }{\lang1024\langfe1024\langnp1030\insrsid15412100\charrsid15412100 inv forall tid1, tid2 in set dom trainmap & 
\par            tid1 <> tid2 => trainmap(tid1) <> trainmap(tid2);
\par   }{\insrsid15412100 pointstate : map TrackId to PointState;
\par   routestate : map Route`RouteId to RouteState;
\par   trackstate : map TrackId to TrackState;
\par inv \tab Train_Consistent(lay, trainmap, pointdir) and
\par \tab Train_Detected(trackstate, trainmap) and
\par \tab Point_Locked(lay, pointstate, trackstate) and
\par \tab Route_Locked(lay, routestate, pointdir, pointstate);
\par 
\par types
\par 
\par   public TrackId = token;
\par 
\par   RouteState = <FREE> | <STANDBY> | <BUSY>;
\par   PointState = <P_Lock> | <P_Free>;
\par   TrackState = <ON> | <OFF>;
\par 
\par \tab \tab 
\par functions
\par 
\par   Train_Detected : (map TrackId to TrackState) * 
\par                    (map Train`TrainId to Train) -> bool
\par   Train_Detected (track_state, train) ==
\par \tab forall tr in set rng train & 
\par \tab  \tab forall tcid in set elems tr.GetBody() &
\par \tab \tab \tab tcid in set dom track_state and
\par \tab \tab \tab track_state(tcid) = <ON>
\par ;
\par 
\par Train_Consistent : Layout * (map Train`TrainId to Train) * 
\par                    (map TrackId to Track`Direction) -> bool
\par Train_Consistent (lay, train, pointdir) ==
\par \tab (forall tr in set rng train &
\par \tab \tab (forall tcid in set elems tr.GetBody() &
\par \tab \tab \tab tcid in set dom lay.GetTracks() and
\par \tab \tab \tab tcid in set dom pointdir)) and
\par \tab forall tr in set rng train &
\par \tab     (forall i in set inds tr.GetBody() &
\par \tab  \tab i + 1 in set inds tr.GetBody() =>
\par \tab \tab     lay.GetTracks()(tr.GetBody()(i)).
\par                 GetSegments()(pointdir(tr.GetBody()(i))) inter
\par \tab \tab     lay.GetTracks()(tr.GetBody()(i+1)).
\par                 GetSegments()(pointdir(tr.GetBody()(i+1))) <> \{\}) and
\par \tab     tr.GetHead() in set lay.GetTracks()
\par          (hd tr.GetBody()).GetSegments()(pointdir(hd tr.GetBody())) and
\par \tab     (2 in set inds tr.GetBody() => 
\par \tab      tr.GetHead() not in set
\par            lay.GetTracks()(tr.GetBody()(2)).
\par            GetSegments()(pointdir(tr.GetBody()(2))));
\par 
\par 
\par Point_Locked : Layout * (map TrackId to PointState) * 
\par                (map TrackId to TrackState) -> bool
\par Point_Locked(lay, point_state, track_state) ==
\par \tab dom track_state = dom lay.GetTracks() and
\par \tab dom point_state = dom lay.GetTracks() and
\par \tab forall tid in set dom lay.GetTracks() &
\par \tab \tab track_state(tid) = <ON> =>
\par \tab \tab forall pid in set dom lay.GetTracks() &
\par \tab \tab \tab tid in set lay.GetTracks()(pid).GetTCLock() =>
\par \tab \tab \tab (pid in set dom point_state and
\par \tab \tab \tab point_state(pid) = <P_Lock>);
\par 
\par Route_Locked: Layout * (map Route`RouteId to RouteState) * 
\par               (map TrackId to Track`Direction) * 
\par               (map TrackId to PointState) -> bool
\par Route_Locked(lay, route_state, point_dir, point_lock) ==
\par \tab dom route_state = dom lay.GetRoutes() and
\par \tab dom point_dir = dom lay.GetTracks() and
\par \tab (forall tcid in set dom lay.GetTracks() &
\par \tab \tab point_dir(tcid) in set dom 
\par                           lay.GetTracks()(tcid).GetSegments()) and
\par \tab forall rid in set dom lay.GetRoutes() & 
\par              let r = lay.GetRoutes()(rid) in
\par \tab (route_state(rid) <> <FREE> =>
\par \tab \tab ((dom r.GetPoints()) <: point_dir = r.GetPoints() and
\par \tab \tab rng ((dom r.GetPoints()) <: point_lock) = \{<P_Lock>\}) and
\par \tab \tab (forall rid1 in set r.GetLock() &
\par                     route_state(rid1)=<FREE>))
\par ;
\par 
\par operations
\par 
\par Is_safe : () ==> bool
\par Is_safe() ==
\par   return Train_not_collide(trainmap) and
\par          Route_not_collide(lay,routestate);
\par 
\par functions
\par 
\par Train_not_collide : map Train`TrainId to Train -> bool
\par Train_not_collide(train) ==
\par \tab forall tr1, tr2 in set dom train &
\par \tab tr1 = tr2 or
\par \tab elems train(tr1).GetBody() inter elems train(tr2).GetBody() = \{\};
\par \tab 
\par Route_not_collide : Layout * (map Route`RouteId to RouteState) -> bool
\par Route_not_collide(lay, route_state) ==
\par \tab dom route_state = dom lay.GetRoutes() and
\par \tab forall rid1, rid2 in set dom lay.GetRoutes() & 
\par \tab \tab (rid1 <> rid2 and
\par \tab \tab route_state(rid1) <> <FREE> and 
\par \tab \tab route_state(rid2) <> <FREE>) =>
\par \tab let r1 = lay.GetRoutes()(rid1), 
\par           r2 = lay.GetRoutes()(rid2) in
\par \tab (forall p in set dom r1.GetPoints() inter dom r2.GetPoints() &
\par \tab \tab r1.GetPoints()(p) = r2.GetPoints()(p)) and
\par \tab  elems r1.GetPartRoutes() inter elems r2.GetPartRoutes() <> \{\};
\par 
\par operations
\par 
\par Routing : Route`RouteId ==> ()
\par Routing(rid) ==
\par   let r = lay.GetRoutes()(rid) in \tab 
\par     let r_state = routestate ++ \{rid |-> <STANDBY>\},
\par \tab   p_dir = pointdir ++ r.GetPoints(),
\par \tab   p_lock = pointstate ++ 
\par \tab \tab \tab \{p |-> <P_Lock> | p in set dom r.GetPoints()\} in
\par \tab atomic (
\par         routestate := r_state;
\par         pointdir := p_dir;
\par         pointstate := p_lock)
\par pre rid in set dom lay.GetRoutes() and
\par     routestate(rid) = <FREE> and
\par     let r = lay.GetRoutes()(rid) in 
\par \tab (forall rid in set r.GetLock() & routestate(rid) = <FREE>) and
\par \tab (forall pid in set dom r.GetPoints() &
\par \tab \tab pointdir(pid) = r.GetPoints()(pid) or 
\par \tab \tab pointstate(pid) = <P_Free> and
\par \tab \tab forall tid in set lay.GetTracks()(pid).GetTCLock() &
\par \tab \tab \tab  trackstate(tid) = <OFF>);
\par 
\par Route_Free_with_ID : Route`RouteId ==> ()
\par Route_Free_with_ID(rid) ==
\par   (routestate := routestate ++ \{rid |-> <FREE>\};
\par    Point_Release())
\par pre\tab rid in set dom lay.GetRoutes() and
\par \tab (routestate(rid) = <STANDBY> or
\par \tab  routestate(rid) = <BUSY>) and
\par \tab forall tid in set elems lay.GetRoutes()(rid).GetPartRoutes() &
\par \tab \tab trackstate(tid) = <OFF>;
\par 
\par Route_Free : () ==> ()
\par Route_Free() ==
\par   (routestate := routestate ++ 
\par \tab   \tab      \{rid |-> <FREE> | rid in set dom lay.GetRoutes() &
\par \tab \tab \tab                  routestate(rid) = <BUSY> and
\par \tab \tab \tab                  forall tid in set elems 
\par                                            lay.GetRoutes()(rid).
\par                                            GetPartRoutes() &
\par \tab \tab \tab \tab            trackstate(tid) = <OFF>\};
\par    Point_Release());
\par 
\par Point_Release : () ==> ()
\par Point_Release() ==
\par   let new_point = \{pid |-> <P_Free> | pid in set dom lay.GetTracks() &
\par \tab \tab (not exists rid in set dom (routestate :-> \{<FREE>\}) &
\par \tab \tab \tab pid in set dom lay.GetRoutes()(rid).GetPoints()) and
\par \tab \tab (forall tcid in set lay.GetTracks()(pid).GetTCLock() &
\par \tab \tab \tab trackstate(tcid) = <OFF>)\} in
\par \tab pointstate := pointstate ++ new_point;
\par 
\par Route_Enter : Train`TrainId ==> ()
\par Route_Enter(tid) ==
\par   let t = trainmap(tid) in
\par     let mk_(newhead, tcid) = 
\par \tab \tab Next_TrackC(lay.GetTracks(),t.GetHead(),t.GetBody()(1),pointdir)
\par     in
\par \tab let new_train = t.AddTrack(newhead,tcid), 
\par \tab     new_point = \{pid |-> <P_Lock> 
\par                       | pid in set dom lay.GetTracks() 
\par                       & tcid in set lay.GetTracks()(pid).GetTCLock()\}
\par       in
\par \tab   let rid in set dom lay.GetRoutes() be st
\par \tab \tab routestate(rid) = <STANDBY> and
\par \tab \tab let r = lay.GetRoutes()(rid).GetAllRoute() in 
\par \tab \tab tcid = r(len r) and
\par \tab \tab t.GetBody()(1) not in set elems r in
\par \tab    atomic (
\par            routestate := \{rid |-> <BUSY>\};
\par \tab      trainmap := trainmap ++ \{tid |-> new_train\};
\par \tab      trackstate := trackstate ++ \{tcid|-> <ON>\};
\par \tab      pointstate := pointstate ++ new_point)
\par 
\par pre\tab tid in set dom trainmap and
\par \tab let t = trainmap(tid) in
\par \tab pre_Next_TrackC(lay.GetTracks(),t.GetHead(),t.GetBody()(1),
\par                       pointdir) and
\par \tab let mk_(-, tcid) =
\par           Next_TrackC(lay.GetTracks(),t.GetHead(),
\par                       t.GetBody()(1),pointdir)
\par \tab in
\par \tab \tab exists1 rid in set dom lay.GetRoutes() &
\par \tab \tab \tab routestate(rid) = <STANDBY> and 
\par \tab \tab \tab let r = lay.GetRoutes()(rid).GetAllRoute() in
\par \tab \tab \tab tcid = r(len r) and
\par \tab \tab \tab t.GetBody()(1) not in set elems r;
\par 
\par 
\par Train_f_Go : Train`TrainId ==> ()
\par Train_f_Go(tid) ==
\par   let t = trainmap(tid) in
\par     let mk_(newhead, tcid) = 
\par \tab Next_TrackC(lay.GetTracks(),t.GetHead(),t.GetBody()(1),pointdir)
\par     in
\par \tab let new_train = t.AddTrack(newhead,tcid),
\par \tab     new_point = \{pid |-> <P_Lock> 
\par                       | pid in set dom lay.GetTracks() 
\par \tab \tab \tab     & tcid in set lay.GetTracks()(pid).GetTCLock()\}
\par       in
\par \tab   atomic (
\par           trainmap := trainmap ++ \{tid |-> new_train\};
\par \tab     trackstate := trackstate ++ \{tcid |-> <ON>\};
\par           pointstate := pointstate ++ new_point)
\par 
\par pre\tab tid in set dom trainmap and
\par \tab let t = trainmap(tid) in
\par \tab pre_Next_TrackC(lay.GetTracks(),t.GetHead(),t.GetBody()(1),
\par                       pointdir) and
\par \tab let mk_(-, tcid) = 
\par                       Next_TrackC(lay.GetTracks(),t.GetHead(),
\par                                   t.GetBody()(1),pointdir)
\par \tab in
\par \tab ((exists1 rid in set dom lay.GetRoutes() &
\par \tab        (routestate(rid) =<BUSY>) and
\par \tab \tab   let r = lay.GetRoutes()(rid) in
\par \tab \tab   exists i in set inds r.GetAllRoute() &
\par \tab \tab \tab i + 1 in set inds r.GetAllRoute() and
\par \tab \tab \tab tcid = r.GetAllRoute()(i) and
\par \tab \tab \tab t.GetBody()(1) = r.GetAllRoute()(i + 1)) or
\par \tab    (forall rid in set dom lay.GetRoutes() &
\par \tab \tab tcid not in set elems lay.GetRoutes()(rid).
\par             GetPartRoutes()));
\par 
\par functions
\par 
\par Next_TrackC : (map TrackId to Track) * Track`Node * TrackId * 
\par               (map TrackId to Track`Direction) -> Track`Node * TrackId
\par Next_TrackC(tcs, n, tcid, dir) ==
\par \tab let tcid1 in set dom tcs be st
\par \tab \tab n in set tcs(tcid1).GetSegments()(dir(tcid1)) and
\par \tab \tab tcid1 <> tcid 
\par \tab in let n1 in set tcs(tcid1).GetSegments()(dir(tcid1)) be st 
\par \tab \tab n1 <> n
\par \tab in mk_(n1, tcid1)
\par pre\tab tcid in set dom tcs and
\par \tab (forall tcid1 in set dom tcs &
\par \tab \tab tcid1 in set dom dir and
\par \tab \tab dir(tcid1) in set dom tcs(tcid1).GetSegments()) and
\par \tab n in set tcs(tcid).GetSegments()(dir(tcid)) and
\par \tab exists tcid1 in set dom tcs &
\par \tab \tab n in set tcs(tcid1).GetSegments()(dir(tcid1)) and
\par \tab \tab tcid1 <> tcid;
\par 
\par operations
\par 
\par Train_b_Go : Train`TrainId ==> ()
\par Train_b_Go(tid) ==
\par   let t = trainmap(tid) in
\par     (trainmap := trainmap ++ \{tid |-> t.DelTrack()\};
\par      trackstate := trackstate ++ 
\par \tab \tab \tab  \{t.GetB}{\insrsid15412100 ody()(len t.GetBody()) |-> <OFF}{\insrsid15412100 >\};
\par      Route_Free())
\par pre\tab tid in set dom trainmap and 
\par \tab len trainmap(tid).GetBody() > 1;
\par 
\par 
\par Train_Occur : Route`RouteId * Train`TrainId ==> ()
\par Train_Occur(rid, tid) ==
\par   let r = lay.GetRoutes()(rid).GetAllRoute() in
\par \tab let tcid = r(len r) in
\par \tab let new_point = \{pid |-> <P_Lock> 
\par                       | pid in set dom lay.GetTracks() 
\par \tab \tab \tab     & tcid in set lay.GetTracks()(pid).GetTCLock()\} in
\par \tab let node in set lay.GetTracks()(tcid).GetSegments()
\par                        (pointdir(tcid)) be st
\par \tab     node in set lay.GetTracks()(r(len r - 1)).GetSegments()
\par                       (pointdir(r(len r - 1))) in
\par \tab atomic (
\par        trainmap := trainmap ++ \{tid |-> new Train().Init(node,[tcid])\};
\par        routestate := routestate ++ \{rid |-> <BUSY>\};
\par \tab  trackstate := trackstate ++ \{tcid |-> <ON>\};
\par \tab  pointstate := pointstate ++ new_point)
\par 
\par pre \tab tid not in set dom trainmap and
\par \tab rid in set dom lay.GetRoutes() and
\par \tab let r = lay.GetRoutes()(rid).GetAllRoute() in
\par \tab (not exists tcid in set dom lay.GetTracks() & 
\par \tab \tab tcid <> r(len r - 1) and 
\par \tab \tab tcid <> r(len r) and
\par \tab \tab lay.GetTracks()(r(len r)).GetSegments()(pointdir(r(len r)))
\par \tab \tab \tab inter dunion rng lay.GetTracks()(tcid).GetSegments() <> \{\}) and
\par \tab routestate(rid) = <STANDBY>;
\par 
\par Train_Disappear : Train`TrainId ==> ()
\par Train_Disappear(tid) ==
\par   let t = trainmap(tid) in
\par     let tcid = hd t.GetBody() in
\par \tab (atomic (
\par          trainmap := \{tid\} <-: trainmap;
\par \tab    trackstate }{\insrsid15412100 := trackstate ++ \{tcid |-> <OFF}{\insrsid15412100 >\});
\par        Route_Free())
\par pre \tab tid in set dom trainmap and
\par \tab let t = trainmap(tid) in 
\par \tab len t.GetBody() = 1 and
\par \tab not pre_Next_TrackC(lay.GetTracks(), t.GetHead(), 
\par                           hd t.GetBody(), pointdir);
\par 
\par end Station
\par }\pard\plain \ql \li0\ri0\widctlpar\aspalpha\aspnum\faauto\adjustright\rin0\lin0\itap0 \fs24\lang1030\langfe1030\cgrid\langnp1030\langfenp1030 {\lang2057\langfe1030\langnp2057\insrsid15412100\charrsid15412100 
\par }}