\kClass $AreaController$ \kISO $GLOBAL$
\par
\kInstanceVarDef
\parlinebr
\begin{insvar}
\assdef{id}{Aid}
\end{insvar}
\begin{insvar}
\assdef{boats}{\mapof{Bid\Gmap Lifeboat}}[{\Emptymap }]
\end{insvar}
\begin{insvar}
\assdef{equip}{\setof{FireEquipment}}[{\set{}}]
\end{insvar}
\begin{insvar}
\assdef{pStay}{\mapof{Pid\Gmap Person}}[{\Emptymap }]
\end{insvar}
\begin{insvar}
\assdef{pTransit}{\setof{tPerson}}[{\set{}}]
\end{insvar}
\begin{insvar}
\assdef{stayCap}{\Nat }[{0}]
\end{insvar}
\begin{insvar}
\assdef{transCap}{\Nat }[{0}]
\end{insvar}
\begin{insvar}
\assdef{busy}{\Bool }[{\True }]
\end{insvar}
\begin{instinvfn}
 \Card  \Dom pStay \Le stayCap\end{instinvfn}
\begin{instinvfn}
 \Card pTransit \Le transCap\end{instinvfn}
\par
\kTypes
\begin{record}{tPerson}person :{Pid} \\
outTime :{\Nat } \\
late :{\Bool } \\
\end{record}
\kOperations
\kw{\kw{public}}\begin{op}[e]{AreaController}%
\signature{Aid \Oto AreaController}
\parms{aid}
\annlab[o]{AreaController`AreaController}
\begin{blockstmt}
\ass{id}{aid} ; \\
\ass{transCap}{2}
\end{blockstmt};
\end{op}
\kw{\kw{public}}\begin{op}[e]{step}%
\signature{() \Oto ()}
\parms{}
\annlab[o]{AreaController`step}
\begin{blockstmt}
\begin{dclstmt}
\assdef{curtime}{Time}[{\fnapply{World`timer.GetTime}{}}]
\end{dclstmt}
\call{boatMaintenance}{} ; \\
\begin{setfor}{p}{pTransit}
\If p.outTime \Le curtime \And  \Not p.late
\Then \\
\begin{blockstmt}
\begin{dclstmt}
\assdef{ap}{tPerson}[{\recmod{p}{late \Mapsto \True }}]
\end{dclstmt}
\ass{pTransit}{pTransit \Setdiff \set{p}} ; \\
\ass{pTransit}{pTransit \Union \set{ap}} ; \\
World`env.\call{addOutline}{\reccons{\kw{mk\textunderscore}} \\
{ \\
curtime, \\
\Dquote Error\hspace{0.5em}person\hspace{0.5em}stayed\hspace{0.5em}too\hspace{0.5em}long\hspace{0.5em} \Dquote , \\
id, \\
p.person, \\
p.outTime, \\
\Quote {\backslash}n \Quote }}
\end{blockstmt}
\Fi
\end{setfor}
\end{blockstmt};
\end{op}
\kw{\kw{public}}\begin{op}[e]{isFinished}%
\signature{() \Oto ()}
\parms{}
\annlab[o]{AreaController`isFinished}
\ass{busy}{\False };
\end{op}
\kw{\kw{public}}\begin{op}[e]{getId}%
\signature{() \Oto Aid}
\parms{}
\annlab[o]{AreaController`getId}
\return{id};
\end{op}
\kw{\kw{public}}\begin{op}[e]{addEquipment}%
\signature{FireEquipment \Oto ()}
\parms{fe}
\annlab[o]{AreaController`addEquipment}
\ass{equip}{\set{fe} \Union equip};
\end{op}
\kw{\kw{public}}\begin{op}[e]{removeEquipment}%
\signature{FireEquipment \Oto ()}
\parms{fe}
\annlab[o]{AreaController`removeEquipment}
\ass{equip}{equip \Setdiff \set{fe}}
\begin{precond}
stayCap \Minus  \Card  \Dom pStay > 0
\end{precond};
\end{op}
\kw{\kw{public}}\begin{op}[e]{canRemoveEquipment}%
\signature{() \Oto \Bool }
\parms{}
\annlab[o]{AreaController`canRemoveEquipment}
\begin{blockstmt}
\call{updateCap}{} ; \\
\If  \Card equip > stayCap
\Then \\
\return{\True }
\Else \\
\return{\pex{stayCap \Minus 1 \Minus  \Card  \Dom pStay} \Ge 0}
\Fi
\end{blockstmt};
\end{op}
\kw{\kw{public}}\begin{op}[e]{addBoat}%
\signature{Lifeboat \Oto ()}
\parms{boat}
\annlab[o]{AreaController`addBoat}
\begin{blockstmt}
\ass{boats}{boats \Mapmerge \map{\fnapply{boat.getId}{} \Mapsto boat}} ; \\
$boat$.\call{addArea}{id}
\end{blockstmt}
\begin{precond}
\fnapply{boat.getId}{} \Notin  \Dom boats
\end{precond};
\end{op}
\kw{\kw{public}}\begin{op}[e]{canRemoveBoat}%
\signature{Bid \Oto \Bool }
\parms{boat}
\annlab[o]{AreaController`canRemoveBoat}
\begin{blockstmt}
\return{ \Card \pex{\fnapply{\fnapply{ORAMS`Lifeboats}{boat}.getCrew}{} \Inter  \Dom pStay} <  \\
\fnapply{getCap}{ \Dom \pex{\set{boat} \Dby boats}}}
\end{blockstmt};
\end{op}
\kw{\kw{public}}\begin{op}[e]{removeBoat}%
\signature{Bid \Oto ()}
\parms{bid}
\annlab[o]{AreaController`removeBoat}
\begin{blockstmt}
\fnapply{boats}{bid}.\call{disable}{} ; \\
\begin{letstmt}
\patdef{ps}{\fnapply{\fnapply{boats}{bid}.getInterCrew}{ \Dom pStay}}
\end{letstmt} \\
\begin{setfor}{p}{ps}
\call{changeBoat}{p}
\end{setfor} ; \\
\fnapply{boats}{bid}.\call{removeArea}{id} ; \\
\fnapply{boats}{bid}.\call{enable}{} ; \\
\ass{boats}{\set{bid} \Dby boats}
\end{blockstmt}
\begin{precond}
id \In  \Dom boats \And \fnapply{canRemoveBoat}{bid}
\end{precond}
\begin{postcond}
id \Notin  \Dom boats
\end{postcond};
\end{op}
\kw{\kw{public}}\begin{op}[e]{leave}%
\signature{Pid \Oto ()}
\parms{person}
\annlab[o]{AreaController`leave}
\If \pex{\exists{p \In  \Dom pStay}{p = person}}
\Then \\
\begin{blockstmt}
\ass{pStay}{\set{person} \Dby pStay}
\end{blockstmt}
\Elseif \pex{\exists{p \In pTransit}{p.person = person}}
\Then \\
\begin{blockstmt}
\Letbe\hspace{0.5em}pT \In pTransit \Best\hspace{0.5em}pT.person = person \Lin \\
\ass{pTransit}{pTransit \Setdiff \set{pT}}
\end{blockstmt}
\Fi
\begin{precond}
person \In  \Dom pStay \Or \exists{p \In pTransit}{p.person = person}
\end{precond};
\end{op}
\kw{\kw{public}}\begin{op}[e]{changeBoat}%
\signature{Pid \Oto ()}
\parms{p}
\annlab[o]{AreaController`changeBoat}
\begin{blockstmt}
\begin{letstmt}
\patdef{b}{\fnapply{\fnapply{pStay}{p}.getBoat}{}}
\end{letstmt} \\
\begin{blockstmt}
\begin{letstmt}
\patdef{newBoat}{\fnapply{findBoat}{b}}
\end{letstmt} \\
\begin{blockstmt}
\fnapply{ORAMS`Lifeboats}{b}.\call{removePerson}{p} ; \\
\fnapply{boats}{newBoat}.\call{addPerson}{p} ; \\
\fnapply{pStay}{p}.\call{changeBoat}{newBoat}
\end{blockstmt}
\end{blockstmt}
\end{blockstmt};
\end{op}
\kw{\kw{public}}\begin{op}[e]{enterPerson}%
\signature{Pid \X Intend \Oto \Bool }
\parms{person,intend}
\annlab[o]{AreaController`enterPerson}
\begin{blockstmt}
\call{updateCap}{} ; \\
\begin{Cases}{intend}
\alt{\const{Stay}}{\return{\fnapply{doAddStaying}{person}}}
\alt{\const{Transit}}{\return{\fnapply{doAddTransit}{person}}}
\end{Cases}
\end{blockstmt}
\begin{precond}
person \Notin  \Dom pStay \Or  \\
\exists{p \In pTransit}{p.person = person}
\end{precond};
\end{op}
\kw{\kw{private}}\begin{op}[e]{doAddStaying}%
\signature{Pid \Oto \Bool }
\parms{person}
\annlab[o]{AreaController`doAddStaying}
\If \fnapply{isRoomForStay}{}
\Then \\
\begin{blockstmt}
\begin{letstmt}
\patdef{boat}{\fnapply{findBoat}{}}
\end{letstmt} \\
\begin{blockstmt}
\fnapply{boats}{boat}.\call{addPerson}{person} ; \\
\ass{pStay}{\map{person \Mapsto \fnapply{ORAMS`persons}{person}} \Mapmerge pStay} ; \\
\If \fnapply{\fnapply{pStay}{person}.getArea}{} \Neq \Nil 
\Then \\
\fnapply{ORAMS`areas}{\fnapply{\fnapply{ORAMS`persons}{person}.getArea}{}}.\call{leave}{person}
\Fi ; \\
\If \fnapply{\fnapply{pStay}{person}.getBoat}{} \Neq \Nil 
\Then \\
\fnapply{ORAMS`Lifeboats}{\fnapply{\fnapply{ORAMS`persons}{person}.getBoat}{}}.\call{removePerson}{person}
\Fi ; \\
\fnapply{pStay}{person}.\call{changeArea}{\fnapply{\pex{\mapinv{ORAMS`areas}}}{\kSelf }} ; \\
\fnapply{pStay}{person}.\call{changeBoat}{boat} ; \\
\return{\True }
\end{blockstmt}
\end{blockstmt}
\Else \\
\return{\False }
\Fi;
\end{op}
\kw{\kw{private}}\begin{op}[e]{doAddTransit}%
\signature{Pid \Oto \Bool }
\parms{person}
\annlab[o]{AreaController`doAddTransit}
\If \fnapply{isRoomForTransit}{}
\Then \\
\begin{blockstmt}
\begin{dclstmt}
\assdef{p}{tPerson}[{\reccons{\kw{mk\textunderscore} tPerson}{person, \\
\fnapply{World`timer.GetTime}{} + 100,\False }}]
\end{dclstmt}
\ass{pTransit}{\set{p} \Union pTransit} ; \\
\If \fnapply{\fnapply{ORAMS`persons}{person}.getArea}{} \Neq \Nil 
\Then \\
\fnapply{ORAMS`areas}{\fnapply{\fnapply{ORAMS`persons}{person}.getArea}{}}.\call{leave}{person}
\Fi ; \\
\fnapply{ORAMS`persons}{person}.\call{changeArea}{\fnapply{\pex{\mapinv{ORAMS`areas}}}{\kSelf }} ; \\
\return{\True }
\end{blockstmt}
\Else \\
\return{\False }
\Fi;
\end{op}
\kw{\kw{private}}\begin{op}[e]{findBoat}%
\signature{Bid \Oto Bid}
\parms{b}
\annlab[o]{AreaController`findBoat}
\begin{blockstmt}
\begin{letstmt}
\patdef{bids}{\set{b} \Dby boats}
\end{letstmt} \\
\begin{blockstmt}
\begin{letstmt}
\patdef{bs}{\setcomp{boat}{boat \In  \Dom bids} \\
[\fnapply{\fnapply{bids}{boat}.getRemainingCap}{} > 0]}
\end{letstmt} \\
\begin{blockstmt}
\If \exists{boat \In bs}{\fnapply{\fnapply{boats}{boat}.isDedicated}{}}
\Then \\
\begin{blockstmt}
\Letbe\hspace{0.5em}boat \In bs \Best\hspace{0.5em}\fnapply{\fnapply{boats}{boat}.isDedicated}{} \Lin \\
\return{boat}
\end{blockstmt}
\Else \\
\begin{blockstmt}
\Letbe* boat \In bs \Lin \\
\return{boat}
\end{blockstmt}
\Fi
\end{blockstmt}
\end{blockstmt}
\end{blockstmt};
\end{op}
\kw{\kw{private}}\begin{op}[e]{findBoat}%
\signature{() \Oto Bid}
\parms{}
\annlab[o]{AreaController`findBoat}
\begin{blockstmt}
\begin{letstmt}
\patdef{bs}{\setcomp{b}{b \In  \Dom boats}[\fnapply{\fnapply{boats}{b}.getRemainingCap}{} > 0]}
\end{letstmt} \\
\begin{blockstmt}
\If \exists{b \In bs}{\fnapply{\fnapply{boats}{b}.isDedicated}{}}
\Then \\
\begin{blockstmt}
\Letbe\hspace{0.5em}b \In bs \Best\hspace{0.5em}\fnapply{\fnapply{boats}{b}.isDedicated}{} \Lin \\
\return{b}
\end{blockstmt}
\Else \\
\begin{blockstmt}
\Letbe* b \In bs \Lin \\
\return{b}
\end{blockstmt}
\Fi
\end{blockstmt}
\end{blockstmt};
\end{op}
\kw{\kw{private}}\begin{op}[e]{boatMaintenance}%
\signature{() \Oto ()}
\parms{}
\annlab[o]{AreaController`boatMaintenance}
\begin{blockstmt}
\begin{dclstmt}
\assdef{remCap}{\Nat }[{0}]
\end{dclstmt}
\begin{letstmt}
\patdef{bs}{\setcomp{b}{b \In  \Rng boats}[\fnapply{b.isDedicated}{}]}
\end{letstmt} \\
\begin{blockstmt}
\begin{setfor}{b}{bs}
\ass{remCap}{remCap + \fnapply{b.getRemainingCap}{}}
\end{setfor} ; \\
\If remCap > 0
\Then \\
\begin{blockstmt}
\begin{letstmt}
\patdef{sharedBoats}{ \Rng boats \Setdiff bs}
\end{letstmt} \\
\begin{blockstmt}
\begin{dclstmt}
\assdef{crew}{\setof{Pid}}[{ \Dunion \setcomp{\fnapply{cs.getInterCrew}{ \Dom pStay}}{cs \In sharedBoats}}]
\end{dclstmt}
\begin{while}{remCap > 0 \And crew \Neq \set{}}
\begin{blockstmt}
\Letbe* p \In crew \Lin \\
\begin{blockstmt}
\call{changeBoat}{p} ; \\
\ass{crew}{crew \Setdiff \set{p}}
\end{blockstmt} ; \\
\ass{remCap}{remCap \Minus 1}
\end{blockstmt}
\end{while}
\end{blockstmt}
\end{blockstmt}
\Fi
\end{blockstmt}
\end{blockstmt};
\end{op}
\kw{\kw{private}}\begin{op}[e]{isRoomForStay}%
\signature{() \Oto \Bool }
\parms{}
\annlab[o]{AreaController`isRoomForStay}
\begin{blockstmt}
\call{updateCap}{} ; \\
\return{stayCap \Minus  \Card  \Dom pStay > 0}
\end{blockstmt};
\end{op}
\kw{\kw{private}}\begin{op}[e]{isRoomForTransit}%
\signature{() \Oto \Bool }
\parms{}
\annlab[o]{AreaController`isRoomForTransit}
\return{transCap \Minus  \Card pTransit > 0};
\end{op}
\kw{\kw{private}}\begin{op}[e]{updateCap}%
\signature{() \Oto ()}
\parms{}
\annlab[o]{AreaController`updateCap}
\begin{blockstmt}
\begin{dclstmt}
\assdef{bCap}{\Nat }[{0}]
\end{dclstmt}
\begin{setfor}{b}{ \Dom boats}
\ass{bCap}{bCap + \fnapply{\fnapply{ORAMS`Lifeboats}{b}.getRemainingCap}{}}
\end{setfor} ; \\
\ass{stayCap}{\fnapply{min}{bCap +  \Card  \Dom pStay, \Card equip}}
\end{blockstmt};
\end{op}
\kw{\kw{private}}\begin{op}[e]{getCap}%
\signature{\setof{Bid} \Oto \Nat }
\parms{bs}
\annlab[o]{AreaController`getCap}
\begin{blockstmt}
\begin{dclstmt}
\assdef{bCap}{\Nat }[{0}]
\end{dclstmt}
\begin{setfor}{b}{bs}
\ass{bCap}{bCap + \fnapply{\fnapply{boats}{b}.getRemainingCap}{}}
\end{setfor} ; \\
\return{bCap}
\end{blockstmt}
\end{op}
\kFunctions
\kw{\kw{private}}\begin{fn}[e]{min}%
\signature{\Nat  \X \Nat  \Pto \Nat }
\parms*{\Lp n1,n2\Rp }
\annlab[o]{AreaController`min}
\If n1 < n2
\Then \\
n1
\Else \\
n2
\Fi
\end{fn}
\kSync
\per{isFinished}{\actminusfin{step} = 0}
\kThreadDef
\begin{thread}
\begin{blockstmt}
\begin{while}{busy}
\call{step}{}
\end{while} ; \\
World`timer.\call{WaitRelative}{TimeStamp`stepLength}
\end{blockstmt}
\end{thread}
\kEnd $AreaController$

