\begin{vdm_al}
class Analyzer is subclass of GLOBAL
-- when sending analysis. put timestamp on

types

--public AnalysisData  = seq of (nat * nat * nat);
public Emergency = EventId * EmergencyType * nat; 
public Tendency = nat;

Buffer = seq of Data;
AnalysisBuffer = seq of DeviceData; 

values

instance variables

dataBuffer : Buffer := [];
analysisBuffer : seq of DeviceData := [];

batMonitor : [BatteryMonitor] := nil;
busy : bool := false;
transmitter : [Transmitter];
hasBattery : bool := false;

cprNr : CprNr := 0;
curValue : nat := 0;
oldValue : nat := 0;

-- do we use these?
eventid : [EventId];
dataType : [DataType];

operations

public Analyzer: DataType ==> Analyzer
Analyzer(type) ==
(
    dataType := type; 
);


public setTransmitter : Transmitter ==> ()
setTransmitter(tnsmt) ==
(
    transmitter := tnsmt;
    start(transmitter);
);

public setBatteryMonitor : BatteryMonitor ==> ()
setBatteryMonitor ( monitor ) ==
(
    batMonitor := monitor; 
    hasBattery := true;   
);

public addData : Data ==> ()
addData(data) ==
(
    Printer`Out("Analyzer received data");
    dataBuffer := dataBuffer ^ [data];
    
    --dataBuffer := dataBuffer ^ [mk_Data(1,100000,3,[mk_(1,2),mk_(2,3)])];
    if len dataBuffer >0 then Printer`Out("Buffer not empty");
    busy := true;

);

public isFinished: () ==> ()
isFinished () == 
(
    Printer`Out("Analyzer is done");
);

done: () ==> ()
    done() == skip;   
    
public sendAnalysis: () ==> ()
sendAnalysis() ==
    skip;
    -- send to TX, which determines transmit and calls handleEvent;

public getDataType: () ==> nat
getDataType () ==
    return dataType;

public getData: () ==> Data 
getData() == 
(dcl result: Data := hd dataBuffer;
    dataBuffer := tl dataBuffer;
    return result;
    
   -- seperate buffer for processed stuff
    --def mk_Data(evid, cpr, datatype, devicedata) = hd dataBuffer in
    --    return mk_Data(evid, cpr, datatype, devicedata);   
);    
    
    
public setCprNr: CprNr ==> ()
setCprNr(cpr) ==
(
    cprNr := cpr;
);

public doAnalysis: () ==> ()
doAnalysis() ==
cycles(5000)
(
    --Printer`Out("Analyzer: something");
  (if dataBuffer <> [] then
    def data = getData() in 
    (def analysisData = data.devicedata in
        (analysisBuffer := analysisBuffer ^ analysisData;
        
            -- drainbattery           
            if hasBattery then
                batMonitor.drain(50);
                        
            (dcl analyzing: bool := true;
                while(analyzing) do
                (   
                    dcl val: DeviceData := hd analysisBuffer;                   
                    (oldValue := curValue;
                     curValue := val.#1;
                        
                        if((curValue - oldValue) > 5) then
                        (
                            Printer`Out("Analyzer: Transmitting");
                            transmitter.transmit(mk_EmergencyData(1, data.cprnr, HEART_RATE_SPIKE, data.devicedata));
                        );
                    );
                    
                    analysisBuffer := tl analysisBuffer;
                    analyzing := len analysisBuffer > 0;
                );       
            );
            
            -- erase buffer
            dataBuffer := [];      
                
            --transmitter.transmit(mk_EmergencyData(1, data.cprnr, HEART_RATE_SPIKE, data.devicedata));
            busy := len dataBuffer > 0;
            if(not busy) then
                Printer`Out("analyzer not busy anymore");
        ) 
     )
  ) 
);

thread
   -- the Analyzer continuously processes data from the pmu
   -- getData is automatically blocked if there
   -- are no data available
    periodic(500, 100, 0, 0) (doAnalysis)
    
sync
  -- addThreat and getThreat modify the same instance variables
  -- therefore they need to be declared mutual exclusive
   
    mutex(addData,getData);  
    per getData => len dataBuffer > 0;
    per isFinished => not busy;
        
end Analyzer

\end{vdm_al}
