\section{TPC class}

\begin{vdm_al}


class TPC

instance variables

--private normalState : bool := true;
--private curtime : nat := 0;
private railway : RailwayGrid;
--private q_APM_out : ActivePlanManager;
--private timeout : nat := 0;

types

public NavigationInput :: 
departureLocation : String
arrivalLocation : String
transportChoice : Choice
id_token : nat1
departureTime : nat

inv n == len n.departureLocation > 0 and
	len n.arrivalLocation > 0 ;
	
public String = seq of char;
public Choice = <Cheapest>|<Quickest>


operations

public TPC : () ==> TPC
TPC() ==
(
	railway := new RailwayGrid();
);

public calculateTransportPlan : NavigationInput ==> seq of TransportPlan`Section 
calculateTransportPlan(navInput) ==
(
	duration(1000)(
 	dcl tempSections : GridReservation`SectionPlan := railway.getSectionPlan();
 	dcl tempGrid : RailwayGrid`Grid := railway.getGrid();

 	def l = {r | r in set tempGrid & r(1).departureLocation = navInput.departureLocation 
         and r(len r).arrivalLocation = navInput.arrivalLocation} in (
 if card l > 0 then 
 (
 	(dcl fastst : nat := 0;
 	dcl tempSeclist : seq of TransportPlan`Section := [];
 	dcl tmpList : seq of TransportPlan`Section;
 	dcl tmpSec : TransportPlan`Section;
 	dcl tmpTime : nat := 0;
 	dcl test : bool := false;
 	
 	for all seclist in set l do
 	(
 		test := true;
 		tmpTime := navInput.departureTime;
 		tmpList := seclist;
 		while len tmpList > 0 and test do 
 		(
 			tmpSec := hd tmpList;
 			tmpList := tl tmpList;
 			if not (exists t in set tempSections(tmpSec) & t > tmpTime) then(
 				test := false;
 			);
 			if test then(
 				tmpTime := findSmallest(tempSections(tmpSec), tmpTime) + tmpSec.dur;
 			);
 		);
 		
 		if( tmpTime < fastst or fastst = 0 and test = true) then (
 			fastst := tmpTime;
 			tempSeclist := seclist;
 		);
 	);
 	return tempSeclist;
 );
 );
);
return [];
);
)
pre exists r in set railway.getGrid() & r(1).departureLocation = navInput.departureLocation and r(len r).arrivalLocation = navInput.arrivalLocation;


public setActiveSection : nat ==> ()
setActiveSection(id_Section) == is not yet specified;


private findCheapest : RailwayGrid`Grid ==> [seq of TransportPlan`Section]
findCheapest(list) ==
(
	dcl sum : real := 0;
	dcl cheap : real := 9999;
	dcl rtn : seq of TransportPlan`Section := [];
	
	for all s in set list do
	(
		sum := 0;
		for r in s do
			sum := sum + r.fee;
		if sum < cheap then
		(
			cheap := sum;
			rtn := s;
		);    
	);
	return rtn;
);

private findQuickest : RailwayGrid`Grid ==> [seq of TransportPlan`Section]
findQuickest (list) == findCheapest(list);

public calcTransportPlan : MessageTypes`REQUESTPLAN ==> MessageTypes`RETURNPLAN
calcTransportPlan(msg)==(
	let mk_MessageTypes`REQUESTPLAN(navi, tok) = msg in
	(	
		return mk_MessageTypes`RETURNPLAN(mk_TransportPlan`DTO(navi.id_token,calculateTransportPlan(navi), navi.transportChoice, navi.departureTime),tok);
	)
);

public inactiveSection : nat ==> ()
inactiveSection(routeid) ==
(	
		railway.setInactiveSection(routeid);
);

public inactiveSections : set of nat ==> ()
inactiveSections(sections)==
(
	for all id in set sections do
	(
		railway.setInactiveSection(id);
	)
)

functions 
public findSmallest : set of nat * nat -> nat
findSmallest(list, v) == (
	let l  = {x | x in set list & x >= v} in(
	hd [x | x in set l & forall y in set l & x <= y]
	)
);

end TPC
\end{vdm_al}


