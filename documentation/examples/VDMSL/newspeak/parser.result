RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private beta'nat1 = 2static private epsilon_r'real = 1static private epsilon_t'real = 1static private bytemax'int = 10000static private maxint'int = 100000static private Phi'(unresolved DEFAULT`Fl_elt) = mk_Fl_elt(<phi>, 1)static private zerot'(unresolved DEFAULT`Time) = mk_(0, 0)static private t_absreal'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_absint'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_realmonminus'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_intmonminus'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_not'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_discard'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_round'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_mantissa'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_exponent'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_odd'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_float'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_min'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_max'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_intbinop'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_realbinop'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_intcomp'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_realcomp'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_tr_eq'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_real_eq'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_int_eq'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_void_eq'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_and'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_skip'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_access'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_comp_extract'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_update'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_construct_ev'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_const_type'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_widen_type'(unresolved DEFAULT`Time) = mk_(1, 1)static private t_if'(unresolved DEFAULT`Time) = mk_(1, 1)static private Errvalue = <err>static private Id = tokenstatic private Flavdom = set of ((unresolved DEFAULT`Fl_elt))static private Fl_elt = compose Fl_elt of label'(<phi> | token), dim'rat endstatic private Tr = compose Tr of val'bool, type'(unresolved DEFAULT`TrType) endstatic private TrType = compose TrType of range'set of (bool), fl'(unresolved DEFAULT`Flavdom) endstatic private EqOp = (<EQ> | <NEQ>)static private Int = compose Int of val'int, type'(unresolved DEFAULT`IntType) endstatic private IntType = compose IntType of rep'(<byte> | <word>), range'set of (int), fl'(unresolved DEFAULT`Flavdom) endstatic private NumOp = compose NumOp of 1'(<binaryminus> | <numdiv> | <nummax> | <nummin> | <nummod> | <nummult> | <numplus>) endstatic private CompOp = (<numge> | <numgt> | <numle> | <numlt>)static private Real = compose Real of val'real, type'(unresolved DEFAULT`Float) endstatic private Floatrng = compose Floatrng of lower'int, upper'int endstatic private Float = compose Float of range'set of ((unresolved DEFAULT`Floatrng)), abserr'real, relerr'real, fl'(unresolved DEFAULT`Flavdom) endstatic private Void = compose Void of val'<nil>, type'(unresolved DEFAULT`VoidType) endstatic private VoidType = compose VoidType of 1'(unresolved DEFAULT`Flavdom) endstatic private Structure = compose Structure of val'(unresolved DEFAULT`StructValue), type'(unresolved DEFAULT`StructureType) endstatic private StructValue = seq1 of ((unresolved DEFAULT`Component))static private Component = (bool | real)static private StructureType = compose StructureType of tps'seq1 of ((unresolved DEFAULT`CompType)), fl'(unresolved DEFAULT`Flavdom) endstatic private CompType = ((unresolved DEFAULT`Float) | (unresolved DEFAULT`IntType) | (unresolved DEFAULT`TrType))static private Vector = compose Vector of val'(unresolved DEFAULT`VectorValue), type'(unresolved DEFAULT`VectorType) endstatic private VectorValue = (seq1 of ((unresolved DEFAULT`Errvalue)) | seq1 of ((unresolved DEFAULT`Int)) | seq1 of ((unresolved DEFAULT`Real)) | seq1 of ((unresolved DEFAULT`StructValue)) | seq1 of ((unresolved DEFAULT`Tr)) | seq1 of ((unresolved DEFAULT`VectorValue)) | seq1 of ((unresolved DEFAULT`Void)))static private VectorType = compose VectorType of lower'int, upper'int, type'(unresolved DEFAULT`Expressible_type), fl'(unresolved DEFAULT`Flavdom) endstatic private Union = compose Union of val'(unresolved DEFAULT`UnionValue), type'(unresolved DEFAULT`UnionType) endstatic private UnionValue = ((unresolved DEFAULT`Int) | (unresolved DEFAULT`Real) | (unresolved DEFAULT`Tr) | (unresolved DEFAULT`Void))static private UnionType = compose UnionType of tps'set of ((((unresolved DEFAULT`Float) | (unresolved DEFAULT`IntType) | (unresolved DEFAULT`TrType) | (unresolved DEFAULT`VoidType)))), fl'(unresolved DEFAULT`Flavdom) endstatic private Expressible_type = ((unresolved DEFAULT`Float) | (unresolved DEFAULT`IntType) | (unresolved DEFAULT`StructureType) | (unresolved DEFAULT`TrType) | (unresolved DEFAULT`UnionType) | (unresolved DEFAULT`VectorType) | (unresolved DEFAULT`VoidType))static private Location = compose Location of 1'nat endstatic private Expressible_value = ((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Int) | (unresolved DEFAULT`Real) | (unresolved DEFAULT`Structure) | (unresolved DEFAULT`Tr) | (unresolved DEFAULT`Union) | (unresolved DEFAULT`Vector) | (unresolved DEFAULT`Void))static private Storable_value = compose Storable_value of 1'((unresolved DEFAULT`Int) | (unresolved DEFAULT`Real) | (unresolved DEFAULT`Structure) | (unresolved DEFAULT`Tr) | (unresolved DEFAULT`Union) | (unresolved DEFAULT`Vector) | (unresolved DEFAULT`Void)) endstatic private Store = map ((unresolved DEFAULT`Location)) to ((unresolved DEFAULT`Storable_value))static private Time = (nat * nat)static private PState = compose PState of sto'(unresolved DEFAULT`Store), time'(unresolved DEFAULT`Time) endstatic private Denotable_value = ((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type) | (unresolved DEFAULT`Location) | (unresolved DEFAULT`Proc) | (unresolved DEFAULT`Storable_value))static private Env = ((map ((unresolved DEFAULT`Id)) to ((unresolved DEFAULT`Denotable_value))) * (unresolved DEFAULT`Location))static private EnvState = ((((unresolved DEFAULT`Env) * (unresolved DEFAULT`PState))) | (unresolved DEFAULT`Errvalue))static private EST_value = compose EST_value of val'(unresolved DEFAULT`Expressible_value), sto'(unresolved DEFAULT`Store), time'(unresolved DEFAULT`Time) endstatic private EST_Iterate = compose EST_Iterate of expst'(unresolved DEFAULT`EST_value), i'int endstatic private Param = seq of ((unresolved DEFAULT`Expressible_value))static private Proc = compose Proc of 1'((unresolved DEFAULT`Param) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))) endstatic private Formal_elt = compose Formal_elt of id'(unresolved DEFAULT`Id), rep'(unresolved DEFAULT`Expressible_type), fl'(unresolved DEFAULT`Flavdom) endstatic private Program = compose Program of 1'(unresolved DEFAULT`Expression) endstatic private Expression = compose Expression of 1'((unresolved DEFAULT`Assertion) | (unresolved DEFAULT`Assignment) | (unresolved DEFAULT`GuardedScope) | (unresolved DEFAULT`InnerLoop) | (unresolved DEFAULT`Operation) | (unresolved DEFAULT`Scope) | (unresolved DEFAULT`TimedExpression)) endstatic private Operation = compose Operation of 1'((unresolved DEFAULT`BinaryOperation) | (unresolved DEFAULT`MonOperation)) endstatic private MonOperation = compose MonOperation of 1'((unresolved DEFAULT`MonOpMonOperand) | (unresolved DEFAULT`Value) | (unresolved DEFAULT`VectorOperation)) endstatic private MonOpMonOperand = compose MonOpMonOperand of operator'(unresolved DEFAULT`MonOp), operand'(unresolved DEFAULT`MonOperation) endstatic private MonOp = ((unresolved DEFAULT`CompileTimeOp) | <discard> | <exponent> | <float> | <mantissa> | <not> | <numabs> | <odd> | <round> | <unaryminus>)static private CompileTimeOp = compose CompileTimeOp of 1'(<abserr> | <absonly> | <inf> | <relerr> | <relonly> | <sup>) endstatic private VectorOperation = compose VectorOperation of vo'(unresolved DEFAULT`VectorOp), mo'(unresolved DEFAULT`MonOperation), mult'[(unresolved DEFAULT`Multiple)] endstatic private VectorOp = (<all> | <flatten> | <product> | <some> | <sum> | <vecmax> | <vecmin>)static private Multiple = compose Multiple of op'(unresolved DEFAULT`Operation), to_p'(unresolved DEFAULT`ToPart) endstatic private ToPart = ((unresolved DEFAULT`Downto) | (unresolved DEFAULT`Upto))static private Upto = (unresolved DEFAULT`Operation)static private Downto = (unresolved DEFAULT`Operation)static private BinaryOperation = compose BinaryOperation of left'(unresolved DEFAULT`MonOperation), opr'(unresolved DEFAULT`BinaryOp), right'(unresolved DEFAULT`MonOperation) endstatic private BinaryOp = compose BinaryOp of 1'((unresolved DEFAULT`BoolOp) | (unresolved DEFAULT`CompOp) | (unresolved DEFAULT`EqOp) | (unresolved DEFAULT`NumOp) | (unresolved DEFAULT`VecBinOp) | <replaceflav>) endstatic private BoolOp = (<and> | <or>)static private VecBinOp = <concat>static private Value = compose Value of 1'((unresolved DEFAULT`Call) | (unresolved DEFAULT`Conditional) | (unresolved DEFAULT`ConstantValue) | (unresolved DEFAULT`NamedValue) | (unresolved DEFAULT`OuterLoop) | (unresolved DEFAULT`Sequence) | (unresolved DEFAULT`StructureValue) | (unresolved DEFAULT`VectorVal) | (unresolved DEFAULT`Widening)) endstatic private ConstantValue = compose ConstantValue of 1'((unresolved DEFAULT`Ascii_Char) | (unresolved DEFAULT`Ascii_string) | (unresolved DEFAULT`BooleanDenotation) | (unresolved DEFAULT`Flavouring) | (unresolved DEFAULT`FloatingDenotation) | (unresolved DEFAULT`IntegerDenotation) | <skip>) endstatic private IntegerDenotation = compose IntegerDenotation of 1'int endstatic private FloatingDenotation = compose FloatingDenotation of 1'real endstatic private BooleanDenotation = compose BooleanDenotation of 1'bool endstatic private Ascii_Char = compose Ascii_Char of 1'char endstatic private Ascii_string = compose Ascii_string of 1'seq1 of (char) endstatic private NamedValue = compose NamedValue of 1'((unresolved DEFAULT`FlavourExtract) | (unresolved DEFAULT`FlavourStrip) | (unresolved DEFAULT`Id) | (unresolved DEFAULT`VectorExtract) | (unresolved DEFAULT`VectorTrimming)) endstatic private FlavourExtract = compose FlavourExtract of nv'(unresolved DEFAULT`NamedValue), fl'(unresolved DEFAULT`Flavouring) endstatic private Flavouring = compose Flavouring of 1'seq of ((unresolved DEFAULT`Flavour)) endstatic private Flavour = compose Flavour of name'token, index'[rat] endstatic private FlavourStrip = compose FlavourStrip of nv'(unresolved DEFAULT`NamedValue), fl'(unresolved DEFAULT`Flavouring) endstatic private VectorExtract = compose VectorExtract of named'(unresolved DEFAULT`NamedValue), index'(unresolved DEFAULT`Operation) endstatic private VectorTrimming = compose VectorTrimming of named'(unresolved DEFAULT`NamedValue), to_p'(<atvalue> | <gtvalue> | <ltvalue>), ctv'(unresolved DEFAULT`CompileTimeValue) endstatic private CompileTimeValue = compose CompileTimeValue of 1'(unresolved DEFAULT`Operation) endstatic private VectorVal = compose VectorVal of 1'seq1 of ((unresolved DEFAULT`Operation)) endstatic private Sequence = compose Sequence of 1'seq1 of ((unresolved DEFAULT`Expression)) endstatic private Call = compose Call of id'(unresolved DEFAULT`Id), acts'seq of ((unresolved DEFAULT`Operation)) endstatic private StructureValue = compose StructureValue of 1'seq1 of ((unresolved DEFAULT`Operation)) endstatic private Widening = compose Widening of expr'(unresolved DEFAULT`Expression), tp'(unresolved DEFAULT`Type) endstatic private Type = compose Type of 1'((unresolved DEFAULT`FlavouredType) | (unresolved DEFAULT`PrimitiveType) | (unresolved DEFAULT`StrucType) | (unresolved DEFAULT`TypeName) | (unresolved DEFAULT`UnionTp) | (unresolved DEFAULT`VecType)) endstatic private PrimitiveType = compose PrimitiveType of 1'((unresolved DEFAULT`FloatType) | (unresolved DEFAULT`Number) | (unresolved DEFAULT`VoidValType)) endstatic private Number = compose Number of rep'(<bit> | <byte> | <word>), range'seq of ((unresolved DEFAULT`Range)) endstatic private Range = compose Range of lower'[(unresolved DEFAULT`CompileTimeValue)], upper'[(unresolved DEFAULT`CompileTimeValue)] endstatic private FloatType = compose FloatType of range'seq of ((unresolved DEFAULT`Range)), abserr'[(unresolved DEFAULT`CompileTimeValue)], relerr'[(unresolved DEFAULT`CompileTimeValue)] endstatic private VoidValType = (unresolved DEFAULT`Flavouring)static private VecType = compose VecType of range'(unresolved DEFAULT`Range), tp'(unresolved DEFAULT`Type) endstatic private StrucType = compose StrucType of 1'seq1 of ((unresolved DEFAULT`Type)) endstatic private FlavouredType = compose FlavouredType of fl'(unresolved DEFAULT`Flavouring), tp'(unresolved DEFAULT`Type) endstatic private UnionTp = compose UnionTp of 1'seq1 of ((unresolved DEFAULT`Type)) endstatic private TypeName = compose TypeName of 1'(unresolved DEFAULT`Id) endstatic private Conditional = compose Conditional of 1'((unresolved DEFAULT`CaseExpr) | (unresolved DEFAULT`IfThenElse) | (unresolved DEFAULT`IfThenOnly)) endstatic private IfThenOnly = compose IfThenOnly of prop'(unresolved DEFAULT`Expression), action'(unresolved DEFAULT`Sequence) endstatic private IfThenElse = compose IfThenElse of prop'(unresolved DEFAULT`Expression), thenaction'(unresolved DEFAULT`Sequence), elseaction'(unresolved DEFAULT`Sequence) endstatic private CaseExpr = compose CaseExpr of expr'(unresolved DEFAULT`Expression), limbs'seq1 of ((unresolved DEFAULT`CaseLimb)), out'[(unresolved DEFAULT`Outlimb)] endstatic private CaseLimb = compose CaseLimb of test'(unresolved DEFAULT`Tester), sequ'(unresolved DEFAULT`Sequence) endstatic private Tester = ((unresolved DEFAULT`NonStrucTest) | (unresolved DEFAULT`SkeletonType) | (unresolved DEFAULT`StrucTest))static private SkeletonType = compose SkeletonType of 1'((unresolved DEFAULT`FlavSkel) | (unresolved DEFAULT`NumSkel) | (unresolved DEFAULT`StrucSkel) | (unresolved DEFAULT`Type) | (unresolved DEFAULT`UnionSkel) | (unresolved DEFAULT`VecSkel)) endstatic private NumSkel = compose NumSkel of ranges'[seq1 of ((unresolved DEFAULT`Range))], errors'[(unresolved DEFAULT`Errors)] endstatic private Errors = compose Errors of abserr'[(unresolved DEFAULT`CompileTimeValue)], relerr'[(unresolved DEFAULT`CompileTimeValue)] endstatic private StrucSkel = compose StrucSkel of 1'seq1 of ((((unresolved DEFAULT`SkeletonType) | <nil>))) endstatic private FlavSkel = compose FlavSkel of skel'(unresolved DEFAULT`SkeletonType), fl'(unresolved DEFAULT`Flavouring) endstatic private VecSkel = compose VecSkel of 1'(unresolved DEFAULT`SkeletonType) endstatic private UnionSkel = compose UnionSkel of 1'seq1 of ((((unresolved DEFAULT`FlavSkel) | (unresolved DEFAULT`FlavouredType) | (unresolved DEFAULT`VoidValType)))) endstatic private StrucTest = compose StrucTest of 1'seq1 of ((((unresolved DEFAULT`NonStrucTest) | <nil>))) endstatic private NonStrucTest = compose NonStrucTest of id'[(unresolved DEFAULT`Id)], fl'[(unresolved DEFAULT`Flavouring)], tp'(unresolved DEFAULT`SkeletonType) endstatic private Outlimb = (unresolved DEFAULT`Sequence)static private OuterLoop = compose OuterLoop of 1'((unresolved DEFAULT`OuterIntLoop) | (unresolved DEFAULT`OuterVecLoop)) endstatic private OuterIntLoop = compose OuterIntLoop of ovr'(unresolved DEFAULT`OverRange), actions'(unresolved DEFAULT`Sequence) endstatic private OverRange = compose OverRange of cnt'(unresolved DEFAULT`LoopId), range'(unresolved DEFAULT`Range) endstatic private LoopId = (unresolved DEFAULT`Id)static private OuterVecLoop = compose OuterVecLoop of ovs'(unresolved DEFAULT`OverVectors), action'(unresolved DEFAULT`Sequence) endstatic private OverVectors = compose OverVectors of cnt'[(unresolved DEFAULT`LoopId)], ovv'seq1 of ((unresolved DEFAULT`OverVector)) endstatic private OverVector = compose OverVector of id'(unresolved DEFAULT`Id), val'(unresolved DEFAULT`Operation) endstatic private InnerLoop = compose InnerLoop of 1'((unresolved DEFAULT`IntLoop) | (unresolved DEFAULT`TimeLoop) | (unresolved DEFAULT`VecLoop)) endstatic private IntLoop = compose IntLoop of inc'(unresolved DEFAULT`InnerControl), actions'(unresolved DEFAULT`Sequence) endstatic private InnerControl = ((unresolved DEFAULT`OverRange) | (unresolved DEFAULT`PartialRange))static private PartialRange = compose PartialRange of cnt'(unresolved DEFAULT`LoopId), from_p'(unresolved DEFAULT`Operation), to_p'(unresolved DEFAULT`ToPart), inc'[(unresolved DEFAULT`Operation)] endstatic private VecLoop = compose VecLoop of ovs'(unresolved DEFAULT`OverVectors), actions'(unresolved DEFAULT`Sequence) endstatic private TimeLoop = compose TimeLoop of time'(unresolved DEFAULT`TimeInterval), actions'(unresolved DEFAULT`Sequence) endstatic private TimeInterval = (unresolved DEFAULT`Range)static private Assignment = compose Assignment of 1'((unresolved DEFAULT`MultAssignment) | (unresolved DEFAULT`NvAssignment) | (unresolved DEFAULT`StrAssignment)) endstatic private NvAssignment = compose NvAssignment of dest'(unresolved DEFAULT`Id), expr'(unresolved DEFAULT`Expression) endstatic private MultAssignment = compose MultAssignment of dest'(unresolved DEFAULT`Id), mult'(unresolved DEFAULT`Multiple), expr'(unresolved DEFAULT`Expression) endstatic private StrAssignment = compose StrAssignment of dest'seq1 of ((unresolved DEFAULT`Id)), expr'(unresolved DEFAULT`Expression) endstatic private Scope = compose Scope of 1'((unresolved DEFAULT`PackageScope) | (unresolved DEFAULT`SimpleScope)) endstatic private SimpleScope = compose SimpleScope of decls'seq1 of ((unresolved DEFAULT`Declaration)), expr'(unresolved DEFAULT`Expression) endstatic private Declaration = ((unresolved DEFAULT`ExportDecl) | (unresolved DEFAULT`ImportDecl) | (unresolved DEFAULT`LetDecl) | (unresolved DEFAULT`ProcDec) | (unresolved DEFAULT`TypeDec) | (unresolved DEFAULT`VarDecl))static private ImportDecl = compose ImportDecl of id'(unresolved DEFAULT`Id), tp'(unresolved DEFAULT`Type) endstatic private ExportDecl = compose ExportDecl of id'(unresolved DEFAULT`Id), expr'(unresolved DEFAULT`Expression) endstatic private LetDecl = compose LetDecl of 1'((unresolved DEFAULT`SimpleLetDecl) | (unresolved DEFAULT`StrucLetDecl)) endstatic private SimpleLetDecl = compose SimpleLetDecl of id'(unresolved DEFAULT`Id), expr'(unresolved DEFAULT`Expression) endstatic private StrucLetDecl = compose StrucLetDecl of ids'seq1 of ((unresolved DEFAULT`Id)), expr'(unresolved DEFAULT`Expression) endstatic private VarDecl = compose VarDecl of id'(unresolved DEFAULT`Id), expr'(unresolved DEFAULT`Expression) endstatic private ProcDec = compose ProcDec of nls'[(unresolved DEFAULT`NonLocals)], ph'(unresolved DEFAULT`ProcHeading), expr'(unresolved DEFAULT`Expression) endstatic private NonLocals = compose NonLocals of ids'[seq1 of ((unresolved DEFAULT`Id))], decls'[seq1 of ((unresolved DEFAULT`Declaration))] endstatic private ProcHeading = compose ProcHeading of id'(unresolved DEFAULT`Id), formals'seq of ((unresolved DEFAULT`Formal)) endstatic private Formal = compose Formal of id'(unresolved DEFAULT`Id), rep'(unresolved DEFAULT`Representation), fl'(unresolved DEFAULT`Flavouring) endstatic private Representation = ((unresolved DEFAULT`FlavouredRep) | (unresolved DEFAULT`PrimitiveRep) | (unresolved DEFAULT`StrucRep) | (unresolved DEFAULT`Type) | (unresolved DEFAULT`UnionRep) | (unresolved DEFAULT`VecRep))static private PrimitiveRep = compose PrimitiveRep of 1'((unresolved DEFAULT`FloatRep) | (unresolved DEFAULT`NumRep)) endstatic private NumRep = compose NumRep of rep'(<bit> | <byte> | <word>), rnage'[seq1 of ((unresolved DEFAULT`Range))] endstatic private FloatRep = compose FloatRep of range'[seq1 of ((unresolved DEFAULT`Range))], abserr'[(unresolved DEFAULT`CompileTimeValue)], relerr'[(unresolved DEFAULT`CompileTimeValue)] endstatic private StrucRep = compose StrucRep of 1'seq1 of ((unresolved DEFAULT`Representation)) endstatic private VecRep = compose VecRep of range'(unresolved DEFAULT`Range), rep'(unresolved DEFAULT`Representation) endstatic private UnionRep = compose UnionRep of 1'seq1 of ((unresolved DEFAULT`Representation)) endstatic private FlavouredRep = compose FlavouredRep of fl'(unresolved DEFAULT`Flavouring), rep'(unresolved DEFAULT`Representation) endstatic private TypeDec = compose TypeDec of id'(unresolved DEFAULT`Id), tp'(unresolved DEFAULT`Type) endstatic private PackageScope = compose PackageScope of ids'seq1 of ((unresolved DEFAULT`Id)), decls'seq1 of ((unresolved DEFAULT`Declaration)), expr'(unresolved DEFAULT`Expression) endstatic private GuardedScope = compose GuardedScope of decls'seq1 of ((unresolved DEFAULT`GuardedDeclaration)), inseq'(unresolved DEFAULT`Sequence), out'(unresolved DEFAULT`Sequence) endstatic private GuardedDeclaration = ((unresolved DEFAULT`Declaration) | (unresolved DEFAULT`WhereDecl))static private WhereDecl = compose WhereDecl of type'(unresolved DEFAULT`SkeletonType), expr'(unresolved DEFAULT`Expression), id'[(unresolved DEFAULT`Id)] endstatic private Assertion = compose Assertion of expr'(unresolved DEFAULT`Expression), tp'(unresolved DEFAULT`SkeletonType) endstatic private TimedExpression = compose TimedExpression of 1'((unresolved DEFAULT`TimeAssertion) | (unresolved DEFAULT`TimeTakes)) endstatic private TimeTakes = compose TimeTakes of expr'(unresolved DEFAULT`Expression), time'(unresolved DEFAULT`TimeInterval) endstatic private TimeAssertion = compose TimeAssertion of expr'(unresolved DEFAULT`Expression), time'(unresolved DEFAULT`TimeInterval) endfl_mult' ((unresolved DEFAULT`Flavdom) * (unresolved DEFAULT`Flavdom) -> (unresolved DEFAULT`Flavdom))	fl_mult(f1, f2) ==(if (Phi in set (f1 union f2))then {Phi}else (({mk_Fl_elt((f.label), ((f.dim) + (f'.dim))) | [f in set f1, f' in set f2] & ((f.label) = (f'.label))} union {f | [f in set f1] & (forall f' in set f2 & ((f'.label) <> (f.label)))}) union {f | [f in set f2] & (forall f' in set f1 & ((f'.label) <> (f.label)))}))fl_div' ((unresolved DEFAULT`Flavdom) * (unresolved DEFAULT`Flavdom) -> (unresolved DEFAULT`Flavdom))	fl_div(f1, f2) ==(if (Phi in set (f1 union f2))then {Phi}else (({mk_Fl_elt((f.label), ((f.dim) - (f'.dim))) | [f in set f1, f' in set f2] & ((f.label) = (f'.label))} union {f | [f in set f1] & (forall f' in set f2 & ((f'.label) <> (f.label)))}) union {mk_Fl_elt((f.label), -(f.dim)) | [f in set f2] & (forall f' in set f1 & ((f'.label) <> (f.label)))}))phi_remove' ((unresolved DEFAULT`Expressible_type) -> (unresolved DEFAULT`Expressible_type))	phi_remove(tp) ==(cases tp 'case mk_(unresolved DEFAULT`VoidType)(t) -> mk_VoidType((t \ {Phi})),case mk_(unresolved DEFAULT`TrType)(range, fl) -> mk_TrType(range, (fl \ {Phi})),case mk_(unresolved DEFAULT`IntType)(rep, range, fl) -> mk_IntType(rep, range, (fl \ {Phi})),case mk_(unresolved DEFAULT`Float)(range, abse, rele, fl) -> mk_Float(range, abse, rele, (fl \ {Phi})),case mk_(unresolved DEFAULT`VectorType)(lower, upper, tp, fl) -> mk_VectorType(lower, upper, tp, (fl \ {Phi})),case mk_(unresolved DEFAULT`StructureType)(tps, fl) -> mk_StructureType(tps, (fl \ {Phi})),case mk_(unresolved DEFAULT`UnionType)(tps, fl) -> mk_UnionType(tps, (fl \ {Phi}))end)tr_eq' ((unresolved DEFAULT`Tr) * (unresolved DEFAULT`Tr) * (unresolved DEFAULT`EqOp) -> (unresolved DEFAULT`Expressible_value))	tr_eq(t1, t2, op) ==(if (((t1.type).fl) <> ((t2.type).fl))then <err>elseif (op = <EQ>)then mk_Tr(((t1.val) = (t2.val)), mk_TrType({(b1 = b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, {}))else mk_Tr(((t1.val) <> (t2.val)), mk_TrType({(b1 <> b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, {})))tr_and' ((unresolved DEFAULT`Tr) * (unresolved DEFAULT`Tr) -> (unresolved DEFAULT`Expressible_value))	tr_and(t1, t2) ==(if (((t1.type).fl) <> ((t2.type).fl))then <err>else mk_Tr(((t1.val) and (t2.val)), mk_TrType({(b1 and b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, ((t1.type).fl))))tr_or' ((unresolved DEFAULT`Tr) * (unresolved DEFAULT`Tr) -> (unresolved DEFAULT`Expressible_value))	tr_or(t1, t2) ==(if (((t1.type).fl) <> ((t2.type).fl))then <err>else mk_Tr(((t1.val) or (t2.val)), mk_TrType({(b1 or b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, ((t1.type).fl))))tr_not' ((unresolved DEFAULT`Tr) -> (unresolved DEFAULT`Expressible_value))	tr_not(t) ==mk_Tr((not (t.val)), mk_TrType({(not b) | [b in set ((t.type).range)]}, ((t.type).fl)))int_eq' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) * (unresolved DEFAULT`EqOp) -> (unresolved DEFAULT`Expressible_value))	int_eq(z1, z2, op) ==(if (((z1.type).fl) <> ((z2.type).fl))then <err>elseif (op = <EQ>)then mk_Tr(((z1.val) = (z2.val)), mk_TrType({(i = j) | [i in set ((z1.type).range), j in set ((z2.type).range)]}, {}))else mk_Tr(((z1.val) <> (z2.val)), mk_TrType({(i <> j) | [i in set ((z1.type).range), j in set ((z2.type).range)]}, {})))min' (set of (real) -> real)	min(s) ==let m in set s in (if ((card s) = 1)then melse let sm = min((s \ {m})) in (if (m < sm)then melse sm))	pre (s <> {})max' (set of (real) -> real)	max(s) ==let m in set s in (if ((card s) = 1)then melse let sm = max((s \ {m})) in (if (m > sm)then melse sm))	pre (s <> {})intbinop' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) * (unresolved DEFAULT`NumOp) -> (unresolved DEFAULT`Expressible_value))	intbinop(x, y, mk_(unresolved DEFAULT`NumOp)(op)) ==(cases op 'case (<numplus>) -> intplus(x, y),case (<binaryminus>) -> intbinminus(x, y),case (<nummult>) -> intmult(x, y),case (<numdiv>) -> intdiv(x, y),case (<nummod>) -> intmod(x, y),case (<nummax>) -> intmax(x, y),case (<nummin>) -> intmin(x, y)end)intplus' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intplus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range = {(i + j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep = (if ((min({(abs min(range)), (abs max(range))}) >= bytemax) or ((((x.type).rep) = <word>) or (((y.type).rep) = <word>)))then <word>else <byte>) in mk_Int(((x.val) + (y.val)), mk_IntType(rep, range, ((x.type).fl)))))intbinminus' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intbinminus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range = {(i - j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep = (if ((min({(abs min(range)), (abs max(range))}) >= bytemax) or ((((x.type).rep) = <word>) or (((y.type).rep) = <word>)))then <word>else <byte>) in mk_Int(((x.val) - (y.val)), mk_IntType(rep, range, ((x.type).fl)))))intmult' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intmult(x, y) ==let fl = fl_mult(((x.type).fl), ((y.type).fl)), range = {(i * j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep = (if ((min({(abs min(range)), (abs max(range))}) >= bytemax) or ((((x.type).rep) = <word>) or (((y.type).rep) = <word>)))then <word>else <byte>) in mk_Int(((x.val) * (y.val)), mk_IntType(rep, range, fl)))intdiv' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intdiv(x, y) ==(if (0 in set ((y.type).range))then <err>else let fl = fl_div(((x.type).fl), ((y.type).fl)), range = {(i div j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep = (if (exists [r in set range] & ((abs r) >= bytemax))then <word>else <byte>) in mk_Int(((x.val) div (y.val)), mk_IntType(rep, range, fl))))intmod' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intmod(x, y) ==(if (0 in set ((y.type).range))then <err>else let range = {(i mod j) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Int(((x.val) mod (y.val)), mk_IntType(((y.type).rep), range, ((x.type).fl))))intmax' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intmax(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let rep = (if ((((x.type).rep) = <word>) or (((y.type).rep) = <word>))then <word>else <byte>), range = {max({i, j}) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Int(max({(x.val), (y.val)}), mk_IntType(rep, range, ((x.type).fl))))intmin' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) -> (unresolved DEFAULT`Expressible_value))	intmin(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let rep = (if ((((x.type).rep) = <word>) or (((y.type).rep) = <word>))then <word>else <byte>), range = {min({i, j}) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Int(min({(x.val), (y.val)}), mk_IntType(rep, range, ((x.type).fl))))absint' ((unresolved DEFAULT`Int) -> (unresolved DEFAULT`Int))	absint(z) ==mk_Int((abs (z.val)), mk_IntType(((z.type).rep), {(abs i) | [i in set ((z.type).range)]}, ((z.type).fl)))intmonminus' ((unresolved DEFAULT`Int) -> (unresolved DEFAULT`Int))	intmonminus(z) ==mk_Int(-(z.val), mk_IntType(((z.type).rep), {-i | [i in set ((z.type).range)]}, ((z.type).fl)))odd' ((unresolved DEFAULT`Int) -> (unresolved DEFAULT`Tr))	odd(z) ==let range = {((x mod 2) = 0) | [x in set ((z.type).range)]} in mk_Tr((((z.val) mod 2) = 0), mk_TrType(range, {}))intcomp' ((unresolved DEFAULT`Int) * (unresolved DEFAULT`Int) * (unresolved DEFAULT`CompOp) -> (unresolved DEFAULT`Expressible_value))	intcomp(x, y, op) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let p = (lambda [mk_(i, j)'(int * int)] & (cases op 'case <numgt> -> (i > j),case <numlt> -> (i < j),case <numge> -> (i >= j),case <numle> -> (i <= j)end)) in let val = p(mk_((x.val), (y.val))), range = {p(mk_(i, j)) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Tr(val, mk_TrType(range, {})))ascii' (char -> int)	ascii(c) ==1float' ((unresolved DEFAULT`Int) -> (unresolved DEFAULT`Real))	float(z) ==mk_Real((z.val), mk_Float({mk_Floatrng(min(((z.type).range)), max(((z.type).range)))}, maxint, maxint, {}))real_eq' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) * (unresolved DEFAULT`EqOp) -> (unresolved DEFAULT`Expressible_value))	real_eq(r, s, op) ==(if (((r.type).fl) <> ((s.type).fl))then <err>else let r1 = (dunion {{(floor (((1 - ((r.type).relerr)) * (range.lower)) - ((r.type).abserr))), ... ,(floor ((0.5 + ((1 + ((r.type).relerr)) * (range.upper))) + ((r.type).abserr)))} | [range in set ((r.type).range)]}), r2 = (dunion {{(floor (((1 - ((s.type).relerr)) * (range.lower)) - ((s.type).abserr))), ... ,(floor ((0.5 + ((1 + ((s.type).relerr)) * (range.upper))) + ((s.type).abserr)))} | [range in set ((s.type).range)]}) in let range = (if ((r1 inter r2) = {})then {false}else {true, false}) in (if (op = <EQ>)then mk_Tr(((r.val) = (s.val)), mk_TrType(range, {}))else mk_Tr(((r.val) <> (s.val)), mk_TrType({(not t) | [t in set range]}, {}))))absreal' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	absreal(r) ==let new_range = {mk_Floatrng(min({(abs (range.lower)), (abs (range.upper))}), max({(abs (range.lower)), (abs (range.upper))})) | [range in set ((r.type).range)]} in mk_Real((abs (r.val)), mu((r.type), range |-> new_range))realmonminus' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	realmonminus(r) ==mk_Real(-(r.val), mu((r.type), range |-> {mk_Floatrng(-(range.upper), -(range.lower)) | [range in set ((r.type).range)]}))realbinop' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) * (unresolved DEFAULT`NumOp) -> (unresolved DEFAULT`Expressible_value))	realbinop(x, y, mk_(unresolved DEFAULT`NumOp)(op)) ==(cases op 'case <numplus> -> realplus(x, y),case <binaryminus> -> realbinminus(x, y),case <nummult> -> realmult(x, y),case <numdiv> -> realdiv(x, y),case <nummax> -> realmax(x, y)others <err>end)realplus' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) -> (unresolved DEFAULT`Expressible_value))	realplus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range = {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax = max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As = ((((((x.type).relerr) + ((y.type).abserr)) + (((x.type).relerr) * Xmax)) + (((y.type).relerr) * Ymax)) + (epsilon_t * XYmax)) in let val = ((x.val) + (y.val)), type = mk_Float(range, As, epsilon_r, ((x.type).fl)) in mk_Real(val, type)))realbinminus' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) -> (unresolved DEFAULT`Expressible_value))	realbinminus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range = {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax = max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As = ((((((x.type).relerr) + ((y.type).abserr)) + (((x.type).relerr) * Xmax)) + (((y.type).relerr) * Ymax)) + (epsilon_t * XYmax)) in let val = ((x.val) - (y.val)), type = mk_Float(range, As, epsilon_r, ((x.type).fl)) in mk_Real(val, type)))realmult' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) -> (unresolved DEFAULT`Expressible_value))	realmult(x, y) ==let range = {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax = max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As = ((((((Xmax * Ymax) * (((x.type).relerr) + ((y.type).relerr))) + ((((x.type).abserr) * Ymax) * (1 + ((y.type).relerr)))) + ((((y.type).abserr) * Xmax) * (1 + ((x.type).relerr)))) + (((x.type).abserr) * ((y.type).abserr))) + (epsilon_t * XYmax)), fl = fl_mult(((x.type).fl), ((y.type).fl)) in mk_Real(((x.val) * (y.val)), mk_Float(range, As, epsilon_r, fl)))realdiv' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) -> (unresolved DEFAULT`Expressible_value))	realdiv(x, y) ==(if (((((1 - ((y.type).relerr)) * min({(range.lower) | [range in set ((y.type).range)]})) - ((y.type).abserr)) <= 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | [range in set ((y.type).range)]})) + ((y.type).abserr)) >= 0))then <err>else let range = {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax = max({Xmax, Ymax}), Ymin = min((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As = ((((((Xmax * Ymax) * max({((x.type).relerr), ((y.type).relerr)})) + (Ymax * ((x.type).abserr))) + (Xmax * ((y.type).abserr))) / (Ymin ** 2)) + (epsilon_t * XYmax)), fl = fl_div(((x.type).fl), ((y.type).fl)) in mk_Real(((x.val) / (y.val)), mk_Float(range, As, epsilon_r, fl))))realmax' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) -> (unresolved DEFAULT`Expressible_value))	realmax(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let val = max({(x.val), (y.val)}), abserr = max({((x.type).abserr), ((y.type).abserr)}), relerr = max({((x.type).relerr), ((y.type).relerr)}), range = {mk_Floatrng(max({(xr.lower), (yr.lower)}), max({(xr.upper), (yr.upper)})) | [xr in set ((x.type).range), yr in set ((y.type).range)]} in mk_Real(val, mk_Float(range, abserr, relerr, ((x.type).fl))))realmin' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) -> (unresolved DEFAULT`Expressible_value))	realmin(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let val = min({(x.val), (y.val)}), abserr = max({((x.type).abserr), ((y.type).abserr)}), relerr = max({((x.type).relerr), ((y.type).relerr)}), range = {mk_Floatrng(min({(xr.lower), (yr.lower)}), min({(xr.upper), (yr.upper)})) | [xr in set ((x.type).range), yr in set ((y.type).range)]} in mk_Real(val, mk_Float(range, abserr, relerr, ((x.type).fl))))discard' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Int))	discard(r) ==mk_Int((floor ((r.val) + 0.5)), mk_IntType(<word>, (dunion {{(range.lower), ... ,(range.upper)} | [range in set ((r.type).range)]}), {}))round' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Int))	round(r) ==(if is_((r.val), int)then mk_Int((r.val), mk_IntType(<word>, (dunion {{(range.lower), ... ,(range.upper)} | [range in set ((r.type).range)]}), {}))else mk_Int((floor ((r.val) + 0.5)), mk_IntType(<word>, (dunion {{(range.lower), ... ,(range.upper)} | [range in set ((r.type).range)]}), {})))realcomp' ((unresolved DEFAULT`Real) * (unresolved DEFAULT`Real) * (unresolved DEFAULT`CompOp) -> (unresolved DEFAULT`Expressible_value))	realcomp(x, y, op) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let p = (lambda [mk_(i, j)'(real * real)] & (cases op 'case <numgt> -> (i > j),case <numlt> -> (i < j),case <numle> -> (i <= j),case <numge> -> (i >= j)end)), xrange = (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | [range in set ((x.type).range)]}), yrange = (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | [range in set ((y.type).range)]}) in let val = p(mk_((x.val), (y.val))), range = (if (max(xrange) < min(yrange))then {p(mk_(max(xrange), min(yrange)))}elseif (min(xrange) > max(yrange))then {p(mk_(max(yrange), min(xrange)))}else {true, false}) in mk_Tr(val, mk_TrType(range, {})))inf' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	inf(r) ==let m = ((min({(range.lower) | [range in set ((r.type).range)]}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in mk_Real(m, mk_Float({mk_Floatrng(m, m)}, 0, 0, {Phi}))sup' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	sup(r) ==let m = ((max({(range.upper) | [range in set ((r.type).range)]}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in mk_Real(m, mk_Float({mk_Floatrng(m, m)}, 0, 0, {Phi}))absonly' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	absonly(mk_(unresolved DEFAULT`Real)(r, f)) ==let abse = ((f.abserr) + (r * (f.relerr))) in mk_Real(r, mu(f, abserr |-> abse, relerr |-> 0))relonly' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	relonly(mk_(unresolved DEFAULT`Real)(r, f)) ==(if (r = 0)then mk_Real(r, mu(f, relerr |-> 0, abserr |-> 0))else let rel = ((f.relerr) + ((f.abserr) / r)) in mk_Real(r, mu(f, relerr |-> rel, abserr |-> 0)))abserr' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	abserr(r) ==mk_Real(((r.type).abserr), mk_Float({mk_Floatrng(((r.type).abserr), ((r.type).abserr))}, 0, 0, {Phi}))relerr' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	relerr(r) ==mk_Real(((r.type).relerr), mk_Float({mk_Floatrng(((r.type).relerr), ((r.type).relerr))}, 0, 0, {Phi}))void_eq' ((unresolved DEFAULT`Void) * (unresolved DEFAULT`Void) * (unresolved DEFAULT`EqOp) -> (unresolved DEFAULT`Expressible_value))	void_eq(v1, v2, op) ==(if (((v1.type) = (v2.type)) and (op = <EQ>))then mk_Tr(true, mk_TrType({true}, {}))elseif (((v1.type) <> (v2.type)) and (op = <NEQ>))then mk_Tr(true, mk_TrType({true}, {}))else mk_Tr(false, mk_TrType({false}, {})))construct_ev' ((unresolved DEFAULT`Component) * (unresolved DEFAULT`CompType) -> (unresolved DEFAULT`Expressible_value))	construct_ev(v, t) ==(if is_(v, real)then mk_Real(v, t)elseif is_(v, bool)then mk_Tr(v, t)else mk_Int(v, t))comp_extract' ((unresolved DEFAULT`Structure) * (unresolved DEFAULT`Flavdom) -> (unresolved DEFAULT`Expressible_value))	comp_extract(s, fl) ==let matches = {i | [i in set (inds (s.val))] & ((((s.type).tps)(i).fl) = fl)} in (if ((card matches) <> 1)then <err>else let {i} = matches in construct_ev((s.val)(i), ((s.type).tps)(i)))struc_length' ((unresolved DEFAULT`StructureType) -> nat)	struc_length(s) ==(len (s.tps))vector_extract' ((unresolved DEFAULT`Vector) * int -> (unresolved DEFAULT`Expressible_value))	vector_extract(v, i) ==(v.val)(((i - ((v.type).lower)) + 1))vector_subv' ((unresolved DEFAULT`VectorValue) * int * int -> (unresolved DEFAULT`VectorValue))	vector_subv(v, l, u) ==(v(l, ... ,u))vector_length' ((unresolved DEFAULT`VectorType) -> nat)	vector_length(v) ==((((v.type).upper) - ((v.type).lower)) + 1)vector_flatten' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`VectorValue))	vector_flatten(vs) ==(conc vs)vector_sum' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`Expressible_value))	vector_sum(v) ==(if ((len v) = 1)then (hd v)else let s = vector_sum((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realplus((hd v), s)else intplus((hd v), s)))vector_product' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`Expressible_value))	vector_product(v) ==(if ((len v) = 1)then (hd v)else let s = vector_product((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realmult((hd v), s)else intmult((hd v), s)))vector_all' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`Expressible_value))	vector_all(v) ==(if ((len v) = 1)then (hd v)else let b = vector_all((tl v)) in (if (b = <err>)then <err>else tr_and((hd v), b)))vector_some' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`Expressible_value))	vector_some(v) ==(if ((len v) = 1)then (hd v)else let b = vector_some((tl v)) in (if (b = <err>)then <err>else tr_or((hd v), b)))vector_max' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`Expressible_value))	vector_max(v) ==(if ((len v) = 1)then (hd v)else let s = vector_max((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realmax((hd v), s)else intmax((hd v), s)))vector_min' ((unresolved DEFAULT`VectorValue) -> (unresolved DEFAULT`Expressible_value))	vector_min(v) ==(if ((len v) = 1)then (hd v)else let s = vector_min((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realmin((hd v), s)else intmin((hd v), s)))vector_concat' ((unresolved DEFAULT`Vector) * (unresolved DEFAULT`Vector) -> (unresolved DEFAULT`Vector))	vector_concat(v1, v2) ==let type = (if tleq(((v1.type).type), ((v2.type).type))then ((v2.type).type)else ((v1.type).type)), lower = ((v1.type).lower), upper = (((((v1.type).upper) + ((v2.type).upper)) - ((v2.type).lower)) + 1), fl = ((v1.type).fl), vec = ((v1.val) ^ (v2.val)) in let new_type = mk_VectorType(lower, upper, type, fl) in mk_Vector(vec, new_type)widen_type' ((unresolved DEFAULT`Expressible_value) * (unresolved DEFAULT`Expressible_type) -> (unresolved DEFAULT`Expressible_value))	widen_type(x, type) ==(if ((x = <err>) or is_(x, Void))then <err>else mu(x, type |-> type))const_type' ((unresolved DEFAULT`Expressible_value) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))	const_type(v) ==(if is_(v, Void)then (v.type)elseif is_(v, Vector)then mk_VectorType(((v.type).lower), ((v.type).upper), seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), ((v.type).fl))elseif is_(v, Structure)then mk_StructureType([const_type(construct_ev((v.val)(i), ((v.type).tps)(i))) | i in set (inds (v.val))], ((v.type).fl))elseif is_(v, Union)then const_type((v.val))elseif (v = <err>)then <err>elseif is_(v, Real)then mk_Float({mk_Floatrng((floor (v.val)), (if is_((v.val), int)then (v.val)else (floor ((v.val) + 0.5))))}, ((v.type).abserr), ((v.type).relerr), ((v.type).fl))elseif is_(v, Int)then mk_IntType(((v.type).rep), {(v.val)}, ((v.type).fl))else mk_TrType({(v.val)}, ((v.type).fl)))fleq' ((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Expressible_type) -> bool)	fleq(t1, t2) ==(if (is_(t1, VoidType) and is_(t2, VoidType))then (t1 = t2)elseif (not (is_(t1, VoidType) and is_(t2, VoidType)))then ((t1.fl) = (t2.fl))else false)replace_flavour' ((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Flavdom) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))	replace_flavour(type, flav) ==(cases type 'case mk_(unresolved DEFAULT`VoidType)(fl) -> mk_VoidType(flav),case mk_(unresolved DEFAULT`TrType)(r, f) -> mk_TrType(r, flav),case mk_(unresolved DEFAULT`Float)(r, a, re, f) -> mk_Float(r, a, re, flav),case mk_(unresolved DEFAULT`IntType)(rep, r, f) -> mk_IntType(rep, r, flav),case mk_(unresolved DEFAULT`VectorType)(l, u, t, f) -> mk_VectorType(l, u, t, flav),case mk_(unresolved DEFAULT`UnionType)(tps, fl) -> mk_UnionType(tps, flav),case mk_(unresolved DEFAULT`StructureType)(tps, fl) -> mk_StructureType(tps, flav)end)lub' ((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Expressible_type) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))	lub(t1, t2) ==(if (is_(t1, TrType) and (is_(t2, TrType) and fleq(t1, t2)))then trlub(t1, t2)elseif (is_(t1, Float) and (is_(t2, Float) and fleq(t1, t2)))then floatlub(t1, t2)elseif (is_(t1, IntType) and (is_(t2, IntType) and fleq(t1, t2)))then intlub(t1, t2)elseif (is_(t1, VectorType) and (is_(t2, VectorType) and fleq(t1, t2)))then vectorlub(t1, t2)elseif (is_(t1, StructureType) and (is_(t2, StructureType) and fleq(t1, t2)))then struclub(t1, t2)elseif (is_(t1, UnionType) and (is_(t2, UnionType) and fleq(t1, t2)))then unionlub(t1, t2)elseif (is_(t1, VoidType) and (is_(t2, VoidType) and fleq(t1, t2)))then t1else <err>)trlub' ((unresolved DEFAULT`TrType) * (unresolved DEFAULT`TrType) -> (unresolved DEFAULT`TrType))	trlub(t1, t2) ==mk_TrType(((t1.range) union (t2.range)), (t1.fl))floatlub' ((unresolved DEFAULT`Float) * (unresolved DEFAULT`Float) -> (unresolved DEFAULT`Float))	floatlub(t1, t2) ==mk_Float(((t1.range) union (t2.range)), max({(t1.abserr), (t2.abserr)}), max({(t1.relerr), (t2.relerr)}), (t1.fl))intlub' ((unresolved DEFAULT`IntType) * (unresolved DEFAULT`IntType) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`IntType))))	intlub(t1, t2) ==(if (((t1.rep) = <byte>) and ((t2.rep) = <byte>))then mk_IntType(<byte>, ((t1.range) union (t2.range)), (t1.fl))elseif (((t1.rep) = <word>) and ((t2.rep) = <word>))then mk_IntType(<word>, ((t1.range) union (t2.range)), (t1.fl))else <err>)vectorlub' ((unresolved DEFAULT`VectorType) * (unresolved DEFAULT`VectorType) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`VectorType))))	vectorlub(t1, t2) ==(if (((t1.lower) <> (t2.lower)) or (((t1.upper) <> (t2.upper)) or (lub((t1.type), (t2.type)) = <err>)))then <err>else mk_VectorType((t1.lower), (t1.upper), lub((t1.type), (t2.type)), (t1.fl)))struclub' ((unresolved DEFAULT`StructureType) * (unresolved DEFAULT`StructureType) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`StructureType))))	struclub(t1, t2) ==(if ((len (t1.tps)) <> (len (t2.tps)))then <err>elseif (exists [i in set (inds (t1.tps))] & (lub((t1.tps)(i), (t2.tps)(i)) = <err>))then <err>else mk_StructureType([lub((t1.tps)(i), (t2.tps)(i)) | i in set (inds (t1.tps))], (t1.fl)))unionlub' ((unresolved DEFAULT`UnionType) * (unresolved DEFAULT`UnionType) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`UnionType))))	unionlub(t1, t2) ==(if ((card (t1.tps)) <> (card (t2.tps)))then <err>else let lub = setlub(((t1.tps) union (t2.tps))) in (if (lub = <err>)then <err>elseif is_(lub, UnionType)then mk_UnionType((lub.tps), (t1.fl))else mk_UnionType({lub}, (t1.fl))))seqlub' (seq1 of ((unresolved DEFAULT`Expressible_type)) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))	seqlub(tps) ==(if ((len tps) = 1)then (hd tps)elseif (lub(tps(1), tps(2)) = <err>)then <err>else lub(lub(tps(1), tps(2)), seqlub((tl tps))))setlub' (set of ((unresolved DEFAULT`Expressible_type)) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))	setlub(s) ==(if (exists [t1, t2 in set s] & (lub(t1, t2) = <err>))then (if (forall t in set s & (is_(t, TrType) or (is_(t, IntType) or (is_(t, Float) or is_(t, VoidType)))))then let t1 = {setlub({t' | [t' in set s] & (is_(t', TrType) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, TrType)}, t2 = {setlub({t' | [t' in set s] & (is_(t', IntType) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, IntType)}, t3 = {setlub({t' | [t' in set s] & (is_(t', Float) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, Float)}, t4 = {setlub({t' | [t' in set s] & (is_(t', VoidType) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, VoidType)} in (if ((exists [t, t' in set (dunion {t1, t2, t3, t4})] & ((t.fl) = (t'.fl))) or (exists [t in set (dunion {t1, t2, t3}), mk_(unresolved DEFAULT`VoidType)(f) in set t4] & ((t.fl) = f)))then <err>else mk_UnionType((((t1 union t2) union t3) union t4), {}))else <err>)else let t in set s in (if (s = {t})then telse lub(t, setlub((s \ {t})))))gt' ((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Expressible_type) -> bool)	gt(t1, t2) ==((lub(t1, t2) = t1) or ((fleq(t1, t2) and ((is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) => (((1 in set z) and (false in set (t2.range))) => (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t1.range)]}))) or (is_(t1, IntType) and (z subset (t1.range))))) or (((is_(t2, IntType) and (((t2.rep) = <byte>) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t1.range)]}))))) or (is_(t1, IntType) and (((t1.rep) = <word>) and ((t2.range) subset (t1.range))))) or ((is_(t2, IntType) and (((t2.rep) = <word>) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t1.range)]}))))) or ((is_(t2, Float) and (is_(t1, Float) and (((dunion {{lower, ... ,upper} | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t2.range)]}) subset (dunion {{lower, ... ,upper} | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t1.range)]})) and (((t2.abserr) + ((t2.relerr) * max({(abs max({lower, upper})) | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t2.range)]}))) <= ((t1.abserr) + ((t1.relerr) * max({(abs max({lower, upper})) | [mk_(unresolved DEFAULT`Floatrng)(lower, upper) in set (t1.range)]}))))))) or (is_(t1, UnionType) and (is_(t2, UnionType) and (forall t in set (t1.tps) & (exists [t' in set (t2.tps)] & (lub(t, t') = t)))))))))) or (is_(t2, UnionType) and (exists [t in set (t2.tps)] & gt(t1, t)))))tleq' ((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Expressible_type) -> bool)	tleq(t1, t2) ==(lub(t1, t2) = t2)next_locn' ((unresolved DEFAULT`Location) -> (unresolved DEFAULT`Location))	next_locn(mk_(unresolved DEFAULT`Location)(l)) ==mk_Location((l + 1))access' ((unresolved DEFAULT`Location) -> ((unresolved DEFAULT`Store) -> (unresolved DEFAULT`Storable_value)))	access(l)(s) ==s(l)update' ((unresolved DEFAULT`Location) -> ((unresolved DEFAULT`Storable_value) -> ((unresolved DEFAULT`Store) -> (unresolved DEFAULT`Store))))	update(l)(v)(s) ==(s ++ {l |-> v})multi_update' (seq of ((unresolved DEFAULT`Location)) -> (seq of ((unresolved DEFAULT`Storable_value)) -> ((unresolved DEFAULT`Store) -> (unresolved DEFAULT`Store))))	multi_update(ls)(vs)(s) ==(if (ls = [])then selse multi_update((tl ls))((tl vs))((s ++ {(hd ls) |-> (hd vs)})))	pre ((len ls) = (len vs))timeleq' ((unresolved DEFAULT`Time) * (unresolved DEFAULT`Time) -> bool)	timeleq(mk_(lt1, ut1), mk_(lt2, ut2)) ==((lt2 <= lt1) and ((lt1 <= ut1) and (ut1 <= ut2)))access_env' ((unresolved DEFAULT`Id) -> ((unresolved DEFAULT`Env) -> (unresolved DEFAULT`Denotable_value)))	access_env(i)(mk_(m, l)) ==m(i)update_env' ((unresolved DEFAULT`Id) -> ((unresolved DEFAULT`Denotable_value) -> ((unresolved DEFAULT`Env) -> (unresolved DEFAULT`Env))))	update_env(i)(d)(mk_(m, l)) ==mk_((m ++ {i |-> d}), l)empty_env' ((unresolved DEFAULT`Location) -> (unresolved DEFAULT`Env))	empty_env(l) ==mk_({}, l)multi_update_env' (seq of ((((unresolved DEFAULT`Id) * (unresolved DEFAULT`Denotable_value)))) -> ((unresolved DEFAULT`Env) -> (unresolved DEFAULT`Env)))	multi_update_env(s)(e) ==(if (s = [])then eelse let mk_(id, v) = (hd s) in multi_update_env((tl s))(update_env(id)(v)(e)))reserve_locn' ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Location) * (unresolved DEFAULT`Env))))	reserve_locn(mk_(m, l)) ==mk_(l, mk_(m, next_locn(l)))instantiate_formals' ((seq of ((unresolved DEFAULT`Formal_elt))) -> ((unresolved DEFAULT`Param) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Env) | (unresolved DEFAULT`Errvalue))))))	instantiate_formals(formals)(params)(e) ==(if ((len formals) <> (len params))then <err>else let lubs_eq = [(lub((formals(i).rep), (params(i).type)) = (formals(i).rep)) | i in set (inds formals)] in (if (false in set (elems lubs_eq))then <err>else let vals = [(if ((formals(i).fl) = {})then params(i)else widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in multi_update_env([mk_((formals(i).id), vals(i)) | i in set (inds vals)])(e)))mantissa' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	mantissa(r) ==rexponent' ((unresolved DEFAULT`Real) -> (unresolved DEFAULT`Real))	exponent(r) ==rtplus' ((unresolved DEFAULT`Time) * (unresolved DEFAULT`Time) -> (unresolved DEFAULT`Time))	tplus(mk_(l1, u1), mk_(l2, u2)) ==mk_((l1 + l2), (u1 + u2))dtplus' (seq of ((unresolved DEFAULT`Time)) -> (unresolved DEFAULT`Time))	dtplus(ts) ==(if (ts = [])then zerotelse tplus((hd ts), dtplus((tl ts))))t_trimming_op' (int -> (unresolved DEFAULT`Time))	t_trimming_op(l) ==mk_(1, 1)t_vector_extract' (int -> (unresolved DEFAULT`Time))	t_vector_extract(l) ==mk_(1, 1)t_vector_concat' (int * int -> (unresolved DEFAULT`Time))	t_vector_concat(l, m) ==mk_(1, 1)t_vectorsum' (int -> (unresolved DEFAULT`Time))	t_vectorsum(l) ==mk_(1, 1)t_vectorproduct' (int -> (unresolved DEFAULT`Time))	t_vectorproduct(l) ==mk_(1, 1)t_vector_all' (int -> (unresolved DEFAULT`Time))	t_vector_all(l) ==mk_(1, 1)t_vector_some' (int -> (unresolved DEFAULT`Time))	t_vector_some(l) ==mk_(1, 1)t_vector_max' (int -> (unresolved DEFAULT`Time))	t_vector_max(l) ==mk_(1, 1)t_vector_min' (int -> (unresolved DEFAULT`Time))	t_vector_min(l) ==mk_(1, 1)t_vector_flatten' (int -> (unresolved DEFAULT`Time))	t_vector_flatten(l) ==mk_(1, 1)t_vector_subv' (int -> (unresolved DEFAULT`Time))	t_vector_subv(l) ==mk_(1, 1)t_multi_update' (int -> (unresolved DEFAULT`Time))	t_multi_update(l) ==mk_(1, 1)choose' ((unresolved DEFAULT`Expressible_type) -> (unresolved DEFAULT`Expressible_value))	choose(tp) ==let val'(unresolved DEFAULT`Expressible_value) be st (lub(const_type(val), tp) = tp) in widen_type(const_type(val), tp)eval_Program' ((unresolved DEFAULT`Program) -> ((unresolved DEFAULT`Location) -> ((unresolved DEFAULT`Store) -> (unresolved DEFAULT`EST_value))))	eval_Program(mk_(unresolved DEFAULT`Program)(expr))(l)(sto) ==eval_Expression(expr)(empty_env(l))(mk_PState(sto, zerot))eval_Expression' ((unresolved DEFAULT`Expression) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Expression(mk_(unresolved DEFAULT`Expression)(expr))(env)(ps) ==(cases expr 'case mk_(unresolved DEFAULT`Operation)(op) -> eval_Operation(expr)(env)(ps),case mk_(unresolved DEFAULT`InnerLoop)(l) -> eval_InnerLoop(expr)(env)(ps),case mk_(unresolved DEFAULT`Assignment)(a) -> eval_Assignment(expr)(env)(ps),case mk_(unresolved DEFAULT`Scope)(s) -> eval_Scope(expr)(env)(ps),case mk_(unresolved DEFAULT`GuardedScope)(d, i, o) -> eval_GuardedScope(expr)(env)(ps),case mk_(unresolved DEFAULT`Assertion)(exp, tp) -> eval_Assertion(expr)(env)(ps),case mk_(unresolved DEFAULT`TimedExpression)(t) -> eval_TimedExpression(expr)(env)(ps)end)eval_Operation' ((unresolved DEFAULT`Operation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Operation(mk_(unresolved DEFAULT`Operation)(op))(e)(ps) ==(cases op 'case mk_(unresolved DEFAULT`MonOperation)(mo) -> eval_MonOperation(op)(e)(ps),case mk_(unresolved DEFAULT`BinaryOperation)(l, bo, r) -> eval_BinaryOperation(op)(e)(ps)end)eval_MonOperation' ((unresolved DEFAULT`MonOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_MonOperation(mk_(unresolved DEFAULT`MonOperation)(mo))(e)(ps) ==(cases mo 'case mk_(unresolved DEFAULT`MonOpMonOperand)(opr, opnd) -> eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)(ps),case mk_(unresolved DEFAULT`VectorOperation)(v, m, op) -> eval_VectorOperation(mk_VectorOperation(v, m, op))(e)(ps),case mk_(unresolved DEFAULT`Value)(v) -> eval_Value(mk_Value(v))(e)(ps)end)eval_MonOpMonOperand' ((unresolved DEFAULT`MonOpMonOperand) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_MonOpMonOperand(mk_(unresolved DEFAULT`MonOpMonOperand)(opr, opnd))(e)(ps) ==let x = eval_MonOperation(opnd)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else (cases opr 'case <numabs> -> eval_Abs(x),case <unaryminus> -> eval_MonMinus(x),case <not> -> eval_Not(x),case mk_(unresolved DEFAULT`CompileTimeOp)(o) -> eval_CompileTimeOp(opr)(x),case <discard> -> eval_Discard(x),case <round> -> eval_Round(x),case <odd> -> eval_Odd(x),case <float> -> eval_Float(x),case <mantissa> -> eval_Mantissa(x),case <exponent> -> eval_Exponent(x)end))eval_Abs' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Abs(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if is_(val, Real)then mk_EST_value(absreal(val), sto, tplus(time, t_absreal))elseif is_(val, Int)then mk_EST_value(absint(val), sto, tplus(time, t_absint))else mk_EST_value(<err>, sto, zerot))eval_MonMinus' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_MonMinus(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if is_(val, Real)then mk_EST_value(realmonminus(val), sto, tplus(time, t_realmonminus))elseif is_(val, Int)then mk_EST_value(intmonminus(val), sto, tplus(time, t_intmonminus))else mk_EST_value(<err>, sto, zerot))eval_Not' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Not(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Tr))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(tr_not(val), sto, tplus(time, t_not)))eval_CompileTimeOp' ((unresolved DEFAULT`CompileTimeOp) -> ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value)))	eval_CompileTimeOp(mk_(unresolved DEFAULT`CompileTimeOp)(op))(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else (cases op 'case <inf> -> mk_EST_value(inf(val), sto, time),case <sup> -> mk_EST_value(sup(val), sto, time),case <absonly> -> mk_EST_value(absonly(val), sto, time),case <relonly> -> mk_EST_value(relonly(val), sto, time),case <abserr> -> mk_EST_value(abserr(val), sto, time),case <relerr> -> mk_EST_value(relerr(val), sto, time)end))eval_Discard' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Discard(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(discard(val), sto, tplus(time, t_discard)))eval_Round' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Round(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(round(val), sto, tplus(time, t_round)))eval_Mantissa' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Mantissa(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(mantissa(val), sto, tplus(time, t_mantissa)))eval_Exponent' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Exponent(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(exponent(val), sto, tplus(time, t_exponent)))eval_Odd' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Odd(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(odd(val), sto, tplus(time, t_odd)))eval_Float' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_Float(mk_(unresolved DEFAULT`EST_value)(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(float(val), sto, tplus(time, t_float)))eval_VectorOperation' ((unresolved DEFAULT`VectorOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_VectorOperation(mk_(unresolved DEFAULT`VectorOperation)(vo, mo, mult))(e)(ps) ==let x = eval_MonOperation(mo)(e)(ps) in (if (not is_((x.val), Vector))then mk_EST_value(<err>, (ps.sto), zerot)else let v = (if (mult = nil)then xelse eval_VectorMult(mu(x, sto |-> (ps.sto)))(mult)(e)) in (if ((v.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else (cases vo 'case <sum> -> eval_VectorSum(v),case <product> -> eval_VectorProduct(v),case <vecmax> -> eval_VectorMax(v),case <vecmin> -> eval_VectorMin(v),case <all> -> eval_VectorAll(v),case <some> -> eval_VectorSome(v),case <flatten> -> eval_VectorFlatten(v)end)))eval_VectorMult' ((unresolved DEFAULT`EST_value) -> ((unresolved DEFAULT`Multiple) -> ((unresolved DEFAULT`Env) -> (unresolved DEFAULT`EST_value))))	eval_VectorMult(mk_(unresolved DEFAULT`EST_value)(est_val, sto, time))(mk_(unresolved DEFAULT`Multiple)(op, to_p))(e) ==let mk_(unresolved DEFAULT`Vector)(val, type) = est_val in let b1 = eval_Operation(op)(e)(mk_PState(sto, time)) in let b2 = eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))then mk_EST_value(<err>, sto, zerot)elseif (((card (((b1.val).type).range)) <> 1) or ((card (((b2.val).type).range)) <> 1))then mk_EST_value(<err>, sto, zerot)else let lower = min({((b1.val).val), ((b2.val).val)}), upper = max({((b1.val).val), ((b2.val).val)}) in (if ((lower < (type.lower)) or ((type.upper) < upper))then mk_EST_value(<err>, sto, zerot)else let new_val = vector_subv(val, lower, upper), new_type = mk_VectorType(lower, upper, (type.type), (type.fl)) in let new_v = mk_Vector(new_val, new_type), new_t = tplus(tplus((b2.time), t_vector_subv((upper - lower))), tplus(t_min, t_max)) in mk_EST_value(new_v, sto, new_t)))eval_VectorSum' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorSum(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_sum(val), sto, tplus(time, t_vectorsum(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorProduct' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorProduct(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_product(val), sto, tplus(time, t_vectorproduct(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorMax' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorMax(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_max(val), sto, tplus(time, t_vector_max(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorMin' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorMin(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_min(val), sto, tplus(time, t_vector_min(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorAll' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorAll(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (not is_((type.type), TrType))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(vector_all(val), sto, tplus(time, t_vector_all(((type.upper) - (type.lower))))))eval_VectorSome' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorSome(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (not is_((type.type), TrType))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(vector_some(val), sto, tplus(time, t_vector_some(((type.upper) - (type.lower))))))eval_VectorFlatten' ((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))	eval_VectorFlatten(mk_(unresolved DEFAULT`EST_value)(mk_(unresolved DEFAULT`Vector)(val, type), sto, time)) ==(if (not is_((type.type), VectorType))then mk_EST_value(<err>, sto, zerot)else let new_val = vector_flatten(val) in let new_upper = (((len new_val) + (type.lower)) - 1) in let new_time = tplus(time, t_vector_flatten(((type.upper) - (type.lower)))), new_type = mk_VectorType((type.lower), new_upper, (type.type), (type.fl)) in mk_EST_value(mk_Vector(new_val, new_type), sto, new_time))eval_BinaryOperation' ((unresolved DEFAULT`BinaryOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_BinaryOperation(bo)(e)(ps) ==let mk_(unresolved DEFAULT`BinaryOp)(op) = (bo.opr) in (cases op 'case mk_(unresolved DEFAULT`NumOp)(opr) -> eval_NumOp(bo)(e)(ps),case <numgt> -> eval_CompOp(bo)(e)(ps),case <numlt> -> eval_CompOp(bo)(e)(ps),case <numge> -> eval_CompOp(bo)(e)(ps),case <numle> -> eval_CompOp(bo)(e)(ps),case <and> -> eval_BoolOp(bo)(e)(ps),case <or> -> eval_BoolOp(bo)(e)(ps),case <EQ> -> eval_EqOp(bo)(e)(ps),case <NEQ> -> eval_EqOp(bo)(e)(ps),case <concat> -> eval_Concat(bo)(e)(ps)end)eval_NumOp' ((unresolved DEFAULT`BinaryOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_NumOp(mk_(unresolved DEFAULT`BinaryOperation)(left, mk_(unresolved DEFAULT`BinaryOp)(opr), right))(e)(ps) ==let a1 = eval_MonOperation(left)(e)(ps) in let a2 = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (cases opr 'case mk_(unresolved DEFAULT`NumOp)(op) -> (cases mk_((a1.val), (a2.val)) 'case mk_(mk_(unresolved DEFAULT`Int)(v1, t1), mk_(unresolved DEFAULT`Int)(v2, t2)) -> (if (op <> <numdiv>)then let val = intbinop(mk_Int(v1, t1), mk_Int(v2, t2), mk_NumOp(op)) in (if (val = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else mk_EST_value(val, (ps.sto), tplus((a2.time), t_intbinop)))else mk_EST_value(<err>, (ps.sto), zerot)),case mk_(mk_(unresolved DEFAULT`Real)(v1, t1), mk_(unresolved DEFAULT`Real)(v2, t2)) -> (if (op not in set {<numdiv>, <nummod>})then let val = realbinop(mk_Real(v1, t1), mk_Real(v2, t2), mk_NumOp(op)) in (if (val = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else mk_EST_value(val, (ps.sto), tplus((a2.time), t_realbinop)))else mk_EST_value(<err>, (ps.sto), zerot))others mk_EST_value(<err>, (ps.sto), zerot)end),case <replaceflav> -> (if (((a2.val) <> <err>) and is_((a2.val), Void))then let mk_(unresolved DEFAULT`VoidType)(f) = ((a2.val).type) in mk_EST_value(mu((a1.val), type |-> replace_flavour(((a1.val).type), f)), (ps.sto), (a2.time))else mk_EST_value(<err>, (ps.sto), zerot))others mk_EST_value(<err>, (ps.sto), zerot)end)eval_CompOp' ((unresolved DEFAULT`BinaryOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_CompOp(mk_(unresolved DEFAULT`BinaryOperation)(left, mk_(unresolved DEFAULT`BinaryOp)(opr), right))(e)(ps) ==let a1 = eval_MonOperation(left)(e)(ps) in let a2 = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (is_((a1.val), Int) and is_((a2.val), Int))then mk_EST_value(intcomp((a1.val), (a2.val), opr), (ps.sto), tplus((a2.time), t_intcomp))elseif (is_((a1.val), Real) and is_((a2.val), Real))then mk_EST_value(realcomp((a1.val), (a2.val), opr), (ps.sto), tplus((a2.time), t_realcomp))else mk_EST_value(<err>, (ps.sto), zerot))eval_EqOp' ((unresolved DEFAULT`BinaryOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_EqOp(mk_(unresolved DEFAULT`BinaryOperation)(left, mk_(unresolved DEFAULT`BinaryOp)(op), right))(e)(ps) ==let a1 = eval_MonOperation(left)(e)(ps) in let a2 = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (is_((a1.val), Tr) and is_((a2.val), Tr))then mk_EST_value(tr_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_tr_eq))elseif (is_((a1.val), Real) and is_((a2.val), Real))then mk_EST_value(real_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_real_eq))elseif (is_((a1.val), Int) and is_((a2.val), Int))then mk_EST_value(int_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_int_eq))elseif (is_((a1.val), Void) and is_((a2.val), Void))then mk_EST_value(void_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_void_eq))else mk_EST_value(<err>, (ps.sto), zerot))eval_BoolOp' ((unresolved DEFAULT`BinaryOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_BoolOp(mk_(unresolved DEFAULT`BinaryOperation)(left, mk_(unresolved DEFAULT`BinaryOp)(op), right))(e)(ps) ==let a1 = eval_MonOperation(left)(e)(ps) in let a2 = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (not (is_((a2.val), Tr) and is_((a2.val), Tr)))then mk_EST_value(<err>, (ps.sto), zerot)else (cases op 'case <and> -> mk_EST_value(tr_and((a1.val), (a2.val)), (ps.sto), tplus((a2.time), t_and)),case <or> -> mk_EST_value(tr_or((a1.val), (a2.val)), (ps.sto), tplus((a2.time), t_and))end))eval_Concat' ((unresolved DEFAULT`BinaryOperation) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Concat(mk_(unresolved DEFAULT`BinaryOperation)(left, op, right))(e)(ps) ==let a1 = eval_MonOperation(left)(e)(ps) in let a2 = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (not (is_((a1.val), Vector) and is_((a2.val), Vector)))then mk_EST_value(<err>, (ps.sto), zerot)elseif (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))then mk_EST_value(<err>, (ps.sto), zerot)else let new_vec = vector_concat((a1.val), (a2.val)), new_time = tplus((a2.time), t_vector_concat(vector_length(((a1.val).type)), vector_length(((a2.val).type)))) in mk_EST_value(new_vec, (ps.sto), new_time))eval_Value' ((unresolved DEFAULT`Value) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Value(mk_(unresolved DEFAULT`Value)(val))(e)(ps) ==(cases val 'case mk_(unresolved DEFAULT`ConstantValue)(c) -> eval_ConstantValue(mk_ConstantValue(c))(ps),case mk_(unresolved DEFAULT`NamedValue)(n) -> eval_NamedValue(mk_NamedValue(n))(e)(ps),case mk_(unresolved DEFAULT`VectorVal)(v) -> eval_VectorVal(mk_VectorVal(v))(e)(ps),case mk_(unresolved DEFAULT`StructureValue)(s) -> eval_StructureValue(mk_StructureValue(s))(e)(ps),case mk_(unresolved DEFAULT`Sequence)(s) -> eval_Sequence(mk_Sequence(s))(e)(ps),case mk_(unresolved DEFAULT`Call)(id, acts) -> eval_Call(mk_Call(id, acts))(e)(ps),case mk_(unresolved DEFAULT`Conditional)(c) -> eval_Conditional(val)(e)(ps),case mk_(unresolved DEFAULT`Widening)(exp, t) -> eval_Widening(val)(e)(ps),case mk_(unresolved DEFAULT`OuterLoop)(l) -> eval_OuterLoop(val)(e)(ps)end)eval_ConstantValue' ((unresolved DEFAULT`ConstantValue) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value)))	eval_ConstantValue(mk_(unresolved DEFAULT`ConstantValue)(cv))(ps) ==(cases cv 'case mk_(unresolved DEFAULT`IntegerDenotation)(z) -> let rep = (if ((abs z) >= bytemax)then <word>else <byte>) in mk_EST_value(mk_Int(z, mk_IntType(rep, {z}, {})), (ps.sto), (ps.time)),case mk_(unresolved DEFAULT`FloatingDenotation)(r) -> mk_EST_value(mk_Real(r, mk_Float({mk_Floatrng((floor r), (if is_(r, int)then relse (floor (r + 0.5))))}, 0, 0, {})), (ps.sto), (ps.time)),case mk_(unresolved DEFAULT`BooleanDenotation)(b) -> mk_EST_value(mk_Tr(b, mk_TrType({b}, {})), (ps.sto), (ps.time)),case mk_(unresolved DEFAULT`Ascii_Char)(c) -> mk_EST_value(mk_Int(ascii(c), mk_IntType(<byte>, {ascii(c)}, {})), (ps.sto), (ps.time)),case mk_(unresolved DEFAULT`Ascii_string)(s) -> mk_EST_value(mk_Vector([mk_Int(ascii(s(i)), mk_IntType(<byte>, {ascii(s(i))}, {})) | i in set (inds s)], mk_VectorType(1, (len s), seqlub([mk_IntType(<byte>, {ascii(s(i))}, {}) | i in set (inds s)]), {})), (ps.sto), (ps.time)),case mk_(unresolved DEFAULT`Flavouring)(fl) -> mk_EST_value(mk_Void(<nil>, mk_VoidType(eval_Flavouring(cv))), (ps.sto), (ps.time)),case <skip> -> mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), tplus((ps.time), t_skip))end)eval_NamedValue' ((unresolved DEFAULT`NamedValue) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_NamedValue(mk_(unresolved DEFAULT`NamedValue)(nv))(e)(ps) ==(cases nv 'case mk_(unresolved DEFAULT`FlavourExtract)(n, fl) -> eval_FlavourExtract(nv)(e)(ps),case mk_(unresolved DEFAULT`FlavourStrip)(n, fl) -> eval_FlavourStrip(nv)(e)(ps),case mk_(unresolved DEFAULT`VectorExtract)(n, i) -> eval_VectorExtract(nv)(e)(ps),case mk_(unresolved DEFAULT`VectorTrimming)(n, t, i) -> eval_VectorTrimming(nv)(e)(ps)others eval_Identifier(nv)(e)(ps)end)eval_Identifier' ((unresolved DEFAULT`Id) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Identifier(id)(mk_(m, l))(mk_(unresolved DEFAULT`PState)(sto, time)) ==(if (id in set (dom m))then (cases access_env(id)(mk_(m, l)) 'case mk_(unresolved DEFAULT`Location)(l) -> let mk_(unresolved DEFAULT`Storable_value)(v) = access(mk_Location(l))(sto) in mk_EST_value(v, sto, tplus(time, t_access)),case mk_(unresolved DEFAULT`Storable_value)(v) -> mk_EST_value(v, sto, time)end)else mk_EST_value(<err>, sto, time))eval_FlavourExtract' ((unresolved DEFAULT`FlavourExtract) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_FlavourExtract(mk_(unresolved DEFAULT`FlavourExtract)(nv, fl))(e)(ps) ==let n = eval_NamedValue(nv)(e)(ps), f = eval_Flavouring(fl) in (if (not is_((n.val), Structure))then mk_EST_value(<err>, (ps.sto), (ps.time))else mk_EST_value(comp_extract((n.val), f), (ps.sto), tplus((n.time), t_comp_extract)))eval_Flavouring' ((unresolved DEFAULT`Flavouring) -> (unresolved DEFAULT`Flavdom))	eval_Flavouring(mk_(unresolved DEFAULT`Flavouring)(fls)) ==(if (fls = [])then {}else ({eval_Flavour((hd fls))} union eval_Flavouring(mk_Flavouring((tl fls)))))eval_Flavour' ((unresolved DEFAULT`Flavour) -> (unresolved DEFAULT`Fl_elt))	eval_Flavour(mk_(unresolved DEFAULT`Flavour)(name, index)) ==mk_Fl_elt(name, index)eval_FlavourStrip' ((unresolved DEFAULT`FlavourStrip) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_FlavourStrip(mk_(unresolved DEFAULT`FlavourStrip)(nv, fl))(e)(ps) ==let n = eval_NamedValue(nv)(e)(ps), f = eval_Flavouring(fl) in (if (not is_((n.val), Structure))then mk_EST_value(<err>, (ps.sto), (ps.time))else let n' = comp_extract((n.val), f) in let n'' = mk_Structure((n'.val), mk_StructureType(((n'.type).tps), {})) in mk_EST_value(n'', (ps.sto), tplus((n.time), t_comp_extract)))eval_VectorExtract' ((unresolved DEFAULT`VectorExtract) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_VectorExtract(mk_(unresolved DEFAULT`VectorExtract)(n, i))(e)(ps) ==let x = eval_NamedValue(n)(e)(ps) in (if (not is_((x.val), Vector))then mk_EST_value(<err>, (ps.sto), (ps.time))else let index = eval_Operation(i)(e)(mu(ps, time |-> (x.time))), length = (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in (if (not is_((index.val), Int))then mk_EST_value(<err>, (ps.sto), (ps.time))elseif (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))then mk_EST_value(<err>, (ps.sto), (ps.time))else mk_EST_value(vector_extract((x.val), ((index.val).val)), (ps.sto), tplus((index.time), t_vector_extract(length)))))eval_VectorTrimming' ((unresolved DEFAULT`VectorTrimming) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_VectorTrimming(mk_(unresolved DEFAULT`VectorTrimming)(name, to_p, ctv))(e)(ps) ==let vec = eval_NamedValue(name)(e)(ps) in (if ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))then mk_EST_value(<err>, (ps.sto), zerot)else let v = eval_CompileTimeValue(ctv)(e) in (if (not (is_((v.val), Real) or is_((v.val), Int)))then mk_EST_value(<err>, (ps.sto), zerot)else let new_v = (cases to_p 'case <gtvalue> -> [((vec.val).val)(i) | i in set (inds ((vec.val).val)) & (((vec.val).val)(i) >= ((v.val).val))],case <ltvalue> -> [((vec.val).val)(i) | i in set (inds ((vec.val).val)) & (((vec.val).val)(i) <= ((v.val).val))],case <atvalue> -> [((vec.val).val)(i) | i in set (inds ((vec.val).val)) & (((vec.val).val)(i) = ((v.val).val))]end) in (if (new_v = [])then mk_EST_value(<err>, (ps.sto), zerot)else let new_l = (((vec.val).type).lower), new_u = (((((vec.val).type).lower) + (len new_v)) - 1), new_t = seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl = (((vec.val).type).fl) in let new_vec = mk_Vector(new_v, mk_VectorType(new_l, new_u, new_t, new_fl)), new_time = tplus((vec.time), t_trimming_op((new_u - new_l))) in mk_EST_value(new_vec, (ps.sto), new_time))))eval_CompileTimeValue' ((unresolved DEFAULT`CompileTimeValue) -> ((unresolved DEFAULT`Env) -> (unresolved DEFAULT`EST_value)))	eval_CompileTimeValue(mk_(unresolved DEFAULT`CompileTimeValue)(op))(mk_(m, l)) ==let locs = {id | [id in set (dom m)] & is_(m(id), Location)} in let new_m = (locs <-' m) in let new_env = mk_(new_m, l) in eval_Operation(op)(new_env)(mk_PState({}, zerot))eval_VectorVal' ((unresolved DEFAULT`VectorVal) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_VectorVal(mk_(unresolved DEFAULT`VectorVal)(ops))(e)(ps) ==let vals = [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val = [(vals(i).val) | i in set (inds vals)], time = dtplus([(vals(i).time) | i in set (inds vals)]) in (if (<err> in set (elems val))then mk_EST_value(<err>, (ps.sto), zerot)else let type = seqlub([(val(i).type) | i in set (inds val)]) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let tp = mk_VectorType(1, (len val), type, {}) in let x = mk_Vector(val, tp) in mk_EST_value(x, (ps.sto), time)))eval_StructureValue' ((unresolved DEFAULT`StructureValue) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_StructureValue(mk_(unresolved DEFAULT`StructureValue)(ops))(e)(ps) ==let vals = [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (if (exists [val in set (elems vals)] & (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))then mk_EST_value(<err>, (ps.sto), zerot)elseif (exists [v1, v2 in set (elems vals)] & fleq(((v1.val).type), ((v2.val).type)))then mk_EST_value(<err>, (ps.sto), zerot)else let tps = [((vals(i).val).type) | i in set (inds vals)], time = dtplus([(vals(i).time) | i in set (inds vals)]), comps = [((vals(i).val).val) | i in set (inds vals)] in let type = mk_StructureType(tps, {}) in let val = mk_Structure(comps, type) in mk_EST_value(val, (ps.sto), time))eval_Sequence' ((unresolved DEFAULT`Sequence) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Sequence(mk_(unresolved DEFAULT`Sequence)(exprs))(e)(ps) ==let x = eval_Expression((hd exprs))(e)(ps) in (if ((len exprs) = 1)then xelseif is_((x.val), Void)then eval_Sequence(mk_Sequence((tl exprs)))(e)(mk_PState((x.sto), (x.time)))else mk_EST_value(<err>, (ps.sto), zerot))eval_Call' ((unresolved DEFAULT`Call) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Call(mk_(unresolved DEFAULT`Call)(id, acts))(mk_(m, l))(mk_(unresolved DEFAULT`PState)(sto, time)) ==(if (id not in set (dom m))then mk_EST_value(<err>, sto, zerot)else let pp = access_env(id)(mk_(m, l)) in (if (not is_(pp, Proc))then mk_EST_value(<err>, sto, zerot)else let mk_(unresolved DEFAULT`Proc)(p) = pp in let params = eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in (if (<err> in set {(x.val) | [x in set (elems params)]})then mk_EST_value(<err>, sto, zerot)else p([(params(i).val) | i in set (inds params)])(mk_PState(sto, (params((len params)).time))))))eval_Acts' (seq of ((unresolved DEFAULT`Operation)) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> seq of ((unresolved DEFAULT`EST_value)))))	eval_Acts(ops)(e)(ps) ==(if (ops = [])then []else let x = eval_Operation((hd ops))(e)(ps) in ([x] ^ eval_Acts((tl ops))(e)(mk_PState((ps.sto), (x.time)))))eval_Widening' ((unresolved DEFAULT`Widening) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Widening(mk_(unresolved DEFAULT`Widening)(expr, dest_type))(e)(ps) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let xt = ((x.val).type), dt = eval_Type(dest_type)(e) in (if (dt = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let dt' = phi_remove(dt) in (if gt(dt', xt)then mk_EST_value(widen_type((x.val), dt'), (ps.sto), (x.time))else mk_EST_value(<err>, (ps.sto), zerot))))eval_Type' ((unresolved DEFAULT`Type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_Type(mk_(unresolved DEFAULT`Type)(tp))(e) ==(cases tp 'case mk_(unresolved DEFAULT`PrimitiveType)(p) -> eval_PrimitiveType(tp)(e),case mk_(unresolved DEFAULT`VecType)(range, tpe) -> eval_VecType(tp)(e),case mk_(unresolved DEFAULT`StrucType)(tps) -> eval_StrucType(tp)(e),case mk_(unresolved DEFAULT`FlavouredType)(fl, tpe) -> eval_FlavouredType(tp)(e),case mk_(unresolved DEFAULT`UnionTp)(tps) -> eval_UnionTp(tp)(e),case mk_(unresolved DEFAULT`TypeName)(id) -> eval_TypeName(tp)(e)end)eval_PrimitiveType' ((unresolved DEFAULT`PrimitiveType) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_PrimitiveType(mk_(unresolved DEFAULT`PrimitiveType)(pt))(e) ==(if is_(pt, Number)then eval_Number(pt)(e)elseif is_(pt, FloatType)then eval_FloatType(pt)(e)else eval_VoidValType(pt)(e))eval_Number' ((unresolved DEFAULT`Number) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_Number(mk_(unresolved DEFAULT`Number)(rep, range))(e) ==let ranges = {eval_Range(r)(e) | [r in set (elems range)]} in (if (<err> in set ranges)then <err>elseif (rep = <bit>)then (if (exists [v in set (dunion ranges)] & (v not in set {0, 1}))then <err>else let m = {0 |-> false, 1 |-> true} in mk_TrType({m(v) | [v in set (dunion ranges)]}, {}))elseif (rep = <byte>)then (if (exists [v in set (dunion ranges)] & ((abs v) > bytemax))then <err>else mk_IntType(rep, (dunion ranges), {}))elseif (exists [v in set (dunion ranges)] & ((abs v) > maxint))then <err>else mk_IntType(rep, (dunion ranges), {}))eval_Range' ((unresolved DEFAULT`Range) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | set of (int)))))	eval_Range(mk_(unresolved DEFAULT`Range)(lower, upper))(e) ==(if (((lower = nil) and (upper = nil)) or (((lower <> nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper <> nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))then <err>elseif (lower = nil)then {x | [x'int] & ((0 <= x) and (x <= ((eval_CompileTimeValue(upper)(e).val).val)))}elseif (upper = nil)then {x | [x'int] & ((((eval_CompileTimeValue(lower)(e).val).val) <= x) and (x <= maxint))}else {x | [x'int] & ((((eval_CompileTimeValue(lower)(e).val).val) <= x) and (x <= ((eval_CompileTimeValue(upper)(e).val).val)))})eval_FloatType' ((unresolved DEFAULT`FloatType) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_FloatType(mk_(unresolved DEFAULT`FloatType)(ranges, abserr, relerr))(e) ==(if (((abserr = nil) and (relerr = nil)) or (exists [range in set (elems ranges)] & (eval_Range(range)(e) = <err>)))then <err>else let abse = (if (abserr = nil)then mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))else (eval_CompileTimeValue(abserr)(e).val)), rele = (if (relerr = nil)then mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))else (eval_CompileTimeValue(relerr)(e).val)) in (if (not (is_(abse, Real) and is_(rele, Real)))then <err>else mk_Float({mk_Floatrng(min(eval_Range(range)(e)), max(eval_Range(range)(e))) | [range in set (elems ranges)]}, (abse.val), (rele.val), {})))eval_VoidValType' ((unresolved DEFAULT`VoidValType) -> (((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_VoidValType(fl) ==(lambda [e'(unresolved DEFAULT`Env)] & mk_VoidType(eval_Flavouring(fl)))eval_StrucType' ((unresolved DEFAULT`StrucType) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_StrucType(mk_(unresolved DEFAULT`StrucType)(tps))(e) ==let typs = [eval_Type(tps(i))(e) | i in set (inds tps)] in (if (exists [tp in set (elems typs)] & (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))then <err>elseif (exists [tp1, tp2 in set (elems typs)] & ((tp1 <> tp2) and ((tp1.fl) = (tp2.fl))))then <err>else mk_StructureType(typs, {}))eval_VecType' ((unresolved DEFAULT`VecType) -> (((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_VecType(mk_(unresolved DEFAULT`VecType)(range, tp)) ==(lambda [e'(unresolved DEFAULT`Env)] & let typ = eval_Type(tp)(e), nrange = eval_Range(range)(e) in (if ((typ = <err>) or (nrange = <err>))then <err>else mk_VectorType(min(nrange), max(nrange), typ, {})))eval_FlavouredType' ((unresolved DEFAULT`FlavouredType) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_FlavouredType(mk_(unresolved DEFAULT`FlavouredType)(fl, tp))(e) ==let flavour = eval_Flavouring(fl), typ = eval_Type(tp)(e) in (if (typ = <err>)then <err>else (cases typ 'case mk_(unresolved DEFAULT`VoidType)(t) -> mk_VoidType((t union flavour)),case mk_(unresolved DEFAULT`TrType)(range, fl) -> mk_TrType(range, (fl union flavour)),case mk_(unresolved DEFAULT`IntType)(rep, range, fl) -> mk_IntType(rep, range, (fl union flavour)),case mk_(unresolved DEFAULT`Float)(range, abse, rele, fl) -> mk_Float(range, abse, rele, (fl union flavour)),case mk_(unresolved DEFAULT`VectorType)(lower, upper, tp, fl) -> mk_VectorType(lower, upper, tp, (fl union flavour)),case mk_(unresolved DEFAULT`StructureType)(tps, fl) -> mk_StructureType(tps, (fl union flavour)),case mk_(unresolved DEFAULT`UnionType)(tps, fl) -> mk_UnionType(tps, (fl union flavour))end))eval_UnionTp' ((unresolved DEFAULT`UnionTp) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_UnionTp(mk_(unresolved DEFAULT`UnionTp)(tps))(e) ==let typs = {eval_Type(tps(i))(e) | [i in set (inds tps)]} in (if (exists [tp in set typs] & (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))then <err>elseif (exists [t1, t2 in set typs] & fleq(t1, t2))then <err>else mk_UnionType(typs, {}))eval_TypeName' ((unresolved DEFAULT`TypeName) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_TypeName(mk_(unresolved DEFAULT`TypeName)(id))(mk_(m, l)) ==(if (id in set (dom m))then (cases access_env(id)(mk_(m, l)) 'case mk_(unresolved DEFAULT`Location)(l) -> <err>,case mk_(unresolved DEFAULT`Storable_value)(v) -> <err>,case mk_(unresolved DEFAULT`Proc)(p) -> <err>,case <err> -> <err>,case t -> tend)else <err>)eval_Scope' ((unresolved DEFAULT`Scope) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Scope(mk_(unresolved DEFAULT`Scope)(s))(e)(ps) ==(if is_(s, SimpleScope)then eval_SimpleScope(s)(e)(ps)else eval_PackageScope(s)(e)(ps))eval_SimpleScope' ((unresolved DEFAULT`SimpleScope) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_SimpleScope(mk_(unresolved DEFAULT`SimpleScope)(decls, expr))(e)(ps) ==let old_env_st = mk_(e, ps) in let new_env_st = eval_Decls(decls)(old_env_st) in (if (new_env_st = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(new_env, new_sto) = new_env_st in eval_Expression(expr)(new_env)(new_sto))eval_Decls' (seq of ((unresolved DEFAULT`Declaration)) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_Decls(decls)(env_st) ==(if (env_st = <err>)then <err>elseif (decls = [])then env_stelse eval_Decls((tl decls))(eval_Declaration((hd decls))(env_st)))eval_Declaration' ((unresolved DEFAULT`Declaration) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_Declaration(decl)(env_st) ==(cases decl 'case mk_(unresolved DEFAULT`ImportDecl)(id, tp) -> eval_ImportDecl(decl)(env_st),case mk_(unresolved DEFAULT`ExportDecl)(id, expr) -> eval_ExportDecl(decl)(env_st),case mk_(unresolved DEFAULT`LetDecl)(l) -> eval_LetDecl(decl)(env_st),case mk_(unresolved DEFAULT`VarDecl)(id, expr) -> eval_VarDecl(decl)(env_st),case mk_(unresolved DEFAULT`ProcDec)(nls, ph, expr) -> eval_ProcDec(decl)(env_st),case mk_(unresolved DEFAULT`TypeDec)(id, type) -> eval_TypeDec(decl)(env_st)end)eval_ImportDecl' ((unresolved DEFAULT`ImportDecl) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_ImportDecl(mk_(unresolved DEFAULT`ImportDecl)(id, tp))(mk_(e, ps)) ==let type = eval_Type(tp)(e) in (if (type = <err>)then <err>else let val = choose(type), mk_(l, n_e) = reserve_locn(e) in let nn_e = update_env(id)(l)(n_e), sto = update(l)(mk_Storable_value(val))((ps.sto)), t = tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))eval_ExportDecl' ((unresolved DEFAULT`ExportDecl) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_ExportDecl(mk_(unresolved DEFAULT`ExportDecl)(id, expr))(mk_(e, ps)) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else let mk_(l, n_e) = reserve_locn(e) in let nn_e = update_env(id)(l)(n_e), sto = update(l)(mk_Storable_value((x.val)))((ps.sto)), t = tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))eval_LetDecl' ((unresolved DEFAULT`LetDecl) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_LetDecl(mk_(unresolved DEFAULT`LetDecl)(decl))(es) ==(if is_(decl, SimpleLetDecl)then eval_SimpleLetDecl(decl)(es)else eval_StrucLetDecl(decl)(es))eval_SimpleLetDecl' ((unresolved DEFAULT`SimpleLetDecl) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_SimpleLetDecl(mk_(unresolved DEFAULT`SimpleLetDecl)(id, expr))(mk_(e, ps)) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else mk_(update_env(id)((x.val))(e), mk_PState((ps.sto), (x.time))))eval_StrucLetDecl' ((unresolved DEFAULT`StrucLetDecl) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_StrucLetDecl(mk_(unresolved DEFAULT`StrucLetDecl)(ids, expr))(mk_(e, ps)) ==let x = eval_Expression(expr)(e)(ps) in (if (not is_((x.val), Structure))then <err>elseif ((len ids) <> struc_length(((x.val).type)))then <err>else let id_vals = [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in let new_env = multi_update_env(id_vals)(e) in mk_(new_env, mk_PState((ps.sto), (x.time))))eval_VarDecl' ((unresolved DEFAULT`VarDecl) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_VarDecl(mk_(unresolved DEFAULT`VarDecl)(id, expr))(mk_(e, ps)) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else let mk_(l, n_e) = reserve_locn(e) in let nn_e = update_env(id)(l)(n_e), sto = update(l)(mk_Storable_value((x.val)))((ps.sto)), t = tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))eval_ProcDec' ((unresolved DEFAULT`ProcDec) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_ProcDec(mk_(unresolved DEFAULT`ProcDec)(nls, ph, expr))(mk_(e, ps)) ==let env_st = eval_NonLocals(nls)(e)(ps) in (if (env_st = <err>)then <err>else let mk_(unresolved DEFAULT`ProcHeading)(id, formals) = ph, mk_(ne, ns) = env_st in let fls = eval_Formals(formals)(e) in let pr = mk_Proc((lambda [a'(unresolved DEFAULT`Param)] & let nn_e = instantiate_formals(fls)(a)(ne) in (lambda [nps'(unresolved DEFAULT`PState)] & (if (nn_e = <err>)then mk_EST_value(<err>, (nps.sto), zerot)else let x = eval_Expression(expr)(nn_e)(nps) in (if (((x.val) <> <err>) and ((is_((x.val), Void) and (((x.val).type) = mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) = {Phi}))))then mk_EST_value(<err>, (nps.sto), zerot)else x))))) in mk_(update_env(id)(pr)(e), mk_PState((ps.sto), (ns.time))))eval_NonLocals' ((unresolved DEFAULT`NonLocals) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EnvState))))	eval_NonLocals(mk_(unresolved DEFAULT`NonLocals)(ids, decls))(mk_(m, l))(ps) ==let ids_map = (if (ids = nil)then {}else ((elems ids) <' m)) in (if (decls = nil)then mk_(mk_(ids_map, l), ps)else eval_Decls(decls)(mk_(mk_(ids_map, l), ps)))eval_Formals' (seq of ((unresolved DEFAULT`Formal)) -> ((unresolved DEFAULT`Env) -> seq of ((unresolved DEFAULT`Formal_elt))))	eval_Formals(fls)(e) ==[eval_Formal(fls(i))(e) | i in set (inds fls)]eval_Formal' ((unresolved DEFAULT`Formal) -> ((unresolved DEFAULT`Env) -> (unresolved DEFAULT`Formal_elt)))	eval_Formal(mk_(unresolved DEFAULT`Formal)(id, rep, fl))(e) ==let n_rep = eval_Representation(rep)(e), n_fl = eval_Flavouring(fl) in mk_Formal_elt(id, n_rep, n_fl)eval_Representation' ((unresolved DEFAULT`Representation) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_Representation(rep)(e) ==(cases rep 'case mk_(unresolved DEFAULT`PrimitiveRep)(p) -> eval_PrimitiveRep(rep)(e),case mk_(unresolved DEFAULT`StrucRep)(rs) -> eval_StrucRep(rep)(e),case mk_(unresolved DEFAULT`VecRep)(range, r) -> eval_VecRep(rep)(e),case mk_(unresolved DEFAULT`UnionRep)(rs) -> eval_UnionRep(rep)(e),case mk_(unresolved DEFAULT`FlavouredRep)(f, r) -> eval_FlavouredRep(rep)(e),case mk_(unresolved DEFAULT`Type)(t) -> eval_Type(rep)(e)end)eval_PrimitiveRep' ((unresolved DEFAULT`PrimitiveRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_PrimitiveRep(mk_(unresolved DEFAULT`PrimitiveRep)(rep))(e) ==(if is_(rep, NumRep)then eval_NumRep(rep)(e)else eval_FloatRep(rep)(e))eval_NumRep' ((unresolved DEFAULT`NumRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_NumRep(mk_(unresolved DEFAULT`NumRep)(rep, range))(e) ==let ranges = (if (range = nil)then {}else {eval_Range(r)(e) | [r in set (elems range)]}) in (if (<err> in set ranges)then <err>elseif (rep = <bit>)then (if (exists [v in set (dunion ranges)] & (v not in set {0, 1}))then <err>else let rngs = (if (range = nil)then {true, false}else {{0 |-> false, 1 |-> true}(r) | [r in set (dunion ranges)]}) in mk_TrType(rngs, {}))elseif (rep = <byte>)then (if (exists [v in set (dunion ranges)] & ((abs v) > bytemax))then <err>else let rngs = (if (range = nil)then {-bytemax, ... ,bytemax}else (dunion ranges)) in mk_IntType(rep, rngs, {}))elseif (exists [v in set (dunion ranges)] & ((abs v) > maxint))then <err>else let rngs = (if (range = nil)then {-maxint, ... ,maxint}else (dunion ranges)) in mk_IntType(rep, rngs, {}))eval_FloatRep' ((unresolved DEFAULT`FloatRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_FloatRep(mk_(unresolved DEFAULT`FloatRep)(range, abserr, relerr))(e) ==let ranges = (if (range = nil)then {}else {eval_Range(r)(e) | [r in set (elems range)]}), abse = (if (abserr = nil)then mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))else eval_CompileTimeValue(abserr)(e)), rele = (if (relerr = nil)then mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))else eval_CompileTimeValue(relerr)(e)) in (if ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (<err> in set ranges))then <err>else let rngs = (if (range = nil)then {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}else {mk_Floatrng(min(r), max(r)) | [r in set ranges]}) in mk_Float(rngs, ((abse.val).val), ((rele.val).val), {}))eval_StrucRep' ((unresolved DEFAULT`StrucRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_StrucRep(mk_(unresolved DEFAULT`StrucRep)(reps))(e) ==let tps = [eval_Representation(reps(i))(e) | i in set (inds reps)] in (if (exists [tp in set (elems tps)] & (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))then <err>elseif (exists [tp1, tp2 in set (elems tps)] & fleq(tp1, tp2))then <err>else mk_StructureType(tps, {}))eval_VecRep' ((unresolved DEFAULT`VecRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_VecRep(mk_(unresolved DEFAULT`VecRep)(range, rep))(e) ==let nrange = eval_Range(range)(e), type = eval_Representation(rep)(e) in (if ((type = <err>) or (nrange = <err>))then <err>else mk_VectorType(min(nrange), max(nrange), type, {}))eval_UnionRep' ((unresolved DEFAULT`UnionRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_UnionRep(mk_(unresolved DEFAULT`UnionRep)(reps))(e) ==let tps = {eval_Representation(rep)(e) | [rep in set (elems reps)]} in (if (exists [tp in set tps] & (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))then <err>elseif (exists [tp1, tp2 in set tps] & fleq(tp1, tp2))then <err>else mk_UnionType(tps, {}))eval_FlavouredRep' ((unresolved DEFAULT`FlavouredRep) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type)))))	eval_FlavouredRep(mk_(unresolved DEFAULT`FlavouredRep)(fl, rep))(e) ==let type = eval_Representation(rep)(e), flav = eval_Flavouring(fl) in (if (type = <err>)then <err>else replace_flavour(type, flav))eval_TypeDec' ((unresolved DEFAULT`TypeDec) -> ((unresolved DEFAULT`EnvState) -> (unresolved DEFAULT`EnvState)))	eval_TypeDec(mk_(unresolved DEFAULT`TypeDec)(id, tp))(mk_(e, ps)) ==let type = eval_Type(tp)(e) in (if (type = <err>)then <err>else mk_(update_env(id)(type)(e), ps))eval_PackageScope' ((unresolved DEFAULT`PackageScope) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_PackageScope(mk_(unresolved DEFAULT`PackageScope)(ids, decls, expr))(mk_(m, l))(ps) ==let env_st = mk_(mk_(m, l), ps) in let new_env_st = eval_Decls(decls)(env_st) in (if (new_env_st = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(mk_(nm, nl), nps) = new_env_st in (if (not ((elems ids) subset ((dom nm) \ (dom m))))then mk_EST_value(<err>, (ps.sto), zerot)else let ne = mk_((((elems ids) union (dom m)) <' nm), nl) in eval_Expression(expr)(ne)(nps)))eval_GuardedScope' ((unresolved DEFAULT`GuardedScope) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_GuardedScope(mk_(unresolved DEFAULT`GuardedScope)(decls, incl, outcl))(e)(ps) ==let g_decl = eval_GuardedDeclarations(decls)(true)(e)(ps) in (if (g_decl = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(ne, nps, val) = g_decl in let in_val = eval_Sequence(incl)(ne)(nps), out_val = eval_Sequence(outcl)(ne)(nps) in (if (((in_val.val) = <err>) or ((out_val.val) = <err>))then mk_EST_value(<err>, (ps.sto), zerot)else let type = setlub({((in_val.val).type), ((out_val.val).type)}) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else (if valthen mk_EST_value(widen_type((in_val.val), type), (in_val.sto), tplus((in_val.time), t_if))else mk_EST_value(widen_type((out_val.val), type), (out_val.sto), tplus((out_val.time), t_if))))))eval_GuardedDeclarations' (seq1 of ((unresolved DEFAULT`GuardedDeclaration)) -> (bool -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Env) * (unresolved DEFAULT`PState) * bool)) | (unresolved DEFAULT`Errvalue)))))))	eval_GuardedDeclarations(decls)(b)(e)(ps) ==let gdcl = eval_GuardedDecl((hd decls))(e)(ps) in (if ((len decls) = 1)then gdclelseif (gdcl = <err>)then <err>else let mk_(ne, nps, tr) = gdcl in eval_GuardedDeclarations((tl decls))((b and tr))(ne)(nps))eval_GuardedDecl' ((unresolved DEFAULT`GuardedDeclaration) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Env) * (unresolved DEFAULT`PState) * bool)) | (unresolved DEFAULT`Errvalue))))))	eval_GuardedDecl(decl)(e)(ps) ==(if is_(decl, WhereDecl)then eval_WhereDecl(decl)(e)(ps)else let d = eval_Declaration(decl)(mk_(e, ps)) in (if (d = <err>)then <err>else let mk_(ne, nps) = d in mk_(ne, nps, true)))eval_WhereDecl' ((unresolved DEFAULT`WhereDecl) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Env) * (unresolved DEFAULT`PState) * bool)) | (unresolved DEFAULT`Errvalue))))))	eval_WhereDecl(mk_(unresolved DEFAULT`WhereDecl)(type, expr, id))(e)(ps) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else let t = eval_SkeletonType(type)(((x.val).type))(e) in (cases t 'case <err> -> <err>others let env = (if (id = nil)then eelse update_env(id)((x.val))(e)) in let xt = const_type((x.val)) in (cases xt 'case <err> -> <err>others let val = gt(t, xt) in mk_(env, mk_PState((ps.sto), (x.time)), val)end)end))eval_Assertion' ((unresolved DEFAULT`Assertion) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Assertion(mk_(unresolved DEFAULT`Assertion)(expr, tp))(e)(ps) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let type = eval_SkeletonType(tp)(((x.val).type))(e) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let xt = const_type((x.val)) in (cases xt 'case <err> -> mk_EST_value(<err>, (ps.sto), zerot)others (if (not (tleq(type, ((x.val).type)) and tleq(xt, type)))then mk_EST_value(<err>, (ps.sto), zerot)else let val = widen_type((x.val), phi_remove(type)) in mk_EST_value(val, (x.sto), tplus((x.time), t_widen_type)))end)))eval_Conditional' ((unresolved DEFAULT`Conditional) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Conditional(mk_(unresolved DEFAULT`Conditional)(cond))(e)(ps) ==(if is_(cond, IfThenOnly)then eval_IfThenOnly(cond)(e)(ps)elseif is_(cond, IfThenElse)then eval_IfThenElse(cond)(e)(ps)else eval_CaseExpr(cond)(e)(ps))eval_IfThenOnly' ((unresolved DEFAULT`IfThenOnly) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_IfThenOnly(mk_(unresolved DEFAULT`IfThenOnly)(prop, action))(e)(ps) ==let cond = eval_Expression(prop)(e)(ps), aseq = eval_Sequence(action)(e)(mu(ps, time |-> tplus((cond.time), t_if))) in (if ((not is_((cond.val), Tr)) or (not is_((aseq.val), Void)))then mk_EST_value(<err>, (ps.sto), zerot)elseif ((cond.val).val)then aseqelse mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), tplus((ps.time), tplus((cond.time), t_if))))eval_IfThenElse' ((unresolved DEFAULT`IfThenElse) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_IfThenElse(mk_(unresolved DEFAULT`IfThenElse)(prop, thenaction, elseaction))(e)(ps) ==let cond = eval_Expression(prop)(e)(ps) in (if (not is_((cond.val), Tr))then mk_EST_value(<err>, (ps.sto), zerot)else let then_x = eval_Sequence(thenaction)(e)(ps), else_x = eval_Sequence(elseaction)(e)(ps) in let type = lub(((then_x.val).type), ((else_x.val).type)) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)elseif ((cond.val).val)then mu(then_x, val |-> widen_type((then_x.val), type), time |-> tplus((then_x.time), (cond.time)))else mu(else_x, val |-> widen_type((else_x.val), type), time |-> tplus((else_x.time), (cond.time)))))eval_CaseExpr' ((unresolved DEFAULT`CaseExpr) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_CaseExpr(mk_(unresolved DEFAULT`CaseExpr)(expr, limbs, outlimb))(e)(ps) ==let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let type_x = ((x.val).type) in let ls = eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-> (x.time))) in let os = (if (outlimb = nil)then []else let mk_(t, v) = ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-> (v.time))))]) in let pats = (ls ^ os) in (if (exists [mk_(t, v) in set (elems pats)] & ((v.val) = <err>))then mk_EST_value(<err>, (ps.sto), zerot)else let patlub = setlub({t | [mk_(t, v) in set (elems pats)]}) in (if (patlub = <err>)then mk_EST_value(<err>, (ps.sto), zerot)elseif (lub(type_x, patlub) <> patlub)then mk_EST_value(<err>, (ps.sto), zerot)else let type = setlub({((v.val).type) | [mk_(t, v) in set (elems pats)]}) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let x_type = const_type((x.val)) in let matches = [pats(i) | i in set (inds pats) & let mk_(t, v) = pats(i) in (lub(x_type, t) = t)] in let mk_(mt, mv) = (hd matches) in let time = dtplus([(mv.time), t_const_type, t_widen_type]) in mk_EST_value(widen_type((mv.val), type), (mv.sto), time)))))eval_Limbs' (seq1 of ((unresolved DEFAULT`CaseLimb)) -> ((unresolved DEFAULT`Expressible_value) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> seq1 of ((((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`EST_value))))))))	eval_Limbs(limbs)(x)(e)(ps) ==let mk_(t, v) = eval_Limb((hd limbs))(x)(e)(ps) in (if ((len limbs) = 1)then [mk_(t, v)]else ([mk_(t, v)] ^ eval_Limbs((tl limbs))(x)(e)(mu(ps, time |-> (v.time)))))eval_Limb' ((unresolved DEFAULT`CaseLimb) -> ((unresolved DEFAULT`Expressible_value) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`EST_value)))))))	eval_Limb(mk_(unresolved DEFAULT`CaseLimb)(test, sequ))(x)(e)(ps) ==let t = eval_Tester(test)(x)(e)(ps) in (if (t = <err>)then mk_(mk_VoidType({}), mk_EST_value(<err>, (ps.sto), zerot))else let mk_(type, env, tm) = t in let val = eval_Sequence(sequ)(env)(mu(ps, time |-> tm)) in (if ((val.val) = <err>)then mk_(mk_VoidType({}), mk_EST_value(<err>, (ps.sto), zerot))else mk_(type, val)))eval_Tester' ((unresolved DEFAULT`Tester) -> ((unresolved DEFAULT`Expressible_value) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Env) * (unresolved DEFAULT`Time))) | (unresolved DEFAULT`Errvalue)))))))	eval_Tester(tester)(x)(e)(ps) ==(cases tester 'case mk_(unresolved DEFAULT`SkeletonType)(t) -> let nt = eval_SkeletonType(tester)((x.type))(e) in (if (nt = <err>)then <err>else mk_(nt, e, (ps.time))),case mk_(unresolved DEFAULT`StrucTest)(s) -> eval_StrucTest(tester)(x)(e)(ps),case mk_(unresolved DEFAULT`NonStrucTest)(id, tp, fl) -> eval_NonStrucTest(tester)(x)(e)(ps)end)eval_SkeletonType' ((unresolved DEFAULT`SkeletonType) -> ((unresolved DEFAULT`Expressible_type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_SkeletonType(mk_(unresolved DEFAULT`SkeletonType)(skel))(t)(e) ==(cases skel 'case mk_(unresolved DEFAULT`Type)(t) -> eval_Type(skel)(e),case mk_(unresolved DEFAULT`NumSkel)(r, er) -> eval_NumSkel(skel)(t)(e),case mk_(unresolved DEFAULT`StrucSkel)(s) -> eval_StrucSkel(skel)(t)(e),case mk_(unresolved DEFAULT`FlavSkel)(s, fl) -> eval_FlavSkel(skel)(t)(e),case mk_(unresolved DEFAULT`VecSkel)(s) -> eval_VecSkel(skel)(t)(e),case mk_(unresolved DEFAULT`UnionSkel)(s) -> eval_UnionSkel(skel)(t)(e)end)eval_NumSkel' ((unresolved DEFAULT`NumSkel) -> ((unresolved DEFAULT`Expressible_type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_NumSkel(mk_(unresolved DEFAULT`NumSkel)(ranges, errors))(x_type)(e) ==(if (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))then <err>else let rngs = (if (ranges = nil)then (if is_(x_type, Float)then {{l, ... ,u} | [mk_(unresolved DEFAULT`Floatrng)(l, u) in set (x_type.range)]}else {(x_type.range)})else {eval_Range(r)(e) | [r in set (elems ranges)]}) in (if (<err> in set rngs)then <err>else (cases x_type 'case mk_(unresolved DEFAULT`TrType)(range, fl) -> (if (not ((dunion rngs) subset {0, 1}))then <err>else mk_TrType({{0 |-> false, 1 |-> true}(v) | [v in set (dunion rngs)]}, fl)),case mk_(unresolved DEFAULT`IntType)(rep, range, fl) -> (if (((rep = <byte>) and (exists [v in set (dunion rngs)] & ((abs v) >= bytemax))) or (exists [v in set (dunion rngs)] & ((abs v) >= maxint)))then <err>else mk_IntType(rep, (dunion rngs), fl)),case mk_(unresolved DEFAULT`Float)(rs, abse, rele, fl) -> (if (exists [v in set (dunion rngs)] & ((abs v) >= maxint))then <err>else let abserr = (if ((errors.abserr) = nil)then abseelse let v1 = (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 = <err>)then <err>else (v1.val))), relerr = (if ((errors.relerr) = nil)then releelse let v1 = (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 = <err>)then <err>else (v1.val))) in (if (not (is_(abserr, real) and is_(relerr, real)))then <err>else mk_Float({mk_Floatrng(min(r), max(r)) | [r in set rngs]}, abserr, relerr, fl)))end)))eval_StrucSkel' ((unresolved DEFAULT`StrucSkel) -> ((unresolved DEFAULT`Expressible_type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_StrucSkel(mk_(unresolved DEFAULT`StrucSkel)(comps))(x_type)(e) ==(if (not is_(x_type, StructureType))then <err>elseif (struc_length(x_type) <> (len comps))then <err>else let t = [(if (comps(i) = <nil>)then (x_type.tps)(i)else eval_SkeletonType(comps(i))((x_type.tps)(i))(e)) | i in set (inds comps)] in (if (exists [tp in set (elems t)] & (not (is_(tp, TrType) or (is_(tp, IntType) or is_(tp, Float)))))then <err>else mk_StructureType(t, (x_type.fl))))eval_FlavSkel' ((unresolved DEFAULT`FlavSkel) -> ((unresolved DEFAULT`Expressible_type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_FlavSkel(mk_(unresolved DEFAULT`FlavSkel)(skel, fl))(x_type)(e) ==let t = eval_SkeletonType(skel)(x_type)(e), f = eval_Flavouring(fl) in (if (t = <err>)then <err>else replace_flavour(t, f))eval_VecSkel' ((unresolved DEFAULT`VecSkel) -> ((unresolved DEFAULT`Expressible_type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_VecSkel(mk_(unresolved DEFAULT`VecSkel)(skel))(x_type)(e) ==let t = eval_SkeletonType(skel)(x_type)(e) in (if (t = <err>)then <err>else (cases x_type 'case mk_(unresolved DEFAULT`VectorType)(l, u, tp, fl) -> mk_VectorType(l, u, t, fl)others <err>end))eval_UnionSkel' ((unresolved DEFAULT`UnionSkel) -> ((unresolved DEFAULT`Expressible_type) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Expressible_type))))))	eval_UnionSkel(mk_(unresolved DEFAULT`UnionSkel)(skels))(x_type)(e) ==let fls = {skel |-> fl | skel in set (elems skels), fl'(unresolved DEFAULT`Flavdom) & (fl = (cases skel 'case mk_(unresolved DEFAULT`FlavSkel)(skel, f) -> eval_Flavouring(f),case mk_(unresolved DEFAULT`FlavouredType)(f, t) -> eval_Flavouring(f)others eval_Flavouring(skel)end))} in (if ((card (dom fls)) <> (card (rng fls)))then <err>elseif is_(x_type, UnionType)then let x_fls = (merge {{mk_VoidType(f) |-> f | mk_(unresolved DEFAULT`VoidType)(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-> fl | mk_(unresolved DEFAULT`IntType)(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-> fl | mk_(unresolved DEFAULT`TrType)(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-> fl | mk_(unresolved DEFAULT`Float)(rs, a, r, fl) in set (x_type.tps)}}) in (if (not ((rng fls) subset (rng x_fls)))then <err>else let tps = {(cases skel 'case mk_(unresolved DEFAULT`FlavSkel)(s, f) -> eval_FlavSkel(skel)(tp)(e),case mk_(unresolved DEFAULT`FlavouredType)(f, t) -> eval_FlavouredType(skel)(e)others eval_VoidValType(skel)(e)end) | [skel in set (elems skels), tp in set (x_type.tps)] & (fls(skel) = x_fls(tp))} in (if (exists [tp in set tps] & (not (is_(tp, TrType) or (is_(tp, IntType) or (is_(tp, Float) or is_(tp, VoidType))))))then <err>else mk_UnionType(tps, (x_type.fl))))else let fl = (if is_(x_type, VoidType)then x_typeelse (x_type.fl)) in (if (fl not in set (rng fls))then <err>else let skel = (iota s in set (elems skels) & (fls(s) = fl)) in (cases skel 'case mk_(unresolved DEFAULT`FlavSkel)(s, f) -> eval_FlavSkel(skel)(x_type)(e),case mk_(unresolved DEFAULT`FlavouredType)(f, t) -> eval_FlavouredType(skel)(e)others eval_VoidValType(skel)(e)end)))eval_NonStrucTest' ((unresolved DEFAULT`NonStrucTest) -> ((unresolved DEFAULT`Expressible_value) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Env) * (unresolved DEFAULT`Time))) | (unresolved DEFAULT`Errvalue)))))))	eval_NonStrucTest(mk_(unresolved DEFAULT`NonStrucTest)(id, fl, skel))(x)(e)(ps) ==let t = eval_SkeletonType(skel)((x.type))(e) in (if (t = <err>)then <err>else let t' = (if (fl = nil)then telse replace_flavour(t, eval_Flavouring(fl))) in (if (id = nil)then mk_(t', e, (ps.time))else mk_(t', update_env(id)(x)(e), (ps.time))))eval_StrucTest' ((unresolved DEFAULT`StrucTest) -> ((unresolved DEFAULT`Expressible_value) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Expressible_type) * (unresolved DEFAULT`Env) * (unresolved DEFAULT`Time))) | (unresolved DEFAULT`Errvalue)))))))	eval_StrucTest(mk_(unresolved DEFAULT`StrucTest)(tests))(x)(e)(ps) ==(if (not is_(x, Structure))then <err>elseif (struc_length((x.type)) <> (len tests))then <err>else let xs = [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts = eval_Testseq(tests)(xs)(e)(ps) in (if (ts = <err>)then <err>else let mk_(tps, env, time) = ts in mk_(mk_StructureType(tps, ((x.type).fl)), env, time)))eval_Testseq' (seq of ((((unresolved DEFAULT`NonStrucTest) | <nil>))) -> (seq of ((unresolved DEFAULT`Expressible_value)) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> ((((seq of ((unresolved DEFAULT`Expressible_type)) * (unresolved DEFAULT`Env) * (unresolved DEFAULT`Time))) | (unresolved DEFAULT`Errvalue)))))))	eval_Testseq(tests)(xs)(e)(ps) ==(if (tests = [])then mk_([], e, (ps.time))else let t = (if ((hd tests) = <nil>)then mk_(((hd xs).type), e, (ps.time))else eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in (if (t = <err>)then <err>else let mk_(tp, env, time) = t in let ts = eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-> time)) in (if (ts = <err>)then <err>else let mk_(tps, n_env, n_time) = ts in mk_(([tp] ^ tps), n_env, n_time))))eval_OuterLoop' ((unresolved DEFAULT`OuterLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_OuterLoop(mk_(unresolved DEFAULT`OuterLoop)(oul))(e)(ps) ==(if is_(oul, OuterIntLoop)then eval_OuterIntLoop(oul)(e)(ps)else eval_OuterVecLoop(oul)(e)(ps))eval_OuterIntLoop' ((unresolved DEFAULT`OuterIntLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_OuterIntLoop(mk_(unresolved DEFAULT`OuterIntLoop)(mk_(unresolved DEFAULT`OverRange)(id, range), actns))(e)(ps) ==let nrange = eval_Range(range)(e) in (if (nrange = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let vec_elems = [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(<word>, {i}, {}))))(e))(mu(ps, time |-> zerot)) | i in set nrange] in (if (<err> in set {(x.val) | [x in set (elems vec_elems)]})then mk_EST_value(<err>, (ps.sto), zerot)else let type = seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time = dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let vec_val = (if (is_(type, StructureType) or is_(type, VectorType))then [((vec_elems(i).val).val) | i in set (inds vec_elems)]else [(vec_elems(i).val) | i in set (inds vec_elems)]) in mk_EST_value(mk_Vector(vec_val, mk_VectorType(1, (len vec_val), type, {})), (ps.sto), tplus((ps.time), time)))))eval_OuterVecLoop' ((unresolved DEFAULT`OuterVecLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_OuterVecLoop(mk_(unresolved DEFAULT`OuterVecLoop)(ovs, actions))(e)(ps) ==let idvs = eval_OverVectors(ovs)(e)(ps) in (if (idvs = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let time1 = dtplus([let mk_(id, v, t) = idvs(i) in t | i in set (inds idvs)]), new_env = (lambda [i'nat] & multi_update_env(([let mk_(id, v, t) = idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) = nil)then []else [mk_((ovs.cnt), i)])))(e)) in let vec_elems = [eval_Sequence(actions)(new_env(i))(mu(ps, time |-> zerot)) | i in set let mk_(i1, v, t) = idvs(1) in (inds (v.val))] in (if (<err> in set {(x.val) | [x in set (elems vec_elems)]})then mk_EST_value(<err>, (ps.sto), zerot)else let type = seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time = dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let new_tp = mk_VectorType(1, (len vec_elems), type, {}) in let vec_val = (if (is_(type, StructureType) or is_(type, VectorType))then [((vec_elems(i).val).val) | i in set (inds vec_elems)]else [(vec_elems(i).val) | i in set (inds vec_elems)]) in let new_vec = mk_Vector(vec_val, new_tp) in mk_EST_value(new_vec, (ps.sto), tplus((ps.time), time)))))eval_OverVectors' ((unresolved DEFAULT`OverVectors) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((unresolved DEFAULT`Errvalue) | seq1 of ((((unresolved DEFAULT`Id) * (unresolved DEFAULT`Vector) * (unresolved DEFAULT`Time)))))))))	eval_OverVectors(ovs)(e)(ps) ==let indices = [let mk_(unresolved DEFAULT`OverVector)(id, val) = (ovs.ovv)(i) in let x = eval_Operation(val)(e)(mu(ps, time |-> zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists [i in set (inds indices)] & let mk_(id, v, t) = indices(i) in (not is_(v, Vector)))then <err>else indices)eval_InnerLoop' ((unresolved DEFAULT`InnerLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_InnerLoop(mk_(unresolved DEFAULT`InnerLoop)(innerl))(e)(ps) ==(cases innerl 'case mk_(unresolved DEFAULT`IntLoop)(inc, actions) -> eval_IntLoop(innerl)(e)(ps),case mk_(unresolved DEFAULT`VecLoop)(ovs, actions) -> eval_VecLoop(innerl)(e)(ps),case mk_(unresolved DEFAULT`TimeLoop)(time, actions) -> eval_TimeLoop(innerl)(e)(ps)end)eval_IntLoop' ((unresolved DEFAULT`IntLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_IntLoop(mk_(unresolved DEFAULT`IntLoop)(inc, actions))(e)(ps) ==let idrng = eval_InnerControl(inc)(e)(ps) in (if (idrng = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(id, range) = idrng in let f'((unresolved DEFAULT`EST_Iterate) -> (unresolved DEFAULT`EST_Iterate)) = (lambda [x'(unresolved DEFAULT`EST_Iterate)] & let new_env = update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(<word>, (elems range), {}))))(e) in eval_SeqIterate(actions)(new_env)(x)) in let exi = NIterate(f, (len range))(mk_EST_Iterate(mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), (ps.time)), 1)) in (exi.expst))eval_InnerControl' ((unresolved DEFAULT`InnerControl) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (((((unresolved DEFAULT`Id) * seq of (int))) | (unresolved DEFAULT`Errvalue))))))	eval_InnerControl(inc)(e)(ps) ==(cases inc 'case mk_(unresolved DEFAULT`OverRange)(cnt, range) -> let r = eval_Range(range)(e) in (if (r = <err>)then <err>else mk_(cnt, [x | x in set r])),case mk_(unresolved DEFAULT`PartialRange)(cnt, from_b, to_b, inc) -> let b1 = eval_Operation(from_b)(e)(ps), b2 = eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))then <err>else let b3 = (if (inc = nil)then (if (((b1.val).val) <= ((b2.val).val))then mk_Int(1, mk_IntType(<byte>, {1, -1}, {}))else mk_Int(-1, mk_IntType(<byte>, {1, -1}, {})))else (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists [v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range)] & (((v2 - v1) * v3) < 0))))then <err>else let r = [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} & ((abs (alpha * (b3.val))) <= (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))end)eval_SeqIterate' ((unresolved DEFAULT`Sequence) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`EST_Iterate) -> (unresolved DEFAULT`EST_Iterate))))	eval_SeqIterate(sequ)(e)(exi) ==(if (((exi.expst).val) = <err>)then mu(exi, i |-> ((exi.i) + 1))else let new_expst = eval_Sequence(sequ)(e)(mk_PState(((exi.expst).sto), ((exi.expst).time))) in mk_EST_Iterate(new_expst, ((exi.i) + 1)))eval_VecLoop' ((unresolved DEFAULT`VecLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_VecLoop(mk_(unresolved DEFAULT`VecLoop)(ovs, actions))(e)(ps) ==let indices = eval_OverVectors(ovs)(e)(ps) in (if (indices = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let time = dtplus([let mk_(id, v, t) = indices(i) in t | i in set (inds indices)]) in let f'((unresolved DEFAULT`EST_Iterate) -> (unresolved DEFAULT`EST_Iterate)) = (lambda [x'(unresolved DEFAULT`EST_Iterate)] & let env = multi_update_env([let mk_(id, v, t) = indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst = mu((x.expst), time |-> ((x.expst).time)) in let new_env = (if ((ovs.cnt) = nil)then envelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(<word>, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-> new_expst))) in let mk_(-, v, -) = indices(1) in let exi = NIterate(f, (len (v.val)))(mk_EST_Iterate(mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), tplus((ps.time), time)), 1)) in (exi.expst))eval_TimeLoop' ((unresolved DEFAULT`TimeLoop) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_TimeLoop(mk_(unresolved DEFAULT`TimeLoop)(time, actions))(e)(ps) ==let t = eval_TimeInterval(time)(e), x = eval_Sequence(actions)(e)(mu(ps, time |-> zerot)) in (if ((t = <err>) or ((x.val) = <err>))then mk_EST_value(<err>, (ps.sto), zerot)elseif (exists [n'nat] & timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t))then let its = (iota n'nat & (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))), f'((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value)) = (lambda [exs'(unresolved DEFAULT`EST_value)] & eval_Sequence(actions)(e)(mk_PState((exs.sto), (exs.time)))) in Iterate(f, its)(mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), (ps.time)))else mk_EST_value(<err>, (ps.sto), zerot))eval_Assignment' ((unresolved DEFAULT`Assignment) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_Assignment(mk_(unresolved DEFAULT`Assignment)(ass))(env)(ps) ==(cases ass 'case mk_(unresolved DEFAULT`NvAssignment)(d, e) -> eval_NvAssignment(ass)(env)(ps),case mk_(unresolved DEFAULT`MultAssignment)(d, m, e) -> eval_MultAssignment(ass)(env)(ps),case mk_(unresolved DEFAULT`StrAssignment)(d, e) -> eval_StrAssignment(ass)(env)(ps)end)eval_NvAssignment' ((unresolved DEFAULT`NvAssignment) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_NvAssignment(mk_(unresolved DEFAULT`NvAssignment)(dest, expr))(e)(ps) ==let l = access_env(dest)(e) in (if (not is_(l, Location))then mk_EST_value(<err>, (ps.sto), zerot)else let x = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)elseif (cases ((x.val).type) 'case mk_(unresolved DEFAULT`VoidType)(t) -> (t = {Phi})others ((((x.val).type).fl) = {Phi})end)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(unresolved DEFAULT`Storable_value)(dest_val) = access(l)((ps.sto)) in (if gt((dest_val.type), ((x.val).type))then let new_sto = update(l)(mk_Storable_value(widen_type((x.val), (dest_val.type))))((ps.sto)) in mk_EST_value(mk_Void(<nil>, mk_VoidType({})), new_sto, tplus(tplus((ps.time), t_update), t_access))else mk_EST_value(<err>, (ps.sto), zerot))))eval_MultAssignment' ((unresolved DEFAULT`MultAssignment) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_MultAssignment(mk_(unresolved DEFAULT`MultAssignment)(dest, mult, expr))(e)(ps) ==let l = access_env(dest)(e) in (if (not is_(l, Location))then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(unresolved DEFAULT`Storable_value)(v) = access(l)((ps.sto)) in (if (not is_(v, Vector))then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(unresolved DEFAULT`Vector)(val, type) = v in let v' = eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x = eval_Expression(expr)(e)(mk_PState((v'.sto), (v'.time))) in (if (((v'.val) = <err>) or (not is_((x.val), Vector)))then mk_EST_value(<err>, (ps.sto), zerot)elseif ((((((x.val).type).upper) - (((x.val).type).lower)) <> ((((v'.val).type).upper) - (((v'.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) 'case mk_(unresolved DEFAULT`VoidType)(t) -> (t = {Phi})others ((((x.val).type).fl) = {Phi})end)))then mk_EST_value(<err>, (ps.sto), zerot)else let vleft = mk_Vector(vector_subv(val, (type.lower), ((((v'.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v'.val).type).lower) - 1), (type.type), (type.fl))), vmid = (x.val), vright = mk_Vector(vector_subv(val, ((((v'.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v'.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec = vector_concat(vector_concat(vleft, vmid), vright), new_time = dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in mk_EST_value(mk_Void(<nil>, mk_VoidType({})), update(l)(mk_Storable_value(new_vec))((ps.sto)), new_time))))eval_StrAssignment' ((unresolved DEFAULT`StrAssignment) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_StrAssignment(mk_(unresolved DEFAULT`StrAssignment)(dest, expr))(e)(ps) ==let ls = [access_env(dest(i))(e) | i in set (inds dest)] in (if (exists [l in set (elems ls)] & (not is_(l, Location)))then mk_EST_value(<err>, (ps.sto), zerot)else let x = eval_Expression(expr)(e)(ps) in (if (not is_((x.val), Structure))then mk_EST_value(<err>, (ps.sto), zerot)elseif ((len ls) <> struc_length(((x.val).type)))then mk_EST_value(<err>, (ps.sto), zerot)else let nvals = [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals = [let mk_(unresolved DEFAULT`Storable_value)(v) = nvals(i) in v | i in set (inds nvals)] in let dest_tps = [(vals(i).type) | i in set (inds vals)], x_tps = [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (if (exists [i in set (inds dest_tps)] & (not gt(dest_tps(i), x_tps(i))))then mk_EST_value(<err>, (ps.sto), zerot)else let ys = [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t = dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in mk_EST_value(mk_Void(<nil>, mk_VoidType({})), multi_update(ls)(ys)((ps.sto)), new_t))))eval_TimedExpression' ((unresolved DEFAULT`TimedExpression) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_TimedExpression(mk_(unresolved DEFAULT`TimedExpression)(texpr))(e)(ps) ==(if is_(texpr, TimeTakes)then eval_TimeTakes(texpr)(e)(ps)else eval_TimeAssertion(texpr)(e)(ps))eval_TimeTakes' ((unresolved DEFAULT`TimeTakes) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_TimeTakes(mk_(unresolved DEFAULT`TimeTakes)(expr, time))(e)(ps) ==let x = eval_Expression(expr)(e)(mu(ps, time |-> zerot)), t = eval_TimeInterval(time)(e) in (if (((x.val) = <err>) or (t = <err>))then mk_EST_value(<err>, (ps.sto), zerot)elseif timeleq((x.time), t)then mu(x, time |-> tplus((ps.time), (x.time)))else mk_EST_value(<err>, (ps.sto), zerot))eval_TimeInterval' ((unresolved DEFAULT`TimeInterval) -> ((unresolved DEFAULT`Env) -> (((unresolved DEFAULT`Errvalue) | (unresolved DEFAULT`Time)))))	eval_TimeInterval(time)(e) ==let range = eval_Range(time)(e) in (if ((range = <err>) or (min(range) < 0))then <err>else mk_(min(range), max(range)))eval_TimeAssertion' ((unresolved DEFAULT`TimeAssertion) -> ((unresolved DEFAULT`Env) -> ((unresolved DEFAULT`PState) -> (unresolved DEFAULT`EST_value))))	eval_TimeAssertion(mk_(unresolved DEFAULT`TimeAssertion)(expr, time))(e)(ps) ==let x = eval_Expression(expr)(e)(mu(ps, time |-> zerot)), t = eval_TimeInterval(time)(e) in (if (((x.val) = <err>) or (t = <err>))then mk_EST_value(<err>, (ps.sto), zerot)elseif timeleq(t, (x.time))then mu(x, time |-> tplus((ps.time), t))else mk_EST_value(<err>, (ps.sto), zerot))Iterate' ((((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))) * nat -> (((unresolved DEFAULT`EST_value) -> (unresolved DEFAULT`EST_value))))	Iterate(f, n) ==(if (n = 0)then (lambda [x'(unresolved DEFAULT`EST_value)] & x)elseif (n = 1)then felse (f comp Iterate(f, (n - 1))))NIterate' ((((unresolved DEFAULT`EST_Iterate) -> (unresolved DEFAULT`EST_Iterate))) * nat -> (((unresolved DEFAULT`EST_Iterate) -> (unresolved DEFAULT`EST_Iterate))))	NIterate(f, n) ==(if (n = 0)then (lambda [x'(unresolved DEFAULT`EST_Iterate)] & x)elseif (n = 1)then felse (f comp NIterate(f, (n - 1))))end DEFAULT
