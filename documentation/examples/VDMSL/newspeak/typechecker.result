WARNING:newspeak.vdmsl:5000:2742,27:Definition 'actions' not used.
WARNING:newspeak.vdmsl:5000:1727,27:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5000:2708,58:Definition 'i1' not used.
WARNING:newspeak.vdmsl:5008:770,38:range at 766'12 hidden by range.
WARNING:newspeak.vdmsl:5008:2521,34:relerr at 925'1 hidden by relerr.
WARNING:newspeak.vdmsl:5000:2030,24:Definition 'p' not used.
WARNING:newspeak.vdmsl:5000:1372,23:Definition 'i' not used.
WARNING:newspeak.vdmsl:5000:2844,26:Definition 'm' not used.
WARNING:newspeak.vdmsl:5000:1728,25:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5000:2067,18:Definition 'id' not used.
WARNING:newspeak.vdmsl:5008:1155,15:lub at 1099'1 hidden by lub.
WARNING:newspeak.vdmsl:5008:2012,24:fl at 1999'37 hidden by fl.
WARNING:newspeak.vdmsl:5000:2062,21:Definition 'id' not used.
WARNING:newspeak.vdmsl:5000:1915,19:Definition 'id' not used.
WARNING:newspeak.vdmsl:5008:814,38:range at 809'12 hidden by range.
WARNING:newspeak.vdmsl:5012:1014,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2175,19:Definition 'rs' not used.
WARNING:newspeak.vdmsl:5000:1089,18:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5000:2734,47:Definition 'id' not used.
WARNING:newspeak.vdmsl:5000:2065,18:Definition 'id' not used.
WARNING:newspeak.vdmsl:5000:1403,27:Definition 'o' not used.
WARNING:newspeak.vdmsl:5000:2577,43:Definition 'skel' not used.
WARNING:newspeak.vdmsl:5008:2512,34:abserr at 920'1 hidden by abserr.
WARNING:newspeak.vdmsl:5008:772,38:range at 766'12 hidden by range.
WARNING:newspeak.vdmsl:5000:1334,15:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2467,19:Definition 's' not used.
WARNING:newspeak.vdmsl:5000:1373,20:Definition 'exp' not used.
WARNING:newspeak.vdmsl:5000:2479,18:Definition 's' not used.
WARNING:newspeak.vdmsl:5012:1312,7:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1349,16:Definition 'l' not used.
WARNING:newspeak.vdmsl:5008:2770,40:inc at 2765'19 hidden by inc.
WARNING:newspeak.vdmsl:5000:2702,57:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:1090,17:Definition 'f' not used.
WARNING:newspeak.vdmsl:5000:1369,18:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2845,25:Definition 'e' not used.
WARNING:newspeak.vdmsl:5000:1730,26:Definition 't' not used.
WARNING:newspeak.vdmsl:5008:2577,43:skel at 2575'29 hidden by skel.
WARNING:newspeak.vdmsl:5000:2508,26:Definition 'rs' not used.
WARNING:newspeak.vdmsl:5000:1692,21:Definition 'c' not used.
WARNING:newspeak.vdmsl:5008:1739,22:l at 1736'27 hidden by l.
WARNING:newspeak.vdmsl:5000:1374,24:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:1373,23:Definition 'tp' not used.
WARNING:newspeak.vdmsl:5000:2063,26:Definition 'expr' not used.
WARNING:newspeak.vdmsl:5012:1162,7:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2064,17:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:1319,16:Definition 'l' not used.
WARNING:newspeak.vdmsl:5012:550,4:Recursive function has no measure.
WARNING:newspeak.vdmsl:5008:1959,49:relerr at 925'1 hidden by relerr.
WARNING:newspeak.vdmsl:5000:2476,14:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2174,22:Definition 'p' not used.
WARNING:newspeak.vdmsl:5012:1755,16:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2578,47:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2744,29:Definition 'actions' not used.
WARNING:newspeak.vdmsl:5000:2479,21:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5012:1862,14:Recursive function has no measure.
WARNING:newspeak.vdmsl:5008:816,38:range at 809'12 hidden by range.
WARNING:newspeak.vdmsl:5000:1372,25:Definition 'o' not used.
WARNING:newspeak.vdmsl:5012:2973,9:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1092,22:Definition 'f' not used.
WARNING:newspeak.vdmsl:5008:790,38:range at 784'7 hidden by range.
WARNING:newspeak.vdmsl:5000:2614,39:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2176,20:Definition 'range' not used.
WARNING:newspeak.vdmsl:5000:1718,21:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5008:850,18:relerr at 925'1 hidden by relerr.
WARNING:newspeak.vdmsl:5000:2176,22:Definition 'r' not used.
WARNING:newspeak.vdmsl:5008:2007,28:fl at 1999'37 hidden by fl.
WARNING:newspeak.vdmsl:5000:2481,19:Definition 's' not used.
WARNING:newspeak.vdmsl:5000:1977,11:Definition 'e' not used.
WARNING:newspeak.vdmsl:5000:2468,23:Definition 'id' not used.
WARNING:newspeak.vdmsl:5000:1914,19:Definition 'tps' not used.
WARNING:newspeak.vdmsl:5008:2214,39:abserr at 920'1 hidden by abserr.
WARNING:newspeak.vdmsl:5000:2067,23:Definition 'type' not used.
WARNING:newspeak.vdmsl:5000:2066,19:Definition 'nls' not used.
WARNING:newspeak.vdmsl:5008:502,33:tp at 496'12 hidden by tp.
WARNING:newspeak.vdmsl:5000:1729,25:Definition 'i' not used.
WARNING:newspeak.vdmsl:5000:1095,27:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5008:2009,36:fl at 1999'37 hidden by fl.
WARNING:newspeak.vdmsl:5000:1913,24:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5000:2844,28:Definition 'e' not used.
WARNING:newspeak.vdmsl:5000:1352,17:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2708,62:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2598,39:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:1337,16:Definition 'l' not used.
WARNING:newspeak.vdmsl:5012:1170,7:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1693,22:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2804,39:Definition 'v' not used.
WARNING:newspeak.vdmsl:5008:2008,32:fl at 1999'37 hidden by fl.
WARNING:newspeak.vdmsl:5000:1322,19:Definition 'l' not used.
WARNING:newspeak.vdmsl:5008:2011,28:fl at 1999'37 hidden by fl.
WARNING:newspeak.vdmsl:5000:1371,14:Definition 's' not used.
WARNING:newspeak.vdmsl:5012:1025,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1381,30:Definition 'r' not used.
WARNING:newspeak.vdmsl:5000:2597,32:Definition 's' not used.
WARNING:newspeak.vdmsl:5008:836,18:relerr at 925'1 hidden by relerr.
WARNING:newspeak.vdmsl:5012:2646,13:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2699,41:Definition 'v' not used.
WARNING:newspeak.vdmsl:5000:1911,25:Definition 'tpe' not used.
WARNING:newspeak.vdmsl:5000:2845,23:Definition 'd' not used.
WARNING:newspeak.vdmsl:5000:1325,18:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:1693,20:Definition 'exp' not used.
WARNING:newspeak.vdmsl:5000:2478,19:Definition 's' not used.
WARNING:newspeak.vdmsl:5008:1959,42:abserr at 920'1 hidden by abserr.
WARNING:newspeak.vdmsl:5000:1669,39:Definition 'op' not used.
WARNING:newspeak.vdmsl:5000:2415,23:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2502,35:Definition 'range' not used.
WARNING:newspeak.vdmsl:5000:1728,22:Definition 'n' not used.
WARNING:newspeak.vdmsl:5012:984,15:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2480,17:Definition 's' not used.
WARNING:newspeak.vdmsl:5000:1913,28:Definition 'tpe' not used.
WARNING:newspeak.vdmsl:5000:2462,22:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:1381,28:Definition 'bo' not used.
WARNING:newspeak.vdmsl:5008:750,38:range at 746'12 hidden by range.
WARNING:newspeak.vdmsl:5012:2435,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5008:2214,46:relerr at 925'1 hidden by relerr.
WARNING:newspeak.vdmsl:5012:1886,10:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2830,51:Definition 'i' not used.
WARNING:newspeak.vdmsl:5000:2065,23:Definition 'expr' not used.
WARNING:newspeak.vdmsl:5008:835,18:abserr at 920'1 hidden by abserr.
WARNING:newspeak.vdmsl:5000:2177,19:Definition 'rs' not used.
WARNING:newspeak.vdmsl:5000:2734,51:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2468,26:Definition 'tp' not used.
WARNING:newspeak.vdmsl:5008:2009,33:tp at 1999'40 hidden by tp.
WARNING:newspeak.vdmsl:5000:1325,20:Definition 'm' not used.
WARNING:newspeak.vdmsl:5000:2062,24:Definition 'tp' not used.
WARNING:newspeak.vdmsl:5000:2029,23:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:1340,15:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:1331,18:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2613,32:Definition 's' not used.
WARNING:newspeak.vdmsl:5000:2844,24:Definition 'd' not used.
WARNING:newspeak.vdmsl:5000:1585,17:Definition 'opr' not used.
WARNING:newspeak.vdmsl:5000:2178,24:Definition 'r' not used.
WARNING:newspeak.vdmsl:5000:2422,55:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2063,21:Definition 'id' not used.
WARNING:newspeak.vdmsl:5000:1730,24:Definition 'n' not used.
WARNING:newspeak.vdmsl:5000:2843,22:Definition 'd' not used.
WARNING:newspeak.vdmsl:5012:2964,8:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1346,19:Definition 'l' not used.
WARNING:newspeak.vdmsl:5012:2306,25:Recursive function has no measure.
WARNING:newspeak.vdmsl:5012:1057,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2744,21:Definition 'time' not used.
WARNING:newspeak.vdmsl:5008:849,18:abserr at 920'1 hidden by abserr.
WARNING:newspeak.vdmsl:5000:1730,28:Definition 'i' not used.
WARNING:newspeak.vdmsl:5000:2843,24:Definition 'e' not used.
WARNING:newspeak.vdmsl:5000:1727,24:Definition 'n' not used.
WARNING:newspeak.vdmsl:5000:2066,22:Definition 'ph' not used.
WARNING:newspeak.vdmsl:5000:1381,25:Definition 'l' not used.
WARNING:newspeak.vdmsl:5008:2476,14:t at 2474'42 hidden by t.
WARNING:newspeak.vdmsl:5008:819,35:range at 809'12 hidden by range.
WARNING:newspeak.vdmsl:5000:1343,15:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2417,45:Definition 'v' not used.
WARNING:newspeak.vdmsl:5000:2832,45:Definition 'i' not used.
WARNING:newspeak.vdmsl:5000:1263,22:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2743,27:Definition 'actions' not used.
WARNING:newspeak.vdmsl:5012:1251,13:Recursive function has no measure.
WARNING:newspeak.vdmsl:5012:973,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2568,30:Definition 'tp' not used.
WARNING:newspeak.vdmsl:5000:1911,21:Definition 'range' not used.
WARNING:newspeak.vdmsl:5000:1910,23:Definition 'p' not used.
WARNING:newspeak.vdmsl:5000:2742,19:Definition 'inc' not used.
WARNING:newspeak.vdmsl:5012:996,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1912,21:Definition 'tps' not used.
WARNING:newspeak.vdmsl:5008:752,38:range at 746'12 hidden by range.
WARNING:newspeak.vdmsl:5000:2430,33:Definition 'mt' not used.
WARNING:newspeak.vdmsl:5008:2029,23:l at 2026'38 hidden by l.
WARNING:newspeak.vdmsl:5000:1694,19:Definition 'l' not used.
WARNING:newspeak.vdmsl:5012:2051,11:Recursive function has no measure.
WARNING:newspeak.vdmsl:5012:1196,3:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2178,22:Definition 'f' not used.
WARNING:newspeak.vdmsl:5008:788,38:range at 784'7 hidden by range.
WARNING:newspeak.vdmsl:5000:2804,37:Definition 'id' not used.
WARNING:newspeak.vdmsl:5008:2006,23:fl at 1999'37 hidden by fl.
WARNING:newspeak.vdmsl:5000:2477,17:Definition 'r' not used.
WARNING:newspeak.vdmsl:5000:2809,35:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2743,19:Definition 'ovs' not used.
WARNING:newspeak.vdmsl:5000:1091,21:Definition 'f' not used.
WARNING:newspeak.vdmsl:5012:1274,17:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:1380,23:Definition 'mo' not used.
WARNING:newspeak.vdmsl:5000:2699,39:Definition 'id' not used.
WARNING:newspeak.vdmsl:5012:558,4:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2477,20:Definition 'er' not used.
WARNING:newspeak.vdmsl:5000:1370,19:Definition 'a' not used.
WARNING:newspeak.vdmsl:5000:1372,21:Definition 'd' not used.
WARNING:newspeak.vdmsl:5012:1005,12:Recursive function has no measure.
WARNING:newspeak.vdmsl:5000:2428,50:Definition 'v' not used.
WARNING:newspeak.vdmsl:5000:2613,34:Definition 'f' not used.
WARNING:newspeak.vdmsl:5000:1093,25:Definition 'f' not used.
WARNING:newspeak.vdmsl:5000:1729,23:Definition 'n' not used.
WARNING:newspeak.vdmsl:5000:693,8:Definition 'c' not used.
WARNING:newspeak.vdmsl:5000:1368,19:Definition 'op' not used.
WARNING:newspeak.vdmsl:5000:2497,30:Definition 'range' not used.
WARNING:newspeak.vdmsl:5000:2833,50:Definition 'i' not used.
WARNING:newspeak.vdmsl:5000:2468,29:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5000:2597,34:Definition 'f' not used.
WARNING:newspeak.vdmsl:5000:1094,23:Definition 'fl' not used.
WARNING:newspeak.vdmsl:5000:2614,37:Definition 'f' not used.
WARNING:newspeak.vdmsl:5000:2066,27:Definition 'expr' not used.
WARNING:newspeak.vdmsl:5000:1328,14:Definition 'l' not used.
WARNING:newspeak.vdmsl:5000:2411,31:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2598,37:Definition 'f' not used.
WARNING:newspeak.vdmsl:5000:2179,14:Definition 't' not used.
WARNING:newspeak.vdmsl:5000:2029,44:Definition 'v' not used.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private beta'nat1 = 2static private epsilon_r'real = 1static private epsilon_t'real = 1static private bytemax'int = 10000static private maxint'int = 100000static private Phi'Fl_elt = mk_Fl_elt(<phi>, 1)static private zerot'Time = mk_(0, 0)static private t_absreal'Time = mk_(1, 1)static private t_absint'Time = mk_(1, 1)static private t_realmonminus'Time = mk_(1, 1)static private t_intmonminus'Time = mk_(1, 1)static private t_not'Time = mk_(1, 1)static private t_discard'Time = mk_(1, 1)static private t_round'Time = mk_(1, 1)static private t_mantissa'Time = mk_(1, 1)static private t_exponent'Time = mk_(1, 1)static private t_odd'Time = mk_(1, 1)static private t_float'Time = mk_(1, 1)static private t_min'Time = mk_(1, 1)static private t_max'Time = mk_(1, 1)static private t_intbinop'Time = mk_(1, 1)static private t_realbinop'Time = mk_(1, 1)static private t_intcomp'Time = mk_(1, 1)static private t_realcomp'Time = mk_(1, 1)static private t_tr_eq'Time = mk_(1, 1)static private t_real_eq'Time = mk_(1, 1)static private t_int_eq'Time = mk_(1, 1)static private t_void_eq'Time = mk_(1, 1)static private t_and'Time = mk_(1, 1)static private t_skip'Time = mk_(1, 1)static private t_access'Time = mk_(1, 1)static private t_comp_extract'Time = mk_(1, 1)static private t_update'Time = mk_(1, 1)static private t_construct_ev'Time = mk_(1, 1)static private t_const_type'Time = mk_(1, 1)static private t_widen_type'Time = mk_(1, 1)static private t_if'Time = mk_(1, 1)static private Errvalue = <err>static private Id = tokenstatic private Flavdom = set of (Fl_elt)static private Fl_elt = compose Fl_elt of label'(<phi> | token), dim'rat endstatic private Tr = compose Tr of val'bool, type'TrType endstatic private TrType = compose TrType of range'set of (bool), fl'Flavdom endstatic private EqOp = (<EQ> | <NEQ>)static private Int = compose Int of val'int, type'IntType endstatic private IntType = compose IntType of rep'(<byte> | <word>), range'set of (int), fl'Flavdom endstatic private NumOp = compose NumOp of 1'(<binaryminus> | <numdiv> | <nummax> | <nummin> | <nummod> | <nummult> | <numplus>) endstatic private CompOp = (<numge> | <numgt> | <numle> | <numlt>)static private Real = compose Real of val'real, type'Float endstatic private Floatrng = compose Floatrng of lower'int, upper'int endstatic private Float = compose Float of range'set of (Floatrng), abserr'real, relerr'real, fl'Flavdom endstatic private Void = compose Void of val'<nil>, type'VoidType endstatic private VoidType = compose VoidType of 1'Flavdom endstatic private Structure = compose Structure of val'StructValue, type'StructureType endstatic private StructValue = seq1 of (Component)static private Component = (bool | real)static private StructureType = compose StructureType of tps'seq1 of (CompType), fl'Flavdom endstatic private CompType = (Float | IntType | TrType)static private Vector = compose Vector of val'VectorValue, type'VectorType endstatic private VectorValue = (seq1 of (Errvalue) | seq1 of (Int) | seq1 of (Real) | seq1 of (StructValue) | seq1 of (Tr) | seq1 of (VectorValue) | seq1 of (Void))static private VectorType = compose VectorType of lower'int, upper'int, type'Expressible_type, fl'Flavdom endstatic private Union = compose Union of val'UnionValue, type'UnionType endstatic private UnionValue = (Int | Real | Tr | Void)static private UnionType = compose UnionType of tps'set of ((Float | IntType | TrType | VoidType)), fl'Flavdom endstatic private Expressible_type = (Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)static private Location = compose Location of 1'nat endstatic private Expressible_value = (Errvalue | Int | Real | Structure | Tr | Union | Vector | Void)static private Storable_value = compose Storable_value of 1'(Int | Real | Structure | Tr | Union | Vector | Void) endstatic private Store = map (Location) to (Storable_value)static private Time = (nat * nat)static private PState = compose PState of sto'Store, time'Time endstatic private Denotable_value = (Errvalue | Expressible_type | Location | Proc | Storable_value)static private Env = (map (Id) to (Denotable_value) * Location)static private EnvState = ((Env * PState) | Errvalue)static private EST_value = compose EST_value of val'Expressible_value, sto'Store, time'Time endstatic private EST_Iterate = compose EST_Iterate of expst'EST_value, i'int endstatic private Param = seq of (Expressible_value)static private Proc = compose Proc of 1'(Param -> (PState -> EST_value)) endstatic private Formal_elt = compose Formal_elt of id'Id, rep'Expressible_type, fl'Flavdom endstatic private Program = compose Program of 1'Expression endstatic private Expression = compose Expression of 1'(Assertion | Assignment | GuardedScope | InnerLoop | Operation | Scope | TimedExpression) endstatic private Operation = compose Operation of 1'(BinaryOperation | MonOperation) endstatic private MonOperation = compose MonOperation of 1'(MonOpMonOperand | Value | VectorOperation) endstatic private MonOpMonOperand = compose MonOpMonOperand of operator'MonOp, operand'MonOperation endstatic private MonOp = (<discard> | <exponent> | <float> | <mantissa> | <not> | <numabs> | <odd> | <round> | <unaryminus> | CompileTimeOp)static private CompileTimeOp = compose CompileTimeOp of 1'(<abserr> | <absonly> | <inf> | <relerr> | <relonly> | <sup>) endstatic private VectorOperation = compose VectorOperation of vo'VectorOp, mo'MonOperation, mult'[Multiple] endstatic private VectorOp = (<all> | <flatten> | <product> | <some> | <sum> | <vecmax> | <vecmin>)static private Multiple = compose Multiple of op'Operation, to_p'ToPart endstatic private ToPart = (Downto | Upto)static private Upto = Operationstatic private Downto = Operationstatic private BinaryOperation = compose BinaryOperation of left'MonOperation, opr'BinaryOp, right'MonOperation endstatic private BinaryOp = compose BinaryOp of 1'(<replaceflav> | BoolOp | CompOp | EqOp | NumOp | VecBinOp) endstatic private BoolOp = (<and> | <or>)static private VecBinOp = <concat>static private Value = compose Value of 1'(Call | Conditional | ConstantValue | NamedValue | OuterLoop | Sequence | StructureValue | VectorVal | Widening) endstatic private ConstantValue = compose ConstantValue of 1'(<skip> | Ascii_Char | Ascii_string | BooleanDenotation | Flavouring | FloatingDenotation | IntegerDenotation) endstatic private IntegerDenotation = compose IntegerDenotation of 1'int endstatic private FloatingDenotation = compose FloatingDenotation of 1'real endstatic private BooleanDenotation = compose BooleanDenotation of 1'bool endstatic private Ascii_Char = compose Ascii_Char of 1'char endstatic private Ascii_string = compose Ascii_string of 1'seq1 of (char) endstatic private NamedValue = compose NamedValue of 1'(FlavourExtract | FlavourStrip | Id | VectorExtract | VectorTrimming) endstatic private FlavourExtract = compose FlavourExtract of nv'NamedValue, fl'Flavouring endstatic private Flavouring = compose Flavouring of 1'seq of (Flavour) endstatic private Flavour = compose Flavour of name'token, index'[rat] endstatic private FlavourStrip = compose FlavourStrip of nv'NamedValue, fl'Flavouring endstatic private VectorExtract = compose VectorExtract of named'NamedValue, index'Operation endstatic private VectorTrimming = compose VectorTrimming of named'NamedValue, to_p'(<atvalue> | <gtvalue> | <ltvalue>), ctv'CompileTimeValue endstatic private CompileTimeValue = compose CompileTimeValue of 1'Operation endstatic private VectorVal = compose VectorVal of 1'seq1 of (Operation) endstatic private Sequence = compose Sequence of 1'seq1 of (Expression) endstatic private Call = compose Call of id'Id, acts'seq of (Operation) endstatic private StructureValue = compose StructureValue of 1'seq1 of (Operation) endstatic private Widening = compose Widening of expr'Expression, tp'Type endstatic private Type = compose Type of 1'(FlavouredType | PrimitiveType | StrucType | TypeName | UnionTp | VecType) endstatic private PrimitiveType = compose PrimitiveType of 1'(FloatType | Number | VoidValType) endstatic private Number = compose Number of rep'(<bit> | <byte> | <word>), range'seq of (Range) endstatic private Range = compose Range of lower'[CompileTimeValue], upper'[CompileTimeValue] endstatic private FloatType = compose FloatType of range'seq of (Range), abserr'[CompileTimeValue], relerr'[CompileTimeValue] endstatic private VoidValType = Flavouringstatic private VecType = compose VecType of range'Range, tp'Type endstatic private StrucType = compose StrucType of 1'seq1 of (Type) endstatic private FlavouredType = compose FlavouredType of fl'Flavouring, tp'Type endstatic private UnionTp = compose UnionTp of 1'seq1 of (Type) endstatic private TypeName = compose TypeName of 1'Id endstatic private Conditional = compose Conditional of 1'(CaseExpr | IfThenElse | IfThenOnly) endstatic private IfThenOnly = compose IfThenOnly of prop'Expression, action'Sequence endstatic private IfThenElse = compose IfThenElse of prop'Expression, thenaction'Sequence, elseaction'Sequence endstatic private CaseExpr = compose CaseExpr of expr'Expression, limbs'seq1 of (CaseLimb), out'[Outlimb] endstatic private CaseLimb = compose CaseLimb of test'Tester, sequ'Sequence endstatic private Tester = (NonStrucTest | SkeletonType | StrucTest)static private SkeletonType = compose SkeletonType of 1'(FlavSkel | NumSkel | StrucSkel | Type | UnionSkel | VecSkel) endstatic private NumSkel = compose NumSkel of ranges'[seq1 of (Range)], errors'[Errors] endstatic private Errors = compose Errors of abserr'[CompileTimeValue], relerr'[CompileTimeValue] endstatic private StrucSkel = compose StrucSkel of 1'seq1 of ((<nil> | SkeletonType)) endstatic private FlavSkel = compose FlavSkel of skel'SkeletonType, fl'Flavouring endstatic private VecSkel = compose VecSkel of 1'SkeletonType endstatic private UnionSkel = compose UnionSkel of 1'seq1 of ((FlavSkel | FlavouredType | VoidValType)) endstatic private StrucTest = compose StrucTest of 1'seq1 of ((<nil> | NonStrucTest)) endstatic private NonStrucTest = compose NonStrucTest of id'[Id], fl'[Flavouring], tp'SkeletonType endstatic private Outlimb = Sequencestatic private OuterLoop = compose OuterLoop of 1'(OuterIntLoop | OuterVecLoop) endstatic private OuterIntLoop = compose OuterIntLoop of ovr'OverRange, actions'Sequence endstatic private OverRange = compose OverRange of cnt'LoopId, range'Range endstatic private LoopId = Idstatic private OuterVecLoop = compose OuterVecLoop of ovs'OverVectors, action'Sequence endstatic private OverVectors = compose OverVectors of cnt'[LoopId], ovv'seq1 of (OverVector) endstatic private OverVector = compose OverVector of id'Id, val'Operation endstatic private InnerLoop = compose InnerLoop of 1'(IntLoop | TimeLoop | VecLoop) endstatic private IntLoop = compose IntLoop of inc'InnerControl, actions'Sequence endstatic private InnerControl = (OverRange | PartialRange)static private PartialRange = compose PartialRange of cnt'LoopId, from_p'Operation, to_p'ToPart, inc'[Operation] endstatic private VecLoop = compose VecLoop of ovs'OverVectors, actions'Sequence endstatic private TimeLoop = compose TimeLoop of time'TimeInterval, actions'Sequence endstatic private TimeInterval = Rangestatic private Assignment = compose Assignment of 1'(MultAssignment | NvAssignment | StrAssignment) endstatic private NvAssignment = compose NvAssignment of dest'Id, expr'Expression endstatic private MultAssignment = compose MultAssignment of dest'Id, mult'Multiple, expr'Expression endstatic private StrAssignment = compose StrAssignment of dest'seq1 of (Id), expr'Expression endstatic private Scope = compose Scope of 1'(PackageScope | SimpleScope) endstatic private SimpleScope = compose SimpleScope of decls'seq1 of (Declaration), expr'Expression endstatic private Declaration = (ExportDecl | ImportDecl | LetDecl | ProcDec | TypeDec | VarDecl)static private ImportDecl = compose ImportDecl of id'Id, tp'Type endstatic private ExportDecl = compose ExportDecl of id'Id, expr'Expression endstatic private LetDecl = compose LetDecl of 1'(SimpleLetDecl | StrucLetDecl) endstatic private SimpleLetDecl = compose SimpleLetDecl of id'Id, expr'Expression endstatic private StrucLetDecl = compose StrucLetDecl of ids'seq1 of (Id), expr'Expression endstatic private VarDecl = compose VarDecl of id'Id, expr'Expression endstatic private ProcDec = compose ProcDec of nls'[NonLocals], ph'ProcHeading, expr'Expression endstatic private NonLocals = compose NonLocals of ids'[seq1 of (Id)], decls'[seq1 of (Declaration)] endstatic private ProcHeading = compose ProcHeading of id'Id, formals'seq of (Formal) endstatic private Formal = compose Formal of id'Id, rep'Representation, fl'Flavouring endstatic private Representation = (FlavouredRep | PrimitiveRep | StrucRep | Type | UnionRep | VecRep)static private PrimitiveRep = compose PrimitiveRep of 1'(FloatRep | NumRep) endstatic private NumRep = compose NumRep of rep'(<bit> | <byte> | <word>), rnage'[seq1 of (Range)] endstatic private FloatRep = compose FloatRep of range'[seq1 of (Range)], abserr'[CompileTimeValue], relerr'[CompileTimeValue] endstatic private StrucRep = compose StrucRep of 1'seq1 of (Representation) endstatic private VecRep = compose VecRep of range'Range, rep'Representation endstatic private UnionRep = compose UnionRep of 1'seq1 of (Representation) endstatic private FlavouredRep = compose FlavouredRep of fl'Flavouring, rep'Representation endstatic private TypeDec = compose TypeDec of id'Id, tp'Type endstatic private PackageScope = compose PackageScope of ids'seq1 of (Id), decls'seq1 of (Declaration), expr'Expression endstatic private GuardedScope = compose GuardedScope of decls'seq1 of (GuardedDeclaration), inseq'Sequence, out'Sequence endstatic private GuardedDeclaration = (Declaration | WhereDecl)static private WhereDecl = compose WhereDecl of type'SkeletonType, expr'Expression, id'[Id] endstatic private Assertion = compose Assertion of expr'Expression, tp'SkeletonType endstatic private TimedExpression = compose TimedExpression of 1'(TimeAssertion | TimeTakes) endstatic private TimeTakes = compose TimeTakes of expr'Expression, time'TimeInterval endstatic private TimeAssertion = compose TimeAssertion of expr'Expression, time'TimeInterval endfl_mult' (Flavdom * Flavdom -> Flavdom)	fl_mult(f1, f2) ==(if (Phi in set (f1 union f2))then {Phi}else (({mk_Fl_elt((f.label), ((f.dim) + (f'.dim))) | [f in set f1, f' in set f2] & ((f.label) = (f'.label))} union {f | [f in set f1] & (forall f' in set f2 & ((f'.label) <> (f.label)))}) union {f | [f in set f2] & (forall f' in set f1 & ((f'.label) <> (f.label)))}))fl_div' (Flavdom * Flavdom -> Flavdom)	fl_div(f1, f2) ==(if (Phi in set (f1 union f2))then {Phi}else (({mk_Fl_elt((f.label), ((f.dim) - (f'.dim))) | [f in set f1, f' in set f2] & ((f.label) = (f'.label))} union {f | [f in set f1] & (forall f' in set f2 & ((f'.label) <> (f.label)))}) union {mk_Fl_elt((f.label), -(f.dim)) | [f in set f2] & (forall f' in set f1 & ((f'.label) <> (f.label)))}))phi_remove' (Expressible_type -> Expressible_type)	phi_remove(tp) ==(cases tp 'case mk_VoidType(t) -> mk_VoidType((t \ {Phi})),case mk_TrType(range, fl) -> mk_TrType(range, (fl \ {Phi})),case mk_IntType(rep, range, fl) -> mk_IntType(rep, range, (fl \ {Phi})),case mk_Float(range, abse, rele, fl) -> mk_Float(range, abse, rele, (fl \ {Phi})),case mk_VectorType(lower, upper, tp, fl) -> mk_VectorType(lower, upper, tp, (fl \ {Phi})),case mk_StructureType(tps, fl) -> mk_StructureType(tps, (fl \ {Phi})),case mk_UnionType(tps, fl) -> mk_UnionType(tps, (fl \ {Phi}))end)tr_eq' (Tr * Tr * EqOp -> Expressible_value)	tr_eq(t1, t2, op) ==(if (((t1.type).fl) <> ((t2.type).fl))then <err>elseif (op = <EQ>)then mk_Tr(((t1.val) = (t2.val)), mk_TrType({(b1 = b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, {}))else mk_Tr(((t1.val) <> (t2.val)), mk_TrType({(b1 <> b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, {})))tr_and' (Tr * Tr -> Expressible_value)	tr_and(t1, t2) ==(if (((t1.type).fl) <> ((t2.type).fl))then <err>else mk_Tr(((t1.val) and (t2.val)), mk_TrType({(b1 and b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, ((t1.type).fl))))tr_or' (Tr * Tr -> Expressible_value)	tr_or(t1, t2) ==(if (((t1.type).fl) <> ((t2.type).fl))then <err>else mk_Tr(((t1.val) or (t2.val)), mk_TrType({(b1 or b2) | [b1 in set ((t1.type).range), b2 in set ((t2.type).range)]}, ((t1.type).fl))))tr_not' (Tr -> Expressible_value)	tr_not(t) ==mk_Tr((not (t.val)), mk_TrType({(not b) | [b in set ((t.type).range)]}, ((t.type).fl)))int_eq' (Int * Int * EqOp -> Expressible_value)	int_eq(z1, z2, op) ==(if (((z1.type).fl) <> ((z2.type).fl))then <err>elseif (op = <EQ>)then mk_Tr(((z1.val) = (z2.val)), mk_TrType({(i = j) | [i in set ((z1.type).range), j in set ((z2.type).range)]}, {}))else mk_Tr(((z1.val) <> (z2.val)), mk_TrType({(i <> j) | [i in set ((z1.type).range), j in set ((z2.type).range)]}, {})))min' (set of (real) -> real)	min(s) ==let m in set s in (if ((card s) = 1)then melse let sm'real = min((s \ {m})) in (if (m < sm)then melse sm))	pre (s <> {})max' (set of (real) -> real)	max(s) ==let m in set s in (if ((card s) = 1)then melse let sm'real = max((s \ {m})) in (if (m > sm)then melse sm))	pre (s <> {})intbinop' (Int * Int * NumOp -> Expressible_value)	intbinop(x, y, mk_NumOp(op)) ==(cases op 'case (<numplus>) -> intplus(x, y),case (<binaryminus>) -> intbinminus(x, y),case (<nummult>) -> intmult(x, y),case (<numdiv>) -> intdiv(x, y),case (<nummod>) -> intmod(x, y),case (<nummax>) -> intmax(x, y),case (<nummin>) -> intmin(x, y)end)intplus' (Int * Int -> Expressible_value)	intplus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range'set of (int) = {(i + j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep'(<byte> | <word>) = (if ((min({(abs min(range)), (abs max(range))}) >= bytemax) or ((((x.type).rep) = <word>) or (((y.type).rep) = <word>)))then <word>else <byte>) in mk_Int(((x.val) + (y.val)), mk_IntType(rep, range, ((x.type).fl)))))intbinminus' (Int * Int -> Expressible_value)	intbinminus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range'set of (int) = {(i - j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep'(<byte> | <word>) = (if ((min({(abs min(range)), (abs max(range))}) >= bytemax) or ((((x.type).rep) = <word>) or (((y.type).rep) = <word>)))then <word>else <byte>) in mk_Int(((x.val) - (y.val)), mk_IntType(rep, range, ((x.type).fl)))))intmult' (Int * Int -> Expressible_value)	intmult(x, y) ==let fl'Flavdom = fl_mult(((x.type).fl), ((y.type).fl)), range'set of (int) = {(i * j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep'(<byte> | <word>) = (if ((min({(abs min(range)), (abs max(range))}) >= bytemax) or ((((x.type).rep) = <word>) or (((y.type).rep) = <word>)))then <word>else <byte>) in mk_Int(((x.val) * (y.val)), mk_IntType(rep, range, fl)))intdiv' (Int * Int -> Expressible_value)	intdiv(x, y) ==(if (0 in set ((y.type).range))then <err>else let fl'Flavdom = fl_div(((x.type).fl), ((y.type).fl)), range'set of (int) = {(i div j) | [i in set ((x.type).range), j in set ((y.type).range)]} in (if (max({(abs min(range)), (abs max(range))}) >= maxint)then <err>else let rep'(<byte> | <word>) = (if (exists [r in set range] & ((abs r) >= bytemax))then <word>else <byte>) in mk_Int(((x.val) div (y.val)), mk_IntType(rep, range, fl))))intmod' (Int * Int -> Expressible_value)	intmod(x, y) ==(if (0 in set ((y.type).range))then <err>else let range'set of (nat) = {(i mod j) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Int(((x.val) mod (y.val)), mk_IntType(((y.type).rep), range, ((x.type).fl))))intmax' (Int * Int -> Expressible_value)	intmax(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let rep'(<byte> | <word>) = (if ((((x.type).rep) = <word>) or (((y.type).rep) = <word>))then <word>else <byte>), range'set of (real) = {max({i, j}) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Int(max({(x.val), (y.val)}), mk_IntType(rep, range, ((x.type).fl))))intmin' (Int * Int -> Expressible_value)	intmin(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let rep'(<byte> | <word>) = (if ((((x.type).rep) = <word>) or (((y.type).rep) = <word>))then <word>else <byte>), range'set of (real) = {min({i, j}) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Int(min({(x.val), (y.val)}), mk_IntType(rep, range, ((x.type).fl))))absint' (Int -> Int)	absint(z) ==mk_Int((abs (z.val)), mk_IntType(((z.type).rep), {(abs i) | [i in set ((z.type).range)]}, ((z.type).fl)))intmonminus' (Int -> Int)	intmonminus(z) ==mk_Int(-(z.val), mk_IntType(((z.type).rep), {-i | [i in set ((z.type).range)]}, ((z.type).fl)))odd' (Int -> Tr)	odd(z) ==let range'set of (bool) = {((x mod 2) = 0) | [x in set ((z.type).range)]} in mk_Tr((((z.val) mod 2) = 0), mk_TrType(range, {}))intcomp' (Int * Int * CompOp -> Expressible_value)	intcomp(x, y, op) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let p'((int * int) -> bool) = (lambda [mk_(i, j)'(int * int)] & (cases op 'case <numgt> -> (i > j),case <numlt> -> (i < j),case <numge> -> (i >= j),case <numle> -> (i <= j)end)) in let val'bool = p(mk_((x.val), (y.val))), range'set of (bool) = {p(mk_(i, j)) | [i in set ((x.type).range), j in set ((y.type).range)]} in mk_Tr(val, mk_TrType(range, {})))ascii' (char -> int)	ascii(c) ==1float' (Int -> Real)	float(z) ==mk_Real((z.val), mk_Float({mk_Floatrng(min(((z.type).range)), max(((z.type).range)))}, maxint, maxint, {}))real_eq' (Real * Real * EqOp -> Expressible_value)	real_eq(r, s, op) ==(if (((r.type).fl) <> ((s.type).fl))then <err>else let r1'set of (int) = (dunion {{(floor (((1 - ((r.type).relerr)) * (range.lower)) - ((r.type).abserr))), ... ,(floor ((0.5 + ((1 + ((r.type).relerr)) * (range.upper))) + ((r.type).abserr)))} | [range in set ((r.type).range)]}), r2'set of (int) = (dunion {{(floor (((1 - ((s.type).relerr)) * (range.lower)) - ((s.type).abserr))), ... ,(floor ((0.5 + ((1 + ((s.type).relerr)) * (range.upper))) + ((s.type).abserr)))} | [range in set ((s.type).range)]}) in let range'set of (bool) = (if ((r1 inter r2) = {})then {false}else {true, false}) in (if (op = <EQ>)then mk_Tr(((r.val) = (s.val)), mk_TrType(range, {}))else mk_Tr(((r.val) <> (s.val)), mk_TrType({(not t) | [t in set range]}, {}))))absreal' (Real -> Real)	absreal(r) ==let new_range'set of (Floatrng) = {mk_Floatrng(min({(abs (range.lower)), (abs (range.upper))}), max({(abs (range.lower)), (abs (range.upper))})) | [range in set ((r.type).range)]} in mk_Real((abs (r.val)), mu((r.type), range |-> new_range))realmonminus' (Real -> Real)	realmonminus(r) ==mk_Real(-(r.val), mu((r.type), range |-> {mk_Floatrng(-(range.upper), -(range.lower)) | [range in set ((r.type).range)]}))realbinop' (Real * Real * NumOp -> Expressible_value)	realbinop(x, y, mk_NumOp(op)) ==(cases op 'case <numplus> -> realplus(x, y),case <binaryminus> -> realbinminus(x, y),case <nummult> -> realmult(x, y),case <numdiv> -> realdiv(x, y),case <nummax> -> realmax(x, y)others <err>end)realplus' (Real * Real -> Expressible_value)	realplus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range'set of (Floatrng) = {mk_Floatrng(((xrange.lower) + (yrange.lower)), ((xrange.upper) + (yrange.upper))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax'real = max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As'real = ((((((x.type).relerr) + ((y.type).abserr)) + (((x.type).relerr) * Xmax)) + (((y.type).relerr) * Ymax)) + (epsilon_t * XYmax)) in let val'real = ((x.val) + (y.val)), type'Float = mk_Float(range, As, epsilon_r, ((x.type).fl)) in mk_Real(val, type)))realbinminus' (Real * Real -> Expressible_value)	realbinminus(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let range'set of (Floatrng) = {mk_Floatrng(((xrange.lower) - (yrange.upper)), ((xrange.upper) - (yrange.lower))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax'real = max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As'real = ((((((x.type).relerr) + ((y.type).abserr)) + (((x.type).relerr) * Xmax)) + (((y.type).relerr) * Ymax)) + (epsilon_t * XYmax)) in let val'real = ((x.val) - (y.val)), type'Float = mk_Float(range, As, epsilon_r, ((x.type).fl)) in mk_Real(val, type)))realmult' (Real * Real -> Expressible_value)	realmult(x, y) ==let range'set of (Floatrng) = {mk_Floatrng(((xrange.lower) * (yrange.lower)), ((xrange.upper) * (yrange.upper))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax'real = max({Xmax, Ymax}) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As'real = ((((((Xmax * Ymax) * (((x.type).relerr) + ((y.type).relerr))) + ((((x.type).abserr) * Ymax) * (1 + ((y.type).relerr)))) + ((((y.type).abserr) * Xmax) * (1 + ((x.type).relerr)))) + (((x.type).abserr) * ((y.type).abserr))) + (epsilon_t * XYmax)), fl'Flavdom = fl_mult(((x.type).fl), ((y.type).fl)) in mk_Real(((x.val) * (y.val)), mk_Float(range, As, epsilon_r, fl)))realdiv' (Real * Real -> Expressible_value)	realdiv(x, y) ==(if (((((1 - ((y.type).relerr)) * min({(range.lower) | [range in set ((y.type).range)]})) - ((y.type).abserr)) <= 0) and ((((1 + ((y.type).relerr)) * max({(range.upper) | [range in set ((y.type).range)]})) + ((y.type).abserr)) >= 0))then <err>else let range'set of (Floatrng) = {mk_Floatrng((floor ((xrange.lower) / (yrange.upper))), (floor (0.5 + ((xrange.upper) / (yrange.lower))))) | [xrange in set ((x.type).range), yrange in set ((y.type).range)]}, Xmax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((x.type).range)]})), Ymax'real = max((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})), XYmax'real = max({Xmax, Ymax}), Ymin'real = min((dunion {{(abs (range.lower)), (abs (range.upper))} | [range in set ((y.type).range)]})) in (if (max({max({(abs (r.lower)), (abs (r.upper))}) | [r in set range]}) >= maxint)then <err>else let As'real = ((((((Xmax * Ymax) * max({((x.type).relerr), ((y.type).relerr)})) + (Ymax * ((x.type).abserr))) + (Xmax * ((y.type).abserr))) / (Ymin ** 2)) + (epsilon_t * XYmax)), fl'Flavdom = fl_div(((x.type).fl), ((y.type).fl)) in mk_Real(((x.val) / (y.val)), mk_Float(range, As, epsilon_r, fl))))realmax' (Real * Real -> Expressible_value)	realmax(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let val'real = max({(x.val), (y.val)}), abserr'real = max({((x.type).abserr), ((y.type).abserr)}), relerr'real = max({((x.type).relerr), ((y.type).relerr)}), range'set of (Floatrng) = {mk_Floatrng(max({(xr.lower), (yr.lower)}), max({(xr.upper), (yr.upper)})) | [xr in set ((x.type).range), yr in set ((y.type).range)]} in mk_Real(val, mk_Float(range, abserr, relerr, ((x.type).fl))))realmin' (Real * Real -> Expressible_value)	realmin(x, y) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let val'real = min({(x.val), (y.val)}), abserr'real = max({((x.type).abserr), ((y.type).abserr)}), relerr'real = max({((x.type).relerr), ((y.type).relerr)}), range'set of (Floatrng) = {mk_Floatrng(min({(xr.lower), (yr.lower)}), min({(xr.upper), (yr.upper)})) | [xr in set ((x.type).range), yr in set ((y.type).range)]} in mk_Real(val, mk_Float(range, abserr, relerr, ((x.type).fl))))discard' (Real -> Int)	discard(r) ==mk_Int((floor ((r.val) + 0.5)), mk_IntType(<word>, (dunion {{(range.lower), ... ,(range.upper)} | [range in set ((r.type).range)]}), {}))round' (Real -> Int)	round(r) ==(if is_((r.val), int)then mk_Int((r.val), mk_IntType(<word>, (dunion {{(range.lower), ... ,(range.upper)} | [range in set ((r.type).range)]}), {}))else mk_Int((floor ((r.val) + 0.5)), mk_IntType(<word>, (dunion {{(range.lower), ... ,(range.upper)} | [range in set ((r.type).range)]}), {})))realcomp' (Real * Real * CompOp -> Expressible_value)	realcomp(x, y, op) ==(if (((x.type).fl) <> ((y.type).fl))then <err>else let p'((real * real) -> bool) = (lambda [mk_(i, j)'(real * real)] & (cases op 'case <numgt> -> (i > j),case <numlt> -> (i < j),case <numle> -> (i <= j),case <numge> -> (i >= j)end)), xrange'set of (int) = (dunion {{(((1 - ((x.type).relerr)) * (range.lower)) - ((x.type).abserr)), ... ,(((1 + ((x.type).relerr)) * (range.upper)) + ((x.type).abserr))} | [range in set ((x.type).range)]}), yrange'set of (int) = (dunion {{(((1 - ((y.type).relerr)) * (range.lower)) - ((y.type).abserr)), ... ,(((1 + ((y.type).relerr)) * (range.upper)) + ((y.type).abserr))} | [range in set ((y.type).range)]}) in let val'bool = p(mk_((x.val), (y.val))), range'set of (bool) = (if (max(xrange) < min(yrange))then {p(mk_(max(xrange), min(yrange)))}elseif (min(xrange) > max(yrange))then {p(mk_(max(yrange), min(xrange)))}else {true, false}) in mk_Tr(val, mk_TrType(range, {})))inf' (Real -> Real)	inf(r) ==let m'real = ((min({(range.lower) | [range in set ((r.type).range)]}) * (1 - ((r.type).relerr))) - ((r.type).abserr)) in mk_Real(m, mk_Float({mk_Floatrng(m, m)}, 0, 0, {Phi}))sup' (Real -> Real)	sup(r) ==let m'real = ((max({(range.upper) | [range in set ((r.type).range)]}) * (1 + ((r.type).relerr))) + ((r.type).abserr)) in mk_Real(m, mk_Float({mk_Floatrng(m, m)}, 0, 0, {Phi}))absonly' (Real -> Real)	absonly(mk_Real(r, f)) ==let abse'real = ((f.abserr) + (r * (f.relerr))) in mk_Real(r, mu(f, abserr |-> abse, relerr |-> 0))relonly' (Real -> Real)	relonly(mk_Real(r, f)) ==(if (r = 0)then mk_Real(r, mu(f, relerr |-> 0, abserr |-> 0))else let rel'real = ((f.relerr) + ((f.abserr) / r)) in mk_Real(r, mu(f, relerr |-> rel, abserr |-> 0)))abserr' (Real -> Real)	abserr(r) ==mk_Real(((r.type).abserr), mk_Float({mk_Floatrng(((r.type).abserr), ((r.type).abserr))}, 0, 0, {Phi}))relerr' (Real -> Real)	relerr(r) ==mk_Real(((r.type).relerr), mk_Float({mk_Floatrng(((r.type).relerr), ((r.type).relerr))}, 0, 0, {Phi}))void_eq' (Void * Void * EqOp -> Expressible_value)	void_eq(v1, v2, op) ==(if (((v1.type) = (v2.type)) and (op = <EQ>))then mk_Tr(true, mk_TrType({true}, {}))elseif (((v1.type) <> (v2.type)) and (op = <NEQ>))then mk_Tr(true, mk_TrType({true}, {}))else mk_Tr(false, mk_TrType({false}, {})))construct_ev' (Component * CompType -> Expressible_value)	construct_ev(v, t) ==(if is_(v, real)then mk_Real(v, t)elseif is_(v, bool)then mk_Tr(v, t)else mk_Int(v, t))comp_extract' (Structure * Flavdom -> Expressible_value)	comp_extract(s, fl) ==let matches'set of (nat1) = {i | [i in set (inds (s.val))] & ((((s.type).tps)(i).fl) = fl)} in (if ((card matches) <> 1)then <err>else let {i}'set of (nat1) = matches in construct_ev((s.val)(i), ((s.type).tps)(i)))struc_length' (StructureType -> nat)	struc_length(s) ==(len (s.tps))vector_extract' (Vector * int -> Expressible_value)	vector_extract(v, i) ==(v.val)(((i - ((v.type).lower)) + 1))vector_subv' (VectorValue * int * int -> VectorValue)	vector_subv(v, l, u) ==(v(l, ... ,u))vector_length' (VectorType -> nat)	vector_length(v) ==((((v.type).upper) - ((v.type).lower)) + 1)vector_flatten' (VectorValue -> VectorValue)	vector_flatten(vs) ==(conc vs)vector_sum' (VectorValue -> Expressible_value)	vector_sum(v) ==(if ((len v) = 1)then (hd v)else let s'Expressible_value = vector_sum((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realplus((hd v), s)else intplus((hd v), s)))vector_product' (VectorValue -> Expressible_value)	vector_product(v) ==(if ((len v) = 1)then (hd v)else let s'Expressible_value = vector_product((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realmult((hd v), s)else intmult((hd v), s)))vector_all' (VectorValue -> Expressible_value)	vector_all(v) ==(if ((len v) = 1)then (hd v)else let b'Expressible_value = vector_all((tl v)) in (if (b = <err>)then <err>else tr_and((hd v), b)))vector_some' (VectorValue -> Expressible_value)	vector_some(v) ==(if ((len v) = 1)then (hd v)else let b'Expressible_value = vector_some((tl v)) in (if (b = <err>)then <err>else tr_or((hd v), b)))vector_max' (VectorValue -> Expressible_value)	vector_max(v) ==(if ((len v) = 1)then (hd v)else let s'Expressible_value = vector_max((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realmax((hd v), s)else intmax((hd v), s)))vector_min' (VectorValue -> Expressible_value)	vector_min(v) ==(if ((len v) = 1)then (hd v)else let s'Expressible_value = vector_min((tl v)) in (if (s = <err>)then <err>elseif is_((hd v), Real)then realmin((hd v), s)else intmin((hd v), s)))vector_concat' (Vector * Vector -> Vector)	vector_concat(v1, v2) ==let type'Expressible_type = (if tleq(((v1.type).type), ((v2.type).type))then ((v2.type).type)else ((v1.type).type)), lower'int = ((v1.type).lower), upper'int = (((((v1.type).upper) + ((v2.type).upper)) - ((v2.type).lower)) + 1), fl'Flavdom = ((v1.type).fl), vec'seq of ((Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) = ((v1.val) ^ (v2.val)) in let new_type'VectorType = mk_VectorType(lower, upper, type, fl) in mk_Vector(vec, new_type)widen_type' (Expressible_value * Expressible_type -> Expressible_value)	widen_type(x, type) ==(if ((x = <err>) or is_(x, Void))then <err>else mu(x, type |-> type))const_type' (Expressible_value -> (Errvalue | Expressible_type))	const_type(v) ==(if is_(v, Void)then (v.type)elseif is_(v, Vector)then mk_VectorType(((v.type).lower), ((v.type).upper), seqlub([const_type((v.val)(i)) | i in set (inds (v.val))]), ((v.type).fl))elseif is_(v, Structure)then mk_StructureType([const_type(construct_ev((v.val)(i), ((v.type).tps)(i))) | i in set (inds (v.val))], ((v.type).fl))elseif is_(v, Union)then const_type((v.val))elseif (v = <err>)then <err>elseif is_(v, Real)then mk_Float({mk_Floatrng((floor (v.val)), (if is_((v.val), int)then (v.val)else (floor ((v.val) + 0.5))))}, ((v.type).abserr), ((v.type).relerr), ((v.type).fl))elseif is_(v, Int)then mk_IntType(((v.type).rep), {(v.val)}, ((v.type).fl))else mk_TrType({(v.val)}, ((v.type).fl)))fleq' (Expressible_type * Expressible_type -> bool)	fleq(t1, t2) ==(if (is_(t1, VoidType) and is_(t2, VoidType))then (t1 = t2)elseif (not (is_(t1, VoidType) and is_(t2, VoidType)))then ((t1.fl) = (t2.fl))else false)replace_flavour' (Expressible_type * Flavdom -> (Errvalue | Expressible_type))	replace_flavour(type, flav) ==(cases type 'case mk_VoidType(fl) -> mk_VoidType(flav),case mk_TrType(r, f) -> mk_TrType(r, flav),case mk_Float(r, a, re, f) -> mk_Float(r, a, re, flav),case mk_IntType(rep, r, f) -> mk_IntType(rep, r, flav),case mk_VectorType(l, u, t, f) -> mk_VectorType(l, u, t, flav),case mk_UnionType(tps, fl) -> mk_UnionType(tps, flav),case mk_StructureType(tps, fl) -> mk_StructureType(tps, flav)end)lub' (Expressible_type * Expressible_type -> (Errvalue | Expressible_type))	lub(t1, t2) ==(if (is_(t1, TrType) and (is_(t2, TrType) and fleq(t1, t2)))then trlub(t1, t2)elseif (is_(t1, Float) and (is_(t2, Float) and fleq(t1, t2)))then floatlub(t1, t2)elseif (is_(t1, IntType) and (is_(t2, IntType) and fleq(t1, t2)))then intlub(t1, t2)elseif (is_(t1, VectorType) and (is_(t2, VectorType) and fleq(t1, t2)))then vectorlub(t1, t2)elseif (is_(t1, StructureType) and (is_(t2, StructureType) and fleq(t1, t2)))then struclub(t1, t2)elseif (is_(t1, UnionType) and (is_(t2, UnionType) and fleq(t1, t2)))then unionlub(t1, t2)elseif (is_(t1, VoidType) and (is_(t2, VoidType) and fleq(t1, t2)))then t1else <err>)trlub' (TrType * TrType -> TrType)	trlub(t1, t2) ==mk_TrType(((t1.range) union (t2.range)), (t1.fl))floatlub' (Float * Float -> Float)	floatlub(t1, t2) ==mk_Float(((t1.range) union (t2.range)), max({(t1.abserr), (t2.abserr)}), max({(t1.relerr), (t2.relerr)}), (t1.fl))intlub' (IntType * IntType -> (Errvalue | IntType))	intlub(t1, t2) ==(if (((t1.rep) = <byte>) and ((t2.rep) = <byte>))then mk_IntType(<byte>, ((t1.range) union (t2.range)), (t1.fl))elseif (((t1.rep) = <word>) and ((t2.rep) = <word>))then mk_IntType(<word>, ((t1.range) union (t2.range)), (t1.fl))else <err>)vectorlub' (VectorType * VectorType -> (Errvalue | VectorType))	vectorlub(t1, t2) ==(if (((t1.lower) <> (t2.lower)) or (((t1.upper) <> (t2.upper)) or (lub((t1.type), (t2.type)) = <err>)))then <err>else mk_VectorType((t1.lower), (t1.upper), lub((t1.type), (t2.type)), (t1.fl)))struclub' (StructureType * StructureType -> (Errvalue | StructureType))	struclub(t1, t2) ==(if ((len (t1.tps)) <> (len (t2.tps)))then <err>elseif (exists [i in set (inds (t1.tps))] & (lub((t1.tps)(i), (t2.tps)(i)) = <err>))then <err>else mk_StructureType([lub((t1.tps)(i), (t2.tps)(i)) | i in set (inds (t1.tps))], (t1.fl)))unionlub' (UnionType * UnionType -> (Errvalue | UnionType))	unionlub(t1, t2) ==(if ((card (t1.tps)) <> (card (t2.tps)))then <err>else let lub'(Errvalue | Expressible_type) = setlub(((t1.tps) union (t2.tps))) in (if (lub = <err>)then <err>elseif is_(lub, UnionType)then mk_UnionType((lub.tps), (t1.fl))else mk_UnionType({lub}, (t1.fl))))seqlub' (seq1 of (Expressible_type) -> (Errvalue | Expressible_type))	seqlub(tps) ==(if ((len tps) = 1)then (hd tps)elseif (lub(tps(1), tps(2)) = <err>)then <err>else lub(lub(tps(1), tps(2)), seqlub((tl tps))))setlub' (set of (Expressible_type) -> (Errvalue | Expressible_type))	setlub(s) ==(if (exists [t1, t2 in set s] & (lub(t1, t2) = <err>))then (if (forall t in set s & (is_(t, TrType) or (is_(t, IntType) or (is_(t, Float) or is_(t, VoidType)))))then let t1'set of ((Errvalue | Expressible_type)) = {setlub({t' | [t' in set s] & (is_(t', TrType) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, TrType)}, t2'set of ((Errvalue | Expressible_type)) = {setlub({t' | [t' in set s] & (is_(t', IntType) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, IntType)}, t3'set of ((Errvalue | Expressible_type)) = {setlub({t' | [t' in set s] & (is_(t', Float) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, Float)}, t4'set of ((Errvalue | Expressible_type)) = {setlub({t' | [t' in set s] & (is_(t', VoidType) and ((t.fl) = (t'.fl)))}) | [t in set s] & is_(t, VoidType)} in (if ((exists [t, t' in set (dunion {t1, t2, t3, t4})] & ((t.fl) = (t'.fl))) or (exists [t in set (dunion {t1, t2, t3}), mk_VoidType(f) in set t4] & ((t.fl) = f)))then <err>else mk_UnionType((((t1 union t2) union t3) union t4), {}))else <err>)else let t in set s in (if (s = {t})then telse lub(t, setlub((s \ {t})))))gt' (Expressible_type * Expressible_type -> bool)	gt(t1, t2) ==((lub(t1, t2) = t1) or ((fleq(t1, t2) and ((is_(t2, TrType) and let z in set (power {0, 1}) be st ((true in set (t2.range)) => (((1 in set z) and (false in set (t2.range))) => (0 in set z))) in ((is_(t1, Float) and (z subset (dunion {{lower, ... ,upper} | [mk_Floatrng(lower, upper) in set (t1.range)]}))) or (is_(t1, IntType) and (z subset (t1.range))))) or (((is_(t2, IntType) and (((t2.rep) = <byte>) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | [mk_Floatrng(lower, upper) in set (t1.range)]}))))) or (is_(t1, IntType) and (((t1.rep) = <word>) and ((t2.range) subset (t1.range))))) or ((is_(t2, IntType) and (((t2.rep) = <word>) and (is_(t1, Float) and ((t2.range) subset (dunion {{lower, ... ,upper} | [mk_Floatrng(lower, upper) in set (t1.range)]}))))) or ((is_(t2, Float) and (is_(t1, Float) and (((dunion {{lower, ... ,upper} | [mk_Floatrng(lower, upper) in set (t2.range)]}) subset (dunion {{lower, ... ,upper} | [mk_Floatrng(lower, upper) in set (t1.range)]})) and (((t2.abserr) + ((t2.relerr) * max({(abs max({lower, upper})) | [mk_Floatrng(lower, upper) in set (t2.range)]}))) <= ((t1.abserr) + ((t1.relerr) * max({(abs max({lower, upper})) | [mk_Floatrng(lower, upper) in set (t1.range)]}))))))) or (is_(t1, UnionType) and (is_(t2, UnionType) and (forall t in set (t1.tps) & (exists [t' in set (t2.tps)] & (lub(t, t') = t)))))))))) or (is_(t2, UnionType) and (exists [t in set (t2.tps)] & gt(t1, t)))))tleq' (Expressible_type * Expressible_type -> bool)	tleq(t1, t2) ==(lub(t1, t2) = t2)next_locn' (Location -> Location)	next_locn(mk_Location(l)) ==mk_Location((l + 1))access' (Location -> (Store -> Storable_value))	access(l)(s) ==s(l)update' (Location -> (Storable_value -> (Store -> Store)))	update(l)(v)(s) ==(s ++ {l |-> v})multi_update' (seq of (Location) -> (seq of (Storable_value) -> (Store -> Store)))	multi_update(ls)(vs)(s) ==(if (ls = [])then selse multi_update((tl ls))((tl vs))((s ++ {(hd ls) |-> (hd vs)})))	pre ((len ls) = (len vs))timeleq' (Time * Time -> bool)	timeleq(mk_(lt1, ut1), mk_(lt2, ut2)) ==((lt2 <= lt1) and ((lt1 <= ut1) and (ut1 <= ut2)))access_env' (Id -> (Env -> Denotable_value))	access_env(i)(mk_(m, l)) ==m(i)update_env' (Id -> (Denotable_value -> (Env -> Env)))	update_env(i)(d)(mk_(m, l)) ==mk_((m ++ {i |-> d}), l)empty_env' (Location -> Env)	empty_env(l) ==mk_({}, l)multi_update_env' (seq of ((Id * Denotable_value)) -> (Env -> Env))	multi_update_env(s)(e) ==(if (s = [])then eelse let mk_(id, v)'(Id * Denotable_value) = (hd s) in multi_update_env((tl s))(update_env(id)(v)(e)))reserve_locn' (Env -> (Location * Env))	reserve_locn(mk_(m, l)) ==mk_(l, mk_(m, next_locn(l)))instantiate_formals' (seq of (Formal_elt) -> (Param -> (Env -> (Env | Errvalue))))	instantiate_formals(formals)(params)(e) ==(if ((len formals) <> (len params))then <err>else let lubs_eq'seq of (bool) = [(lub((formals(i).rep), (params(i).type)) = (formals(i).rep)) | i in set (inds formals)] in (if (false in set (elems lubs_eq))then <err>else let vals'seq of (Expressible_value) = [(if ((formals(i).fl) = {})then params(i)else widen_type((params(i).val), replace_flavour((params(i).type), (formals(i).fl)))) | i in set (inds params)] in multi_update_env([mk_((formals(i).id), vals(i)) | i in set (inds vals)])(e)))mantissa' (Real -> Real)	mantissa(r) ==rexponent' (Real -> Real)	exponent(r) ==rtplus' (Time * Time -> Time)	tplus(mk_(l1, u1), mk_(l2, u2)) ==mk_((l1 + l2), (u1 + u2))dtplus' (seq of (Time) -> Time)	dtplus(ts) ==(if (ts = [])then zerotelse tplus((hd ts), dtplus((tl ts))))t_trimming_op' (int -> Time)	t_trimming_op(l) ==mk_(1, 1)t_vector_extract' (int -> Time)	t_vector_extract(l) ==mk_(1, 1)t_vector_concat' (int * int -> Time)	t_vector_concat(l, m) ==mk_(1, 1)t_vectorsum' (int -> Time)	t_vectorsum(l) ==mk_(1, 1)t_vectorproduct' (int -> Time)	t_vectorproduct(l) ==mk_(1, 1)t_vector_all' (int -> Time)	t_vector_all(l) ==mk_(1, 1)t_vector_some' (int -> Time)	t_vector_some(l) ==mk_(1, 1)t_vector_max' (int -> Time)	t_vector_max(l) ==mk_(1, 1)t_vector_min' (int -> Time)	t_vector_min(l) ==mk_(1, 1)t_vector_flatten' (int -> Time)	t_vector_flatten(l) ==mk_(1, 1)t_vector_subv' (int -> Time)	t_vector_subv(l) ==mk_(1, 1)t_multi_update' (int -> Time)	t_multi_update(l) ==mk_(1, 1)choose' (Expressible_type -> Expressible_value)	choose(tp) ==let val'Expressible_value be st (lub(const_type(val), tp) = tp) in widen_type(const_type(val), tp)eval_Program' (Program -> (Location -> (Store -> EST_value)))	eval_Program(mk_Program(expr))(l)(sto) ==eval_Expression(expr)(empty_env(l))(mk_PState(sto, zerot))eval_Expression' (Expression -> (Env -> (PState -> EST_value)))	eval_Expression(mk_Expression(expr))(env)(ps) ==(cases expr 'case mk_Operation(op) -> eval_Operation(expr)(env)(ps),case mk_InnerLoop(l) -> eval_InnerLoop(expr)(env)(ps),case mk_Assignment(a) -> eval_Assignment(expr)(env)(ps),case mk_Scope(s) -> eval_Scope(expr)(env)(ps),case mk_GuardedScope(d, i, o) -> eval_GuardedScope(expr)(env)(ps),case mk_Assertion(exp, tp) -> eval_Assertion(expr)(env)(ps),case mk_TimedExpression(t) -> eval_TimedExpression(expr)(env)(ps)end)eval_Operation' (Operation -> (Env -> (PState -> EST_value)))	eval_Operation(mk_Operation(op))(e)(ps) ==(cases op 'case mk_MonOperation(mo) -> eval_MonOperation(op)(e)(ps),case mk_BinaryOperation(l, bo, r) -> eval_BinaryOperation(op)(e)(ps)end)eval_MonOperation' (MonOperation -> (Env -> (PState -> EST_value)))	eval_MonOperation(mk_MonOperation(mo))(e)(ps) ==(cases mo 'case mk_MonOpMonOperand(opr, opnd) -> eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)(ps),case mk_VectorOperation(v, m, op) -> eval_VectorOperation(mk_VectorOperation(v, m, op))(e)(ps),case mk_Value(v) -> eval_Value(mk_Value(v))(e)(ps)end)eval_MonOpMonOperand' (MonOpMonOperand -> (Env -> (PState -> EST_value)))	eval_MonOpMonOperand(mk_MonOpMonOperand(opr, opnd))(e)(ps) ==let x'EST_value = eval_MonOperation(opnd)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else (cases opr 'case <numabs> -> eval_Abs(x),case <unaryminus> -> eval_MonMinus(x),case <not> -> eval_Not(x),case mk_CompileTimeOp(o) -> eval_CompileTimeOp(opr)(x),case <discard> -> eval_Discard(x),case <round> -> eval_Round(x),case <odd> -> eval_Odd(x),case <float> -> eval_Float(x),case <mantissa> -> eval_Mantissa(x),case <exponent> -> eval_Exponent(x)end))eval_Abs' (EST_value -> EST_value)	eval_Abs(mk_EST_value(val, sto, time)) ==(if is_(val, Real)then mk_EST_value(absreal(val), sto, tplus(time, t_absreal))elseif is_(val, Int)then mk_EST_value(absint(val), sto, tplus(time, t_absint))else mk_EST_value(<err>, sto, zerot))eval_MonMinus' (EST_value -> EST_value)	eval_MonMinus(mk_EST_value(val, sto, time)) ==(if is_(val, Real)then mk_EST_value(realmonminus(val), sto, tplus(time, t_realmonminus))elseif is_(val, Int)then mk_EST_value(intmonminus(val), sto, tplus(time, t_intmonminus))else mk_EST_value(<err>, sto, zerot))eval_Not' (EST_value -> EST_value)	eval_Not(mk_EST_value(val, sto, time)) ==(if (not is_(val, Tr))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(tr_not(val), sto, tplus(time, t_not)))eval_CompileTimeOp' (CompileTimeOp -> (EST_value -> EST_value))	eval_CompileTimeOp(mk_CompileTimeOp(op))(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else (cases op 'case <inf> -> mk_EST_value(inf(val), sto, time),case <sup> -> mk_EST_value(sup(val), sto, time),case <absonly> -> mk_EST_value(absonly(val), sto, time),case <relonly> -> mk_EST_value(relonly(val), sto, time),case <abserr> -> mk_EST_value(abserr(val), sto, time),case <relerr> -> mk_EST_value(relerr(val), sto, time)end))eval_Discard' (EST_value -> EST_value)	eval_Discard(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(discard(val), sto, tplus(time, t_discard)))eval_Round' (EST_value -> EST_value)	eval_Round(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(round(val), sto, tplus(time, t_round)))eval_Mantissa' (EST_value -> EST_value)	eval_Mantissa(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(mantissa(val), sto, tplus(time, t_mantissa)))eval_Exponent' (EST_value -> EST_value)	eval_Exponent(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(exponent(val), sto, tplus(time, t_exponent)))eval_Odd' (EST_value -> EST_value)	eval_Odd(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(odd(val), sto, tplus(time, t_odd)))eval_Float' (EST_value -> EST_value)	eval_Float(mk_EST_value(val, sto, time)) ==(if (not is_(val, Real))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(float(val), sto, tplus(time, t_float)))eval_VectorOperation' (VectorOperation -> (Env -> (PState -> EST_value)))	eval_VectorOperation(mk_VectorOperation(vo, mo, mult))(e)(ps) ==let x'EST_value = eval_MonOperation(mo)(e)(ps) in (if (not is_((x.val), Vector))then mk_EST_value(<err>, (ps.sto), zerot)else let v'EST_value = (if (mult = nil)then xelse eval_VectorMult(mu(x, sto |-> (ps.sto)))(mult)(e)) in (if ((v.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else (cases vo 'case <sum> -> eval_VectorSum(v),case <product> -> eval_VectorProduct(v),case <vecmax> -> eval_VectorMax(v),case <vecmin> -> eval_VectorMin(v),case <all> -> eval_VectorAll(v),case <some> -> eval_VectorSome(v),case <flatten> -> eval_VectorFlatten(v)end)))eval_VectorMult' (EST_value -> (Multiple -> (Env -> EST_value)))	eval_VectorMult(mk_EST_value(est_val, sto, time))(mk_Multiple(op, to_p))(e) ==let mk_Vector(val, type)'Expressible_value = est_val in let b1'EST_value = eval_Operation(op)(e)(mk_PState(sto, time)) in let b2'EST_value = eval_Operation(to_p)(e)(mk_PState(sto, (b1.time))) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))then mk_EST_value(<err>, sto, zerot)elseif (((card (((b1.val).type).range)) <> 1) or ((card (((b2.val).type).range)) <> 1))then mk_EST_value(<err>, sto, zerot)else let lower'real = min({((b1.val).val), ((b2.val).val)}), upper'real = max({((b1.val).val), ((b2.val).val)}) in (if ((lower < (type.lower)) or ((type.upper) < upper))then mk_EST_value(<err>, sto, zerot)else let new_val'VectorValue = vector_subv(val, lower, upper), new_type'VectorType = mk_VectorType(lower, upper, (type.type), (type.fl)) in let new_v'Vector = mk_Vector(new_val, new_type), new_t'Time = tplus(tplus((b2.time), t_vector_subv((upper - lower))), tplus(t_min, t_max)) in mk_EST_value(new_v, sto, new_t)))eval_VectorSum' (EST_value -> EST_value)	eval_VectorSum(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_sum(val), sto, tplus(time, t_vectorsum(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorProduct' (EST_value -> EST_value)	eval_VectorProduct(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_product(val), sto, tplus(time, t_vectorproduct(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorMax' (EST_value -> EST_value)	eval_VectorMax(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_max(val), sto, tplus(time, t_vector_max(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorMin' (EST_value -> EST_value)	eval_VectorMin(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (is_((type.type), Float) or is_((type.type), IntType))then mk_EST_value(vector_min(val), sto, tplus(time, t_vector_min(((type.upper) - (type.lower)))))else mk_EST_value(<err>, sto, zerot))eval_VectorAll' (EST_value -> EST_value)	eval_VectorAll(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (not is_((type.type), TrType))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(vector_all(val), sto, tplus(time, t_vector_all(((type.upper) - (type.lower))))))eval_VectorSome' (EST_value -> EST_value)	eval_VectorSome(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (not is_((type.type), TrType))then mk_EST_value(<err>, sto, zerot)else mk_EST_value(vector_some(val), sto, tplus(time, t_vector_some(((type.upper) - (type.lower))))))eval_VectorFlatten' (EST_value -> EST_value)	eval_VectorFlatten(mk_EST_value(mk_Vector(val, type), sto, time)) ==(if (not is_((type.type), VectorType))then mk_EST_value(<err>, sto, zerot)else let new_val'VectorValue = vector_flatten(val) in let new_upper'int = (((len new_val) + (type.lower)) - 1) in let new_time'Time = tplus(time, t_vector_flatten(((type.upper) - (type.lower)))), new_type'VectorType = mk_VectorType((type.lower), new_upper, (type.type), (type.fl)) in mk_EST_value(mk_Vector(new_val, new_type), sto, new_time))eval_BinaryOperation' (BinaryOperation -> (Env -> (PState -> EST_value)))	eval_BinaryOperation(bo)(e)(ps) ==let mk_BinaryOp(op)'BinaryOp = (bo.opr) in (cases op 'case mk_NumOp(opr) -> eval_NumOp(bo)(e)(ps),case <numgt> -> eval_CompOp(bo)(e)(ps),case <numlt> -> eval_CompOp(bo)(e)(ps),case <numge> -> eval_CompOp(bo)(e)(ps),case <numle> -> eval_CompOp(bo)(e)(ps),case <and> -> eval_BoolOp(bo)(e)(ps),case <or> -> eval_BoolOp(bo)(e)(ps),case <EQ> -> eval_EqOp(bo)(e)(ps),case <NEQ> -> eval_EqOp(bo)(e)(ps),case <concat> -> eval_Concat(bo)(e)(ps)end)eval_NumOp' (BinaryOperation -> (Env -> (PState -> EST_value)))	eval_NumOp(mk_BinaryOperation(left, mk_BinaryOp(opr), right))(e)(ps) ==let a1'EST_value = eval_MonOperation(left)(e)(ps) in let a2'EST_value = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (cases opr 'case mk_NumOp(op) -> (cases mk_((a1.val), (a2.val)) 'case mk_(mk_Int(v1, t1), mk_Int(v2, t2)) -> (if (op <> <numdiv>)then let val'Expressible_value = intbinop(mk_Int(v1, t1), mk_Int(v2, t2), mk_NumOp(op)) in (if (val = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else mk_EST_value(val, (ps.sto), tplus((a2.time), t_intbinop)))else mk_EST_value(<err>, (ps.sto), zerot)),case mk_(mk_Real(v1, t1), mk_Real(v2, t2)) -> (if (op not in set {<numdiv>, <nummod>})then let val'Expressible_value = realbinop(mk_Real(v1, t1), mk_Real(v2, t2), mk_NumOp(op)) in (if (val = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else mk_EST_value(val, (ps.sto), tplus((a2.time), t_realbinop)))else mk_EST_value(<err>, (ps.sto), zerot))others mk_EST_value(<err>, (ps.sto), zerot)end),case <replaceflav> -> (if (((a2.val) <> <err>) and is_((a2.val), Void))then let mk_VoidType(f)'(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) = ((a2.val).type) in mk_EST_value(mu((a1.val), type |-> replace_flavour(((a1.val).type), f)), (ps.sto), (a2.time))else mk_EST_value(<err>, (ps.sto), zerot))others mk_EST_value(<err>, (ps.sto), zerot)end)eval_CompOp' (BinaryOperation -> (Env -> (PState -> EST_value)))	eval_CompOp(mk_BinaryOperation(left, mk_BinaryOp(opr), right))(e)(ps) ==let a1'EST_value = eval_MonOperation(left)(e)(ps) in let a2'EST_value = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (is_((a1.val), Int) and is_((a2.val), Int))then mk_EST_value(intcomp((a1.val), (a2.val), opr), (ps.sto), tplus((a2.time), t_intcomp))elseif (is_((a1.val), Real) and is_((a2.val), Real))then mk_EST_value(realcomp((a1.val), (a2.val), opr), (ps.sto), tplus((a2.time), t_realcomp))else mk_EST_value(<err>, (ps.sto), zerot))eval_EqOp' (BinaryOperation -> (Env -> (PState -> EST_value)))	eval_EqOp(mk_BinaryOperation(left, mk_BinaryOp(op), right))(e)(ps) ==let a1'EST_value = eval_MonOperation(left)(e)(ps) in let a2'EST_value = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (is_((a1.val), Tr) and is_((a2.val), Tr))then mk_EST_value(tr_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_tr_eq))elseif (is_((a1.val), Real) and is_((a2.val), Real))then mk_EST_value(real_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_real_eq))elseif (is_((a1.val), Int) and is_((a2.val), Int))then mk_EST_value(int_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_int_eq))elseif (is_((a1.val), Void) and is_((a2.val), Void))then mk_EST_value(void_eq((a1.val), (a2.val), op), (ps.sto), tplus((a2.time), t_void_eq))else mk_EST_value(<err>, (ps.sto), zerot))eval_BoolOp' (BinaryOperation -> (Env -> (PState -> EST_value)))	eval_BoolOp(mk_BinaryOperation(left, mk_BinaryOp(op), right))(e)(ps) ==let a1'EST_value = eval_MonOperation(left)(e)(ps) in let a2'EST_value = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (not (is_((a2.val), Tr) and is_((a2.val), Tr)))then mk_EST_value(<err>, (ps.sto), zerot)else (cases op 'case <and> -> mk_EST_value(tr_and((a1.val), (a2.val)), (ps.sto), tplus((a2.time), t_and)),case <or> -> mk_EST_value(tr_or((a1.val), (a2.val)), (ps.sto), tplus((a2.time), t_and))end))eval_Concat' (BinaryOperation -> (Env -> (PState -> EST_value)))	eval_Concat(mk_BinaryOperation(left, op, right))(e)(ps) ==let a1'EST_value = eval_MonOperation(left)(e)(ps) in let a2'EST_value = eval_MonOperation(right)(e)(mu(ps, time |-> (a1.time))) in (if (not (is_((a1.val), Vector) and is_((a2.val), Vector)))then mk_EST_value(<err>, (ps.sto), zerot)elseif (not (tleq((((a1.val).type).type), (((a2.val).type).type)) or tleq((((a2.val).type).type), (((a1.val).type).type))))then mk_EST_value(<err>, (ps.sto), zerot)else let new_vec'Vector = vector_concat((a1.val), (a2.val)), new_time'Time = tplus((a2.time), t_vector_concat(vector_length(((a1.val).type)), vector_length(((a2.val).type)))) in mk_EST_value(new_vec, (ps.sto), new_time))eval_Value' (Value -> (Env -> (PState -> EST_value)))	eval_Value(mk_Value(val))(e)(ps) ==(cases val 'case mk_ConstantValue(c) -> eval_ConstantValue(mk_ConstantValue(c))(ps),case mk_NamedValue(n) -> eval_NamedValue(mk_NamedValue(n))(e)(ps),case mk_VectorVal(v) -> eval_VectorVal(mk_VectorVal(v))(e)(ps),case mk_StructureValue(s) -> eval_StructureValue(mk_StructureValue(s))(e)(ps),case mk_Sequence(s) -> eval_Sequence(mk_Sequence(s))(e)(ps),case mk_Call(id, acts) -> eval_Call(mk_Call(id, acts))(e)(ps),case mk_Conditional(c) -> eval_Conditional(val)(e)(ps),case mk_Widening(exp, t) -> eval_Widening(val)(e)(ps),case mk_OuterLoop(l) -> eval_OuterLoop(val)(e)(ps)end)eval_ConstantValue' (ConstantValue -> (PState -> EST_value))	eval_ConstantValue(mk_ConstantValue(cv))(ps) ==(cases cv 'case mk_IntegerDenotation(z) -> let rep'(<byte> | <word>) = (if ((abs z) >= bytemax)then <word>else <byte>) in mk_EST_value(mk_Int(z, mk_IntType(rep, {z}, {})), (ps.sto), (ps.time)),case mk_FloatingDenotation(r) -> mk_EST_value(mk_Real(r, mk_Float({mk_Floatrng((floor r), (if is_(r, int)then relse (floor (r + 0.5))))}, 0, 0, {})), (ps.sto), (ps.time)),case mk_BooleanDenotation(b) -> mk_EST_value(mk_Tr(b, mk_TrType({b}, {})), (ps.sto), (ps.time)),case mk_Ascii_Char(c) -> mk_EST_value(mk_Int(ascii(c), mk_IntType(<byte>, {ascii(c)}, {})), (ps.sto), (ps.time)),case mk_Ascii_string(s) -> mk_EST_value(mk_Vector([mk_Int(ascii(s(i)), mk_IntType(<byte>, {ascii(s(i))}, {})) | i in set (inds s)], mk_VectorType(1, (len s), seqlub([mk_IntType(<byte>, {ascii(s(i))}, {}) | i in set (inds s)]), {})), (ps.sto), (ps.time)),case mk_Flavouring(fl) -> mk_EST_value(mk_Void(<nil>, mk_VoidType(eval_Flavouring(cv))), (ps.sto), (ps.time)),case <skip> -> mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), tplus((ps.time), t_skip))end)eval_NamedValue' (NamedValue -> (Env -> (PState -> EST_value)))	eval_NamedValue(mk_NamedValue(nv))(e)(ps) ==(cases nv 'case mk_FlavourExtract(n, fl) -> eval_FlavourExtract(nv)(e)(ps),case mk_FlavourStrip(n, fl) -> eval_FlavourStrip(nv)(e)(ps),case mk_VectorExtract(n, i) -> eval_VectorExtract(nv)(e)(ps),case mk_VectorTrimming(n, t, i) -> eval_VectorTrimming(nv)(e)(ps)others eval_Identifier(nv)(e)(ps)end)eval_Identifier' (Id -> (Env -> (PState -> EST_value)))	eval_Identifier(id)(mk_(m, l))(mk_PState(sto, time)) ==(if (id in set (dom m))then (cases access_env(id)(mk_(m, l)) 'case mk_Location(l) -> let mk_Storable_value(v)'Storable_value = access(mk_Location(l))(sto) in mk_EST_value(v, sto, tplus(time, t_access)),case mk_Storable_value(v) -> mk_EST_value(v, sto, time)end)else mk_EST_value(<err>, sto, time))eval_FlavourExtract' (FlavourExtract -> (Env -> (PState -> EST_value)))	eval_FlavourExtract(mk_FlavourExtract(nv, fl))(e)(ps) ==let n'EST_value = eval_NamedValue(nv)(e)(ps), f'Flavdom = eval_Flavouring(fl) in (if (not is_((n.val), Structure))then mk_EST_value(<err>, (ps.sto), (ps.time))else mk_EST_value(comp_extract((n.val), f), (ps.sto), tplus((n.time), t_comp_extract)))eval_Flavouring' (Flavouring -> Flavdom)	eval_Flavouring(mk_Flavouring(fls)) ==(if (fls = [])then {}else ({eval_Flavour((hd fls))} union eval_Flavouring(mk_Flavouring((tl fls)))))eval_Flavour' (Flavour -> Fl_elt)	eval_Flavour(mk_Flavour(name, index)) ==mk_Fl_elt(name, index)eval_FlavourStrip' (FlavourStrip -> (Env -> (PState -> EST_value)))	eval_FlavourStrip(mk_FlavourStrip(nv, fl))(e)(ps) ==let n'EST_value = eval_NamedValue(nv)(e)(ps), f'Flavdom = eval_Flavouring(fl) in (if (not is_((n.val), Structure))then mk_EST_value(<err>, (ps.sto), (ps.time))else let n''Expressible_value = comp_extract((n.val), f) in let n'''Structure = mk_Structure((n'.val), mk_StructureType(((n'.type).tps), {})) in mk_EST_value(n'', (ps.sto), tplus((n.time), t_comp_extract)))eval_VectorExtract' (VectorExtract -> (Env -> (PState -> EST_value)))	eval_VectorExtract(mk_VectorExtract(n, i))(e)(ps) ==let x'EST_value = eval_NamedValue(n)(e)(ps) in (if (not is_((x.val), Vector))then mk_EST_value(<err>, (ps.sto), (ps.time))else let index'EST_value = eval_Operation(i)(e)(mu(ps, time |-> (x.time))), length'int = (((((x.val).type).upper) - (((x.val).type).lower)) + 1) in (if (not is_((index.val), Int))then mk_EST_value(<err>, (ps.sto), (ps.time))elseif (not ((((index.val).type).range) subset {(((x.val).type).lower), ... ,(((x.val).type).upper)}))then mk_EST_value(<err>, (ps.sto), (ps.time))else mk_EST_value(vector_extract((x.val), ((index.val).val)), (ps.sto), tplus((index.time), t_vector_extract(length)))))eval_VectorTrimming' (VectorTrimming -> (Env -> (PState -> EST_value)))	eval_VectorTrimming(mk_VectorTrimming(name, to_p, ctv))(e)(ps) ==let vec'EST_value = eval_NamedValue(name)(e)(ps) in (if ((not is_((vec.val), Vector)) or (is_((vec.val), Vector) and (not (is_((((vec.val).type).type), Float) or is_((((vec.val).type).type), IntType)))))then mk_EST_value(<err>, (ps.sto), zerot)else let v'EST_value = eval_CompileTimeValue(ctv)(e) in (if (not (is_((v.val), Real) or is_((v.val), Int)))then mk_EST_value(<err>, (ps.sto), zerot)else let new_v'seq of ((Component | Errvalue | Int | Real | StructValue | Tr | VectorValue | Void)) = (cases to_p 'case <gtvalue> -> [((vec.val).val)(i) | i in set (inds ((vec.val).val)) & (((vec.val).val)(i) >= ((v.val).val))],case <ltvalue> -> [((vec.val).val)(i) | i in set (inds ((vec.val).val)) & (((vec.val).val)(i) <= ((v.val).val))],case <atvalue> -> [((vec.val).val)(i) | i in set (inds ((vec.val).val)) & (((vec.val).val)(i) = ((v.val).val))]end) in (if (new_v = [])then mk_EST_value(<err>, (ps.sto), zerot)else let new_l'int = (((vec.val).type).lower), new_u'int = (((((vec.val).type).lower) + (len new_v)) - 1), new_t'(Errvalue | Expressible_type) = seqlub([const_type(new_v(i)) | i in set (inds new_v)]), new_fl'Flavdom = (((vec.val).type).fl) in let new_vec'Vector = mk_Vector(new_v, mk_VectorType(new_l, new_u, new_t, new_fl)), new_time'Time = tplus((vec.time), t_trimming_op((new_u - new_l))) in mk_EST_value(new_vec, (ps.sto), new_time))))eval_CompileTimeValue' (CompileTimeValue -> (Env -> EST_value))	eval_CompileTimeValue(mk_CompileTimeValue(op))(mk_(m, l)) ==let locs'set of (Id) = {id | [id in set (dom m)] & is_(m(id), Location)} in let new_m'map (Id) to (Denotable_value) = (locs <-' m) in let new_env'(map (Id) to (Denotable_value) * Location) = mk_(new_m, l) in eval_Operation(op)(new_env)(mk_PState({}, zerot))eval_VectorVal' (VectorVal -> (Env -> (PState -> EST_value)))	eval_VectorVal(mk_VectorVal(ops))(e)(ps) ==let vals'seq of (EST_value) = [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in let val'seq of (Expressible_value) = [(vals(i).val) | i in set (inds vals)], time'Time = dtplus([(vals(i).time) | i in set (inds vals)]) in (if (<err> in set (elems val))then mk_EST_value(<err>, (ps.sto), zerot)else let type'(Errvalue | Expressible_type) = seqlub([(val(i).type) | i in set (inds val)]) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let tp'VectorType = mk_VectorType(1, (len val), type, {}) in let x'Vector = mk_Vector(val, tp) in mk_EST_value(x, (ps.sto), time)))eval_StructureValue' (StructureValue -> (Env -> (PState -> EST_value)))	eval_StructureValue(mk_StructureValue(ops))(e)(ps) ==let vals'seq of (EST_value) = [eval_Operation(ops(i))(e)(mk_PState((ps.sto), zerot)) | i in set (inds ops)] in (if (exists [val in set (elems vals)] & (not (is_((val.val), Tr) or (is_((val.val), Int) or is_((val.val), Real)))))then mk_EST_value(<err>, (ps.sto), zerot)elseif (exists [v1, v2 in set (elems vals)] & fleq(((v1.val).type), ((v2.val).type)))then mk_EST_value(<err>, (ps.sto), zerot)else let tps'seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) = [((vals(i).val).type) | i in set (inds vals)], time'Time = dtplus([(vals(i).time) | i in set (inds vals)]), comps'seq of ((<nil> | StructValue | UnionValue | VectorValue | bool | real)) = [((vals(i).val).val) | i in set (inds vals)] in let type'StructureType = mk_StructureType(tps, {}) in let val'Structure = mk_Structure(comps, type) in mk_EST_value(val, (ps.sto), time))eval_Sequence' (Sequence -> (Env -> (PState -> EST_value)))	eval_Sequence(mk_Sequence(exprs))(e)(ps) ==let x'EST_value = eval_Expression((hd exprs))(e)(ps) in (if ((len exprs) = 1)then xelseif is_((x.val), Void)then eval_Sequence(mk_Sequence((tl exprs)))(e)(mk_PState((x.sto), (x.time)))else mk_EST_value(<err>, (ps.sto), zerot))eval_Call' (Call -> (Env -> (PState -> EST_value)))	eval_Call(mk_Call(id, acts))(mk_(m, l))(mk_PState(sto, time)) ==(if (id not in set (dom m))then mk_EST_value(<err>, sto, zerot)else let pp'Denotable_value = access_env(id)(mk_(m, l)) in (if (not is_(pp, Proc))then mk_EST_value(<err>, sto, zerot)else let mk_Proc(p)'Denotable_value = pp in let params'seq of (EST_value) = eval_Acts(acts)(mk_(m, l))(mk_PState(sto, time)) in (if (<err> in set {(x.val) | [x in set (elems params)]})then mk_EST_value(<err>, sto, zerot)else p([(params(i).val) | i in set (inds params)])(mk_PState(sto, (params((len params)).time))))))eval_Acts' (seq of (Operation) -> (Env -> (PState -> seq of (EST_value))))	eval_Acts(ops)(e)(ps) ==(if (ops = [])then []else let x'EST_value = eval_Operation((hd ops))(e)(ps) in ([x] ^ eval_Acts((tl ops))(e)(mk_PState((ps.sto), (x.time)))))eval_Widening' (Widening -> (Env -> (PState -> EST_value)))	eval_Widening(mk_Widening(expr, dest_type))(e)(ps) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let xt'(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) = ((x.val).type), dt'(Errvalue | Expressible_type) = eval_Type(dest_type)(e) in (if (dt = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let dt''Expressible_type = phi_remove(dt) in (if gt(dt', xt)then mk_EST_value(widen_type((x.val), dt'), (ps.sto), (x.time))else mk_EST_value(<err>, (ps.sto), zerot))))eval_Type' (Type -> (Env -> (Errvalue | Expressible_type)))	eval_Type(mk_Type(tp))(e) ==(cases tp 'case mk_PrimitiveType(p) -> eval_PrimitiveType(tp)(e),case mk_VecType(range, tpe) -> eval_VecType(tp)(e),case mk_StrucType(tps) -> eval_StrucType(tp)(e),case mk_FlavouredType(fl, tpe) -> eval_FlavouredType(tp)(e),case mk_UnionTp(tps) -> eval_UnionTp(tp)(e),case mk_TypeName(id) -> eval_TypeName(tp)(e)end)eval_PrimitiveType' (PrimitiveType -> (Env -> (Errvalue | Expressible_type)))	eval_PrimitiveType(mk_PrimitiveType(pt))(e) ==(if is_(pt, Number)then eval_Number(pt)(e)elseif is_(pt, FloatType)then eval_FloatType(pt)(e)else eval_VoidValType(pt)(e))eval_Number' (Number -> (Env -> (Errvalue | Expressible_type)))	eval_Number(mk_Number(rep, range))(e) ==let ranges'set of ((Errvalue | set of (int))) = {eval_Range(r)(e) | [r in set (elems range)]} in (if (<err> in set ranges)then <err>elseif (rep = <bit>)then (if (exists [v in set (dunion ranges)] & (v not in set {0, 1}))then <err>else let m'map (nat) to (bool) = {0 |-> false, 1 |-> true} in mk_TrType({m(v) | [v in set (dunion ranges)]}, {}))elseif (rep = <byte>)then (if (exists [v in set (dunion ranges)] & ((abs v) > bytemax))then <err>else mk_IntType(rep, (dunion ranges), {}))elseif (exists [v in set (dunion ranges)] & ((abs v) > maxint))then <err>else mk_IntType(rep, (dunion ranges), {}))eval_Range' (Range -> (Env -> (Errvalue | set of (int))))	eval_Range(mk_Range(lower, upper))(e) ==(if (((lower = nil) and (upper = nil)) or (((lower <> nil) and (not is_((eval_CompileTimeValue(lower)(e).val), Int))) or ((upper <> nil) and (not is_((eval_CompileTimeValue(upper)(e).val), Int)))))then <err>elseif (lower = nil)then {x | [x'int] & ((0 <= x) and (x <= ((eval_CompileTimeValue(upper)(e).val).val)))}elseif (upper = nil)then {x | [x'int] & ((((eval_CompileTimeValue(lower)(e).val).val) <= x) and (x <= maxint))}else {x | [x'int] & ((((eval_CompileTimeValue(lower)(e).val).val) <= x) and (x <= ((eval_CompileTimeValue(upper)(e).val).val)))})eval_FloatType' (FloatType -> (Env -> (Errvalue | Expressible_type)))	eval_FloatType(mk_FloatType(ranges, abserr, relerr))(e) ==(if (((abserr = nil) and (relerr = nil)) or (exists [range in set (elems ranges)] & (eval_Range(range)(e) = <err>)))then <err>else let abse'(Expressible_value | Real) = (if (abserr = nil)then mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))else (eval_CompileTimeValue(abserr)(e).val)), rele'(Expressible_value | Real) = (if (relerr = nil)then mk_Real(0, mk_Float({mk_Floatrng(0, 0)}, 0, 0, {}))else (eval_CompileTimeValue(relerr)(e).val)) in (if (not (is_(abse, Real) and is_(rele, Real)))then <err>else mk_Float({mk_Floatrng(min(eval_Range(range)(e)), max(eval_Range(range)(e))) | [range in set (elems ranges)]}, (abse.val), (rele.val), {})))eval_VoidValType' (VoidValType -> (Env -> (Errvalue | Expressible_type)))	eval_VoidValType(fl) ==(lambda [e'(unresolved DEFAULT`Env)] & mk_VoidType(eval_Flavouring(fl)))eval_StrucType' (StrucType -> (Env -> (Errvalue | Expressible_type)))	eval_StrucType(mk_StrucType(tps))(e) ==let typs'seq of ((Errvalue | Expressible_type)) = [eval_Type(tps(i))(e) | i in set (inds tps)] in (if (exists [tp in set (elems typs)] & (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))then <err>elseif (exists [tp1, tp2 in set (elems typs)] & ((tp1 <> tp2) and ((tp1.fl) = (tp2.fl))))then <err>else mk_StructureType(typs, {}))eval_VecType' (VecType -> (Env -> (Errvalue | Expressible_type)))	eval_VecType(mk_VecType(range, tp)) ==(lambda [e'(unresolved DEFAULT`Env)] & let typ'(Errvalue | Expressible_type) = eval_Type(tp)(e), nrange'(Errvalue | set of (int)) = eval_Range(range)(e) in (if ((typ = <err>) or (nrange = <err>))then <err>else mk_VectorType(min(nrange), max(nrange), typ, {})))eval_FlavouredType' (FlavouredType -> (Env -> (Errvalue | Expressible_type)))	eval_FlavouredType(mk_FlavouredType(fl, tp))(e) ==let flavour'Flavdom = eval_Flavouring(fl), typ'(Errvalue | Expressible_type) = eval_Type(tp)(e) in (if (typ = <err>)then <err>else (cases typ 'case mk_VoidType(t) -> mk_VoidType((t union flavour)),case mk_TrType(range, fl) -> mk_TrType(range, (fl union flavour)),case mk_IntType(rep, range, fl) -> mk_IntType(rep, range, (fl union flavour)),case mk_Float(range, abse, rele, fl) -> mk_Float(range, abse, rele, (fl union flavour)),case mk_VectorType(lower, upper, tp, fl) -> mk_VectorType(lower, upper, tp, (fl union flavour)),case mk_StructureType(tps, fl) -> mk_StructureType(tps, (fl union flavour)),case mk_UnionType(tps, fl) -> mk_UnionType(tps, (fl union flavour))end))eval_UnionTp' (UnionTp -> (Env -> (Errvalue | Expressible_type)))	eval_UnionTp(mk_UnionTp(tps))(e) ==let typs'set of ((Errvalue | Expressible_type)) = {eval_Type(tps(i))(e) | [i in set (inds tps)]} in (if (exists [tp in set typs] & (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))then <err>elseif (exists [t1, t2 in set typs] & fleq(t1, t2))then <err>else mk_UnionType(typs, {}))eval_TypeName' (TypeName -> (Env -> (Errvalue | Expressible_type)))	eval_TypeName(mk_TypeName(id))(mk_(m, l)) ==(if (id in set (dom m))then (cases access_env(id)(mk_(m, l)) 'case mk_Location(l) -> <err>,case mk_Storable_value(v) -> <err>,case mk_Proc(p) -> <err>,case <err> -> <err>,case t -> tend)else <err>)eval_Scope' (Scope -> (Env -> (PState -> EST_value)))	eval_Scope(mk_Scope(s))(e)(ps) ==(if is_(s, SimpleScope)then eval_SimpleScope(s)(e)(ps)else eval_PackageScope(s)(e)(ps))eval_SimpleScope' (SimpleScope -> (Env -> (PState -> EST_value)))	eval_SimpleScope(mk_SimpleScope(decls, expr))(e)(ps) ==let old_env_st'(Env * PState) = mk_(e, ps) in let new_env_st'EnvState = eval_Decls(decls)(old_env_st) in (if (new_env_st = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(new_env, new_sto)'EnvState = new_env_st in eval_Expression(expr)(new_env)(new_sto))eval_Decls' (seq of (Declaration) -> (EnvState -> EnvState))	eval_Decls(decls)(env_st) ==(if (env_st = <err>)then <err>elseif (decls = [])then env_stelse eval_Decls((tl decls))(eval_Declaration((hd decls))(env_st)))eval_Declaration' (Declaration -> (EnvState -> EnvState))	eval_Declaration(decl)(env_st) ==(cases decl 'case mk_ImportDecl(id, tp) -> eval_ImportDecl(decl)(env_st),case mk_ExportDecl(id, expr) -> eval_ExportDecl(decl)(env_st),case mk_LetDecl(l) -> eval_LetDecl(decl)(env_st),case mk_VarDecl(id, expr) -> eval_VarDecl(decl)(env_st),case mk_ProcDec(nls, ph, expr) -> eval_ProcDec(decl)(env_st),case mk_TypeDec(id, type) -> eval_TypeDec(decl)(env_st)end)eval_ImportDecl' (ImportDecl -> (EnvState -> EnvState))	eval_ImportDecl(mk_ImportDecl(id, tp))(mk_(e, ps)) ==let type'(Errvalue | Expressible_type) = eval_Type(tp)(e) in (if (type = <err>)then <err>else let val'Expressible_value = choose(type), mk_(l, n_e)'(Location * Env) = reserve_locn(e) in let nn_e'Env = update_env(id)(l)(n_e), sto'Store = update(l)(mk_Storable_value(val))((ps.sto)), t'Time = tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))eval_ExportDecl' (ExportDecl -> (EnvState -> EnvState))	eval_ExportDecl(mk_ExportDecl(id, expr))(mk_(e, ps)) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else let mk_(l, n_e)'(Location * Env) = reserve_locn(e) in let nn_e'Env = update_env(id)(l)(n_e), sto'Store = update(l)(mk_Storable_value((x.val)))((ps.sto)), t'Time = tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))eval_LetDecl' (LetDecl -> (EnvState -> EnvState))	eval_LetDecl(mk_LetDecl(decl))(es) ==(if is_(decl, SimpleLetDecl)then eval_SimpleLetDecl(decl)(es)else eval_StrucLetDecl(decl)(es))eval_SimpleLetDecl' (SimpleLetDecl -> (EnvState -> EnvState))	eval_SimpleLetDecl(mk_SimpleLetDecl(id, expr))(mk_(e, ps)) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else mk_(update_env(id)((x.val))(e), mk_PState((ps.sto), (x.time))))eval_StrucLetDecl' (StrucLetDecl -> (EnvState -> EnvState))	eval_StrucLetDecl(mk_StrucLetDecl(ids, expr))(mk_(e, ps)) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if (not is_((x.val), Structure))then <err>elseif ((len ids) <> struc_length(((x.val).type)))then <err>else let id_vals'seq of ((Id * Expressible_value)) = [mk_(ids(i), construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ids)] in let new_env'Env = multi_update_env(id_vals)(e) in mk_(new_env, mk_PState((ps.sto), (x.time))))eval_VarDecl' (VarDecl -> (EnvState -> EnvState))	eval_VarDecl(mk_VarDecl(id, expr))(mk_(e, ps)) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else let mk_(l, n_e)'(Location * Env) = reserve_locn(e) in let nn_e'Env = update_env(id)(l)(n_e), sto'Store = update(l)(mk_Storable_value((x.val)))((ps.sto)), t'Time = tplus((ps.time), t_update) in mk_(nn_e, mk_PState(sto, t)))eval_ProcDec' (ProcDec -> (EnvState -> EnvState))	eval_ProcDec(mk_ProcDec(nls, ph, expr))(mk_(e, ps)) ==let env_st'EnvState = eval_NonLocals(nls)(e)(ps) in (if (env_st = <err>)then <err>else let mk_ProcHeading(id, formals)'ProcHeading = ph, mk_(ne, ns)'EnvState = env_st in let fls'seq of (Formal_elt) = eval_Formals(formals)(e) in let pr'Proc = mk_Proc((lambda [a'(unresolved DEFAULT`Param)] & let nn_e'(Env | Errvalue) = instantiate_formals(fls)(a)(ne) in (lambda [nps'(unresolved DEFAULT`PState)] & (if (nn_e = <err>)then mk_EST_value(<err>, (nps.sto), zerot)else let x'EST_value = eval_Expression(expr)(nn_e)(nps) in (if (((x.val) <> <err>) and ((is_((x.val), Void) and (((x.val).type) = mk_VoidType({Phi}))) or ((not is_((x.val), Void)) and ((((x.val).type).fl) = {Phi}))))then mk_EST_value(<err>, (nps.sto), zerot)else x))))) in mk_(update_env(id)(pr)(e), mk_PState((ps.sto), (ns.time))))eval_NonLocals' (NonLocals -> (Env -> (PState -> EnvState)))	eval_NonLocals(mk_NonLocals(ids, decls))(mk_(m, l))(ps) ==let ids_map'(map (?) to (?) | map (Id) to (Denotable_value)) = (if (ids = nil)then {}else ((elems ids) <' m)) in (if (decls = nil)then mk_(mk_(ids_map, l), ps)else eval_Decls(decls)(mk_(mk_(ids_map, l), ps)))eval_Formals' (seq of (Formal) -> (Env -> seq of (Formal_elt)))	eval_Formals(fls)(e) ==[eval_Formal(fls(i))(e) | i in set (inds fls)]eval_Formal' (Formal -> (Env -> Formal_elt))	eval_Formal(mk_Formal(id, rep, fl))(e) ==let n_rep'(Errvalue | Expressible_type) = eval_Representation(rep)(e), n_fl'Flavdom = eval_Flavouring(fl) in mk_Formal_elt(id, n_rep, n_fl)eval_Representation' (Representation -> (Env -> (Errvalue | Expressible_type)))	eval_Representation(rep)(e) ==(cases rep 'case mk_PrimitiveRep(p) -> eval_PrimitiveRep(rep)(e),case mk_StrucRep(rs) -> eval_StrucRep(rep)(e),case mk_VecRep(range, r) -> eval_VecRep(rep)(e),case mk_UnionRep(rs) -> eval_UnionRep(rep)(e),case mk_FlavouredRep(f, r) -> eval_FlavouredRep(rep)(e),case mk_Type(t) -> eval_Type(rep)(e)end)eval_PrimitiveRep' (PrimitiveRep -> (Env -> (Errvalue | Expressible_type)))	eval_PrimitiveRep(mk_PrimitiveRep(rep))(e) ==(if is_(rep, NumRep)then eval_NumRep(rep)(e)else eval_FloatRep(rep)(e))eval_NumRep' (NumRep -> (Env -> (Errvalue | Expressible_type)))	eval_NumRep(mk_NumRep(rep, range))(e) ==let ranges'(set of ((Errvalue | set of (int))) | {}) = (if (range = nil)then {}else {eval_Range(r)(e) | [r in set (elems range)]}) in (if (<err> in set ranges)then <err>elseif (rep = <bit>)then (if (exists [v in set (dunion ranges)] & (v not in set {0, 1}))then <err>else let rngs'set of (bool) = (if (range = nil)then {true, false}else {{0 |-> false, 1 |-> true}(r) | [r in set (dunion ranges)]}) in mk_TrType(rngs, {}))elseif (rep = <byte>)then (if (exists [v in set (dunion ranges)] & ((abs v) > bytemax))then <err>else let rngs'(? | Errvalue | set of (int)) = (if (range = nil)then {-bytemax, ... ,bytemax}else (dunion ranges)) in mk_IntType(rep, rngs, {}))elseif (exists [v in set (dunion ranges)] & ((abs v) > maxint))then <err>else let rngs'(? | Errvalue | set of (int)) = (if (range = nil)then {-maxint, ... ,maxint}else (dunion ranges)) in mk_IntType(rep, rngs, {}))eval_FloatRep' (FloatRep -> (Env -> (Errvalue | Expressible_type)))	eval_FloatRep(mk_FloatRep(range, abserr, relerr))(e) ==let ranges'(set of ((Errvalue | set of (int))) | {}) = (if (range = nil)then {}else {eval_Range(r)(e) | [r in set (elems range)]}), abse'(EST_value | Real) = (if (abserr = nil)then mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))else eval_CompileTimeValue(abserr)(e)), rele'(EST_value | Real) = (if (relerr = nil)then mk_Real(maxint, mk_Float({mk_Floatrng(maxint, maxint)}, 0, 0, {}))else eval_CompileTimeValue(relerr)(e)) in (if ((not (is_((abse.val), Real) and is_((rele.val), Real))) or (<err> in set ranges))then <err>else let rngs'set of (Floatrng) = (if (range = nil)then {mk_Floatrng(-(beta ** maxint), (beta ** maxint))}else {mk_Floatrng(min(r), max(r)) | [r in set ranges]}) in mk_Float(rngs, ((abse.val).val), ((rele.val).val), {}))eval_StrucRep' (StrucRep -> (Env -> (Errvalue | Expressible_type)))	eval_StrucRep(mk_StrucRep(reps))(e) ==let tps'seq of ((Errvalue | Expressible_type)) = [eval_Representation(reps(i))(e) | i in set (inds reps)] in (if (exists [tp in set (elems tps)] & (not (is_(tp, TrType) or (is_(tp, Float) or is_(tp, IntType)))))then <err>elseif (exists [tp1, tp2 in set (elems tps)] & fleq(tp1, tp2))then <err>else mk_StructureType(tps, {}))eval_VecRep' (VecRep -> (Env -> (Errvalue | Expressible_type)))	eval_VecRep(mk_VecRep(range, rep))(e) ==let nrange'(Errvalue | set of (int)) = eval_Range(range)(e), type'(Errvalue | Expressible_type) = eval_Representation(rep)(e) in (if ((type = <err>) or (nrange = <err>))then <err>else mk_VectorType(min(nrange), max(nrange), type, {}))eval_UnionRep' (UnionRep -> (Env -> (Errvalue | Expressible_type)))	eval_UnionRep(mk_UnionRep(reps))(e) ==let tps'set of ((Errvalue | Expressible_type)) = {eval_Representation(rep)(e) | [rep in set (elems reps)]} in (if (exists [tp in set tps] & (not (is_(tp, IntType) or (is_(tp, Float) or (is_(tp, TrType) or is_(tp, VoidType))))))then <err>elseif (exists [tp1, tp2 in set tps] & fleq(tp1, tp2))then <err>else mk_UnionType(tps, {}))eval_FlavouredRep' (FlavouredRep -> (Env -> (Errvalue | Expressible_type)))	eval_FlavouredRep(mk_FlavouredRep(fl, rep))(e) ==let type'(Errvalue | Expressible_type) = eval_Representation(rep)(e), flav'Flavdom = eval_Flavouring(fl) in (if (type = <err>)then <err>else replace_flavour(type, flav))eval_TypeDec' (TypeDec -> (EnvState -> EnvState))	eval_TypeDec(mk_TypeDec(id, tp))(mk_(e, ps)) ==let type'(Errvalue | Expressible_type) = eval_Type(tp)(e) in (if (type = <err>)then <err>else mk_(update_env(id)(type)(e), ps))eval_PackageScope' (PackageScope -> (Env -> (PState -> EST_value)))	eval_PackageScope(mk_PackageScope(ids, decls, expr))(mk_(m, l))(ps) ==let env_st'((map (Id) to (Denotable_value) * Location) * PState) = mk_(mk_(m, l), ps) in let new_env_st'EnvState = eval_Decls(decls)(env_st) in (if (new_env_st = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(mk_(nm, nl), nps)'EnvState = new_env_st in (if (not ((elems ids) subset ((dom nm) \ (dom m))))then mk_EST_value(<err>, (ps.sto), zerot)else let ne'(map (Id) to (Denotable_value) * Location) = mk_((((elems ids) union (dom m)) <' nm), nl) in eval_Expression(expr)(ne)(nps)))eval_GuardedScope' (GuardedScope -> (Env -> (PState -> EST_value)))	eval_GuardedScope(mk_GuardedScope(decls, incl, outcl))(e)(ps) ==let g_decl'((Env * PState * bool) | Errvalue) = eval_GuardedDeclarations(decls)(true)(e)(ps) in (if (g_decl = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(ne, nps, val)'((Env * PState * bool) | Errvalue) = g_decl in let in_val'EST_value = eval_Sequence(incl)(ne)(nps), out_val'EST_value = eval_Sequence(outcl)(ne)(nps) in (if (((in_val.val) = <err>) or ((out_val.val) = <err>))then mk_EST_value(<err>, (ps.sto), zerot)else let type'(Errvalue | Expressible_type) = setlub({((in_val.val).type), ((out_val.val).type)}) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else (if valthen mk_EST_value(widen_type((in_val.val), type), (in_val.sto), tplus((in_val.time), t_if))else mk_EST_value(widen_type((out_val.val), type), (out_val.sto), tplus((out_val.time), t_if))))))eval_GuardedDeclarations' (seq1 of (GuardedDeclaration) -> (bool -> (Env -> (PState -> ((Env * PState * bool) | Errvalue)))))	eval_GuardedDeclarations(decls)(b)(e)(ps) ==let gdcl'((Env * PState * bool) | Errvalue) = eval_GuardedDecl((hd decls))(e)(ps) in (if ((len decls) = 1)then gdclelseif (gdcl = <err>)then <err>else let mk_(ne, nps, tr)'((Env * PState * bool) | Errvalue) = gdcl in eval_GuardedDeclarations((tl decls))((b and tr))(ne)(nps))eval_GuardedDecl' (GuardedDeclaration -> (Env -> (PState -> ((Env * PState * bool) | Errvalue))))	eval_GuardedDecl(decl)(e)(ps) ==(if is_(decl, WhereDecl)then eval_WhereDecl(decl)(e)(ps)else let d'EnvState = eval_Declaration(decl)(mk_(e, ps)) in (if (d = <err>)then <err>else let mk_(ne, nps)'EnvState = d in mk_(ne, nps, true)))eval_WhereDecl' (WhereDecl -> (Env -> (PState -> ((Env * PState * bool) | Errvalue))))	eval_WhereDecl(mk_WhereDecl(type, expr, id))(e)(ps) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then <err>else let t'(Errvalue | Expressible_type) = eval_SkeletonType(type)(((x.val).type))(e) in (cases t 'case <err> -> <err>others let env'Env = (if (id = nil)then eelse update_env(id)((x.val))(e)) in let xt'(Errvalue | Expressible_type) = const_type((x.val)) in (cases xt 'case <err> -> <err>others let val'bool = gt(t, xt) in mk_(env, mk_PState((ps.sto), (x.time)), val)end)end))eval_Assertion' (Assertion -> (Env -> (PState -> EST_value)))	eval_Assertion(mk_Assertion(expr, tp))(e)(ps) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let type'(Errvalue | Expressible_type) = eval_SkeletonType(tp)(((x.val).type))(e) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let xt'(Errvalue | Expressible_type) = const_type((x.val)) in (cases xt 'case <err> -> mk_EST_value(<err>, (ps.sto), zerot)others (if (not (tleq(type, ((x.val).type)) and tleq(xt, type)))then mk_EST_value(<err>, (ps.sto), zerot)else let val'Expressible_value = widen_type((x.val), phi_remove(type)) in mk_EST_value(val, (x.sto), tplus((x.time), t_widen_type)))end)))eval_Conditional' (Conditional -> (Env -> (PState -> EST_value)))	eval_Conditional(mk_Conditional(cond))(e)(ps) ==(if is_(cond, IfThenOnly)then eval_IfThenOnly(cond)(e)(ps)elseif is_(cond, IfThenElse)then eval_IfThenElse(cond)(e)(ps)else eval_CaseExpr(cond)(e)(ps))eval_IfThenOnly' (IfThenOnly -> (Env -> (PState -> EST_value)))	eval_IfThenOnly(mk_IfThenOnly(prop, action))(e)(ps) ==let cond'EST_value = eval_Expression(prop)(e)(ps), aseq'EST_value = eval_Sequence(action)(e)(mu(ps, time |-> tplus((cond.time), t_if))) in (if ((not is_((cond.val), Tr)) or (not is_((aseq.val), Void)))then mk_EST_value(<err>, (ps.sto), zerot)elseif ((cond.val).val)then aseqelse mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), tplus((ps.time), tplus((cond.time), t_if))))eval_IfThenElse' (IfThenElse -> (Env -> (PState -> EST_value)))	eval_IfThenElse(mk_IfThenElse(prop, thenaction, elseaction))(e)(ps) ==let cond'EST_value = eval_Expression(prop)(e)(ps) in (if (not is_((cond.val), Tr))then mk_EST_value(<err>, (ps.sto), zerot)else let then_x'EST_value = eval_Sequence(thenaction)(e)(ps), else_x'EST_value = eval_Sequence(elseaction)(e)(ps) in let type'(Errvalue | Expressible_type) = lub(((then_x.val).type), ((else_x.val).type)) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)elseif ((cond.val).val)then mu(then_x, val |-> widen_type((then_x.val), type), time |-> tplus((then_x.time), (cond.time)))else mu(else_x, val |-> widen_type((else_x.val), type), time |-> tplus((else_x.time), (cond.time)))))eval_CaseExpr' (CaseExpr -> (Env -> (PState -> EST_value)))	eval_CaseExpr(mk_CaseExpr(expr, limbs, outlimb))(e)(ps) ==let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let type_x'(Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) = ((x.val).type) in let ls'seq1 of ((Expressible_type * EST_value)) = eval_Limbs(limbs)((x.val))(e)(mu(ps, time |-> (x.time))) in let os'([] | seq1 of (((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value))) = (if (outlimb = nil)then []else let mk_(t, v)'(Expressible_type * EST_value) = ls((len ls)) in [mk_(type_x, eval_Sequence(outlimb)(e)(mu(ps, time |-> (v.time))))]) in let pats'seq1 of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) = (ls ^ os) in (if (exists [mk_(t, v) in set (elems pats)] & ((v.val) = <err>))then mk_EST_value(<err>, (ps.sto), zerot)else let patlub'(Errvalue | Expressible_type) = setlub({t | [mk_(t, v) in set (elems pats)]}) in (if (patlub = <err>)then mk_EST_value(<err>, (ps.sto), zerot)elseif (lub(type_x, patlub) <> patlub)then mk_EST_value(<err>, (ps.sto), zerot)else let type'(Errvalue | Expressible_type) = setlub({((v.val).type) | [mk_(t, v) in set (elems pats)]}) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let x_type'(Errvalue | Expressible_type) = const_type((x.val)) in let matches'seq of ((((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?)) = [pats(i) | i in set (inds pats) & let mk_(t, v)'(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) = pats(i) in (lub(x_type, t) = t)] in let mk_(mt, mv)'(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * EST_value) | (Expressible_type * EST_value) | ?) = (hd matches) in let time'Time = dtplus([(mv.time), t_const_type, t_widen_type]) in mk_EST_value(widen_type((mv.val), type), (mv.sto), time)))))eval_Limbs' (seq1 of (CaseLimb) -> (Expressible_value -> (Env -> (PState -> seq1 of ((Expressible_type * EST_value))))))	eval_Limbs(limbs)(x)(e)(ps) ==let mk_(t, v)'(Expressible_type * EST_value) = eval_Limb((hd limbs))(x)(e)(ps) in (if ((len limbs) = 1)then [mk_(t, v)]else ([mk_(t, v)] ^ eval_Limbs((tl limbs))(x)(e)(mu(ps, time |-> (v.time)))))eval_Limb' (CaseLimb -> (Expressible_value -> (Env -> (PState -> (Expressible_type * EST_value)))))	eval_Limb(mk_CaseLimb(test, sequ))(x)(e)(ps) ==let t'((Expressible_type * Env * Time) | Errvalue) = eval_Tester(test)(x)(e)(ps) in (if (t = <err>)then mk_(mk_VoidType({}), mk_EST_value(<err>, (ps.sto), zerot))else let mk_(type, env, tm)'((Expressible_type * Env * Time) | Errvalue) = t in let val'EST_value = eval_Sequence(sequ)(env)(mu(ps, time |-> tm)) in (if ((val.val) = <err>)then mk_(mk_VoidType({}), mk_EST_value(<err>, (ps.sto), zerot))else mk_(type, val)))eval_Tester' (Tester -> (Expressible_value -> (Env -> (PState -> ((Expressible_type * Env * Time) | Errvalue)))))	eval_Tester(tester)(x)(e)(ps) ==(cases tester 'case mk_SkeletonType(t) -> let nt'(Errvalue | Expressible_type) = eval_SkeletonType(tester)((x.type))(e) in (if (nt = <err>)then <err>else mk_(nt, e, (ps.time))),case mk_StrucTest(s) -> eval_StrucTest(tester)(x)(e)(ps),case mk_NonStrucTest(id, tp, fl) -> eval_NonStrucTest(tester)(x)(e)(ps)end)eval_SkeletonType' (SkeletonType -> (Expressible_type -> (Env -> (Errvalue | Expressible_type))))	eval_SkeletonType(mk_SkeletonType(skel))(t)(e) ==(cases skel 'case mk_Type(t) -> eval_Type(skel)(e),case mk_NumSkel(r, er) -> eval_NumSkel(skel)(t)(e),case mk_StrucSkel(s) -> eval_StrucSkel(skel)(t)(e),case mk_FlavSkel(s, fl) -> eval_FlavSkel(skel)(t)(e),case mk_VecSkel(s) -> eval_VecSkel(skel)(t)(e),case mk_UnionSkel(s) -> eval_UnionSkel(skel)(t)(e)end)eval_NumSkel' (NumSkel -> (Expressible_type -> (Env -> (Errvalue | Expressible_type))))	eval_NumSkel(mk_NumSkel(ranges, errors))(x_type)(e) ==(if (not (is_(x_type, TrType) or (is_(x_type, IntType) or is_(x_type, Float))))then <err>else let rngs'(set of ((Errvalue | set of (int))) | set of ((set of (Floatrng) | set of (bool) | set of (int))) | set of (set of (int))) = (if (ranges = nil)then (if is_(x_type, Float)then {{l, ... ,u} | [mk_Floatrng(l, u) in set (x_type.range)]}else {(x_type.range)})else {eval_Range(r)(e) | [r in set (elems ranges)]}) in (if (<err> in set rngs)then <err>else (cases x_type 'case mk_TrType(range, fl) -> (if (not ((dunion rngs) subset {0, 1}))then <err>else mk_TrType({{0 |-> false, 1 |-> true}(v) | [v in set (dunion rngs)]}, fl)),case mk_IntType(rep, range, fl) -> (if (((rep = <byte>) and (exists [v in set (dunion rngs)] & ((abs v) >= bytemax))) or (exists [v in set (dunion rngs)] & ((abs v) >= maxint)))then <err>else mk_IntType(rep, (dunion rngs), fl)),case mk_Float(rs, abse, rele, fl) -> (if (exists [v in set (dunion rngs)] & ((abs v) >= maxint))then <err>else let abserr'(<err> | <nil> | StructValue | UnionValue | VectorValue | bool | real) = (if ((errors.abserr) = nil)then abseelse let v1'Expressible_value = (eval_CompileTimeValue((errors.abserr))(e).val) in (if (v1 = <err>)then <err>else (v1.val))), relerr'(<err> | <nil> | StructValue | UnionValue | VectorValue | bool | real) = (if ((errors.relerr) = nil)then releelse let v1'Expressible_value = (eval_CompileTimeValue((errors.relerr))(e).val) in (if (v1 = <err>)then <err>else (v1.val))) in (if (not (is_(abserr, real) and is_(relerr, real)))then <err>else mk_Float({mk_Floatrng(min(r), max(r)) | [r in set rngs]}, abserr, relerr, fl)))end)))eval_StrucSkel' (StrucSkel -> (Expressible_type -> (Env -> (Errvalue | Expressible_type))))	eval_StrucSkel(mk_StrucSkel(comps))(x_type)(e) ==(if (not is_(x_type, StructureType))then <err>elseif (struc_length(x_type) <> (len comps))then <err>else let t'seq of ((CompType | Errvalue | Expressible_type)) = [(if (comps(i) = <nil>)then (x_type.tps)(i)else eval_SkeletonType(comps(i))((x_type.tps)(i))(e)) | i in set (inds comps)] in (if (exists [tp in set (elems t)] & (not (is_(tp, TrType) or (is_(tp, IntType) or is_(tp, Float)))))then <err>else mk_StructureType(t, (x_type.fl))))eval_FlavSkel' (FlavSkel -> (Expressible_type -> (Env -> (Errvalue | Expressible_type))))	eval_FlavSkel(mk_FlavSkel(skel, fl))(x_type)(e) ==let t'(Errvalue | Expressible_type) = eval_SkeletonType(skel)(x_type)(e), f'Flavdom = eval_Flavouring(fl) in (if (t = <err>)then <err>else replace_flavour(t, f))eval_VecSkel' (VecSkel -> (Expressible_type -> (Env -> (Errvalue | Expressible_type))))	eval_VecSkel(mk_VecSkel(skel))(x_type)(e) ==let t'(Errvalue | Expressible_type) = eval_SkeletonType(skel)(x_type)(e) in (if (t = <err>)then <err>else (cases x_type 'case mk_VectorType(l, u, tp, fl) -> mk_VectorType(l, u, t, fl)others <err>end))eval_UnionSkel' (UnionSkel -> (Expressible_type -> (Env -> (Errvalue | Expressible_type))))	eval_UnionSkel(mk_UnionSkel(skels))(x_type)(e) ==let fls'map ((FlavSkel | FlavouredType | VoidValType)) to (Flavdom) = {skel |-> fl | skel in set (elems skels), fl'Flavdom & (fl = (cases skel 'case mk_FlavSkel(skel, f) -> eval_Flavouring(f),case mk_FlavouredType(f, t) -> eval_Flavouring(f)others eval_Flavouring(skel)end))} in (if ((card (dom fls)) <> (card (rng fls)))then <err>elseif is_(x_type, UnionType)then let x_fls'(map (Float) to (Flavdom) | map (IntType) to (Flavdom) | map (TrType) to (Flavdom) | map (VoidType) to (Flavdom)) = (merge {{mk_VoidType(f) |-> f | mk_VoidType(f) in set (x_type.tps)}, {mk_IntType(rep, range, fl) |-> fl | mk_IntType(rep, range, fl) in set (x_type.tps)}, {mk_TrType(range, fl) |-> fl | mk_TrType(range, fl) in set (x_type.tps)}, {mk_Float(rs, a, r, fl) |-> fl | mk_Float(rs, a, r, fl) in set (x_type.tps)}}) in (if (not ((rng fls) subset (rng x_fls)))then <err>else let tps'set of ((Errvalue | Expressible_type)) = {(cases skel 'case mk_FlavSkel(s, f) -> eval_FlavSkel(skel)(tp)(e),case mk_FlavouredType(f, t) -> eval_FlavouredType(skel)(e)others eval_VoidValType(skel)(e)end) | [skel in set (elems skels), tp in set (x_type.tps)] & (fls(skel) = x_fls(tp))} in (if (exists [tp in set tps] & (not (is_(tp, TrType) or (is_(tp, IntType) or (is_(tp, Float) or is_(tp, VoidType))))))then <err>else mk_UnionType(tps, (x_type.fl))))else let fl'(Expressible_type | Flavdom) = (if is_(x_type, VoidType)then x_typeelse (x_type.fl)) in (if (fl not in set (rng fls))then <err>else let skel'(FlavSkel | FlavouredType | VoidValType) = (iota s in set (elems skels) & (fls(s) = fl)) in (cases skel 'case mk_FlavSkel(s, f) -> eval_FlavSkel(skel)(x_type)(e),case mk_FlavouredType(f, t) -> eval_FlavouredType(skel)(e)others eval_VoidValType(skel)(e)end)))eval_NonStrucTest' (NonStrucTest -> (Expressible_value -> (Env -> (PState -> ((Expressible_type * Env * Time) | Errvalue)))))	eval_NonStrucTest(mk_NonStrucTest(id, fl, skel))(x)(e)(ps) ==let t'(Errvalue | Expressible_type) = eval_SkeletonType(skel)((x.type))(e) in (if (t = <err>)then <err>else let t''(Errvalue | Expressible_type) = (if (fl = nil)then telse replace_flavour(t, eval_Flavouring(fl))) in (if (id = nil)then mk_(t', e, (ps.time))else mk_(t', update_env(id)(x)(e), (ps.time))))eval_StrucTest' (StrucTest -> (Expressible_value -> (Env -> (PState -> ((Expressible_type * Env * Time) | Errvalue)))))	eval_StrucTest(mk_StrucTest(tests))(x)(e)(ps) ==(if (not is_(x, Structure))then <err>elseif (struc_length((x.type)) <> (len tests))then <err>else let xs'seq of (Expressible_value) = [construct_ev((x.val)(i), ((x.type).tps)(i)) | i in set (inds (x.val))] in let ts'((seq of (Expressible_type) * Env * Time) | Errvalue) = eval_Testseq(tests)(xs)(e)(ps) in (if (ts = <err>)then <err>else let mk_(tps, env, time)'((seq of (Expressible_type) * Env * Time) | Errvalue) = ts in mk_(mk_StructureType(tps, ((x.type).fl)), env, time)))eval_Testseq' (seq of ((<nil> | NonStrucTest)) -> (seq of (Expressible_value) -> (Env -> (PState -> ((seq of (Expressible_type) * Env * Time) | Errvalue)))))	eval_Testseq(tests)(xs)(e)(ps) ==(if (tests = [])then mk_([], e, (ps.time))else let t'(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) = (if ((hd tests) = <nil>)then mk_(((hd xs).type), e, (ps.time))else eval_NonStrucTest((hd tests))((hd xs))(e)(ps)) in (if (t = <err>)then <err>else let mk_(tp, env, time)'(((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType) * Env * Time) | (Expressible_type * Env * Time) | Errvalue) = t in let ts'((seq of (Expressible_type) * Env * Time) | Errvalue) = eval_Testseq((tl tests))((tl xs))(env)(mu(ps, time |-> time)) in (if (ts = <err>)then <err>else let mk_(tps, n_env, n_time)'((seq of (Expressible_type) * Env * Time) | Errvalue) = ts in mk_(([tp] ^ tps), n_env, n_time))))eval_OuterLoop' (OuterLoop -> (Env -> (PState -> EST_value)))	eval_OuterLoop(mk_OuterLoop(oul))(e)(ps) ==(if is_(oul, OuterIntLoop)then eval_OuterIntLoop(oul)(e)(ps)else eval_OuterVecLoop(oul)(e)(ps))eval_OuterIntLoop' (OuterIntLoop -> (Env -> (PState -> EST_value)))	eval_OuterIntLoop(mk_OuterIntLoop(mk_OverRange(id, range), actns))(e)(ps) ==let nrange'(Errvalue | set of (int)) = eval_Range(range)(e) in (if (nrange = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let vec_elems'seq of (EST_value) = [eval_Sequence(actns)(update_env(id)(mk_Storable_value(mk_Int(i, mk_IntType(<word>, {i}, {}))))(e))(mu(ps, time |-> zerot)) | i in set nrange] in (if (<err> in set {(x.val) | [x in set (elems vec_elems)]})then mk_EST_value(<err>, (ps.sto), zerot)else let type'(Errvalue | Expressible_type) = seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time'Time = dtplus([(vec_elems(i).time) | i in set (inds vec_elems)]) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let vec_val'(seq of ((<nil> | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) = (if (is_(type, StructureType) or is_(type, VectorType))then [((vec_elems(i).val).val) | i in set (inds vec_elems)]else [(vec_elems(i).val) | i in set (inds vec_elems)]) in mk_EST_value(mk_Vector(vec_val, mk_VectorType(1, (len vec_val), type, {})), (ps.sto), tplus((ps.time), time)))))eval_OuterVecLoop' (OuterVecLoop -> (Env -> (PState -> EST_value)))	eval_OuterVecLoop(mk_OuterVecLoop(ovs, actions))(e)(ps) ==let idvs'(Errvalue | seq1 of ((Id * Vector * Time))) = eval_OverVectors(ovs)(e)(ps) in (if (idvs = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let time1'Time = dtplus([let mk_(id, v, t)'(Id * Vector * Time) = idvs(i) in t | i in set (inds idvs)]), new_env'(nat -> Env) = (lambda [i'nat] & multi_update_env(([let mk_(id, v, t)'(Id * Vector * Time) = idvs(j) in mk_(id, vector_extract(v, i)) | j in set (inds idvs)] ^ (if ((ovs.cnt) = nil)then []else [mk_((ovs.cnt), i)])))(e)) in let vec_elems'seq of (EST_value) = [eval_Sequence(actions)(new_env(i))(mu(ps, time |-> zerot)) | i in set let mk_(i1, v, t)'(Id * Vector * Time) = idvs(1) in (inds (v.val))] in (if (<err> in set {(x.val) | [x in set (elems vec_elems)]})then mk_EST_value(<err>, (ps.sto), zerot)else let type'(Errvalue | Expressible_type) = seqlub([((vec_elems(i).val).type) | i in set (inds vec_elems)]), time'Time = dtplus(([(vec_elems(i).time) | i in set (inds vec_elems)] ^ [time1])) in (if (type = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let new_tp'VectorType = mk_VectorType(1, (len vec_elems), type, {}) in let vec_val'(seq of ((<nil> | StructValue | UnionValue | VectorValue | bool | real)) | seq of (Expressible_value)) = (if (is_(type, StructureType) or is_(type, VectorType))then [((vec_elems(i).val).val) | i in set (inds vec_elems)]else [(vec_elems(i).val) | i in set (inds vec_elems)]) in let new_vec'Vector = mk_Vector(vec_val, new_tp) in mk_EST_value(new_vec, (ps.sto), tplus((ps.time), time)))))eval_OverVectors' (OverVectors -> (Env -> (PState -> (Errvalue | seq1 of ((Id * Vector * Time))))))	eval_OverVectors(ovs)(e)(ps) ==let indices'seq of ((Id * Expressible_value * Time)) = [let mk_OverVector(id, val)'OverVector = (ovs.ovv)(i) in let x'EST_value = eval_Operation(val)(e)(mu(ps, time |-> zerot)) in mk_(id, (x.val), (x.time)) | i in set (inds (ovs.ovv))] in (if (exists [i in set (inds indices)] & let mk_(id, v, t)'(Id * Expressible_value * Time) = indices(i) in (not is_(v, Vector)))then <err>else indices)eval_InnerLoop' (InnerLoop -> (Env -> (PState -> EST_value)))	eval_InnerLoop(mk_InnerLoop(innerl))(e)(ps) ==(cases innerl 'case mk_IntLoop(inc, actions) -> eval_IntLoop(innerl)(e)(ps),case mk_VecLoop(ovs, actions) -> eval_VecLoop(innerl)(e)(ps),case mk_TimeLoop(time, actions) -> eval_TimeLoop(innerl)(e)(ps)end)eval_IntLoop' (IntLoop -> (Env -> (PState -> EST_value)))	eval_IntLoop(mk_IntLoop(inc, actions))(e)(ps) ==let idrng'((Id * seq of (int)) | Errvalue) = eval_InnerControl(inc)(e)(ps) in (if (idrng = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_(id, range)'((Id * seq of (int)) | Errvalue) = idrng in let f'(EST_Iterate -> EST_Iterate) = (lambda [x'(unresolved DEFAULT`EST_Iterate)] & let new_env'Env = update_env(id)(mk_Storable_value(mk_Int(range((x.i)), mk_IntType(<word>, (elems range), {}))))(e) in eval_SeqIterate(actions)(new_env)(x)) in let exi'EST_Iterate = NIterate(f, (len range))(mk_EST_Iterate(mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), (ps.time)), 1)) in (exi.expst))eval_InnerControl' (InnerControl -> (Env -> (PState -> ((Id * seq of (int)) | Errvalue))))	eval_InnerControl(inc)(e)(ps) ==(cases inc 'case mk_OverRange(cnt, range) -> let r'(Errvalue | set of (int)) = eval_Range(range)(e) in (if (r = <err>)then <err>else mk_(cnt, [x | x in set r])),case mk_PartialRange(cnt, from_b, to_b, inc) -> let b1'EST_value = eval_Operation(from_b)(e)(ps), b2'EST_value = eval_Operation(to_b)(e)(ps) in (if (not (is_((b1.val), Int) and is_((b2.val), Int)))then <err>else let b3'(Expressible_value | Int) = (if (inc = nil)then (if (((b1.val).val) <= ((b2.val).val))then mk_Int(1, mk_IntType(<byte>, {1, -1}, {}))else mk_Int(-1, mk_IntType(<byte>, {1, -1}, {})))else (eval_Operation(inc)(e)(ps).val)) in (if ((not is_((b3.val), Int)) or (is_((b3.val), Int) and (exists [v1 in set (((b1.val).type).range), v2 in set (((b2.val).type).range), v3 in set (((b3.val).type).range)] & (((v2 - v1) * v3) < 0))))then <err>else let r'seq of (real) = [(((b1.val).val) + (alpha * (b3.val))) | alpha in set {0, ... ,(floor (1 + ((((b2.val).val) - ((b1.val).val)) / (b3.val))))} & ((abs (alpha * (b3.val))) <= (abs (((b2.val).val) - ((b1.val).val))))] in mk_(cnt, r)))end)eval_SeqIterate' (Sequence -> (Env -> (EST_Iterate -> EST_Iterate)))	eval_SeqIterate(sequ)(e)(exi) ==(if (((exi.expst).val) = <err>)then mu(exi, i |-> ((exi.i) + 1))else let new_expst'EST_value = eval_Sequence(sequ)(e)(mk_PState(((exi.expst).sto), ((exi.expst).time))) in mk_EST_Iterate(new_expst, ((exi.i) + 1)))eval_VecLoop' (VecLoop -> (Env -> (PState -> EST_value)))	eval_VecLoop(mk_VecLoop(ovs, actions))(e)(ps) ==let indices'(Errvalue | seq1 of ((Id * Vector * Time))) = eval_OverVectors(ovs)(e)(ps) in (if (indices = <err>)then mk_EST_value(<err>, (ps.sto), zerot)else let time'Time = dtplus([let mk_(id, v, t)'(Id * Vector * Time) = indices(i) in t | i in set (inds indices)]) in let f'(EST_Iterate -> EST_Iterate) = (lambda [x'(unresolved DEFAULT`EST_Iterate)] & let env'Env = multi_update_env([let mk_(id, v, t)'(Id * Vector * Time) = indices(i) in mk_(id, vector_extract(v, (x.i))) | i in set (inds indices)])(e), new_expst'EST_value = mu((x.expst), time |-> ((x.expst).time)) in let new_env'Env = (if ((ovs.cnt) = nil)then envelse update_env((ovs.cnt))(mk_Storable_value(mk_Int((x.i), mk_IntType(<word>, {(x.i)}, {}))))(env)) in eval_SeqIterate(actions)(new_env)(mu(x, expst |-> new_expst))) in let mk_(-, v, -)'(Id * Vector * Time) = indices(1) in let exi'EST_Iterate = NIterate(f, (len (v.val)))(mk_EST_Iterate(mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), tplus((ps.time), time)), 1)) in (exi.expst))eval_TimeLoop' (TimeLoop -> (Env -> (PState -> EST_value)))	eval_TimeLoop(mk_TimeLoop(time, actions))(e)(ps) ==let t'(Errvalue | Time) = eval_TimeInterval(time)(e), x'EST_value = eval_Sequence(actions)(e)(mu(ps, time |-> zerot)) in (if ((t = <err>) or ((x.val) = <err>))then mk_EST_value(<err>, (ps.sto), zerot)elseif (exists [n'nat] & timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t))then let its'nat = (iota n'nat & (timeleq(dtplus([(x.time) | i in set {1, ... ,n}]), t) and (not timeleq(dtplus([(x.time) | i in set {1, ... ,(n + 1)}]), t)))), f'(EST_value -> EST_value) = (lambda [exs'(unresolved DEFAULT`EST_value)] & eval_Sequence(actions)(e)(mk_PState((exs.sto), (exs.time)))) in Iterate(f, its)(mk_EST_value(mk_Void(<nil>, mk_VoidType({})), (ps.sto), (ps.time)))else mk_EST_value(<err>, (ps.sto), zerot))eval_Assignment' (Assignment -> (Env -> (PState -> EST_value)))	eval_Assignment(mk_Assignment(ass))(env)(ps) ==(cases ass 'case mk_NvAssignment(d, e) -> eval_NvAssignment(ass)(env)(ps),case mk_MultAssignment(d, m, e) -> eval_MultAssignment(ass)(env)(ps),case mk_StrAssignment(d, e) -> eval_StrAssignment(ass)(env)(ps)end)eval_NvAssignment' (NvAssignment -> (Env -> (PState -> EST_value)))	eval_NvAssignment(mk_NvAssignment(dest, expr))(e)(ps) ==let l'Denotable_value = access_env(dest)(e) in (if (not is_(l, Location))then mk_EST_value(<err>, (ps.sto), zerot)else let x'EST_value = eval_Expression(expr)(e)(ps) in (if ((x.val) = <err>)then mk_EST_value(<err>, (ps.sto), zerot)elseif (cases ((x.val).type) 'case mk_VoidType(t) -> (t = {Phi})others ((((x.val).type).fl) = {Phi})end)then mk_EST_value(<err>, (ps.sto), zerot)else let mk_Storable_value(dest_val)'Storable_value = access(l)((ps.sto)) in (if gt((dest_val.type), ((x.val).type))then let new_sto'Store = update(l)(mk_Storable_value(widen_type((x.val), (dest_val.type))))((ps.sto)) in mk_EST_value(mk_Void(<nil>, mk_VoidType({})), new_sto, tplus(tplus((ps.time), t_update), t_access))else mk_EST_value(<err>, (ps.sto), zerot))))eval_MultAssignment' (MultAssignment -> (Env -> (PState -> EST_value)))	eval_MultAssignment(mk_MultAssignment(dest, mult, expr))(e)(ps) ==let l'Denotable_value = access_env(dest)(e) in (if (not is_(l, Location))then mk_EST_value(<err>, (ps.sto), zerot)else let mk_Storable_value(v)'Storable_value = access(l)((ps.sto)) in (if (not is_(v, Vector))then mk_EST_value(<err>, (ps.sto), zerot)else let mk_Vector(val, type)'(Int | Real | Structure | Tr | Union | Vector | Void) = v in let v''EST_value = eval_VectorMult(mk_EST_value(v, (ps.sto), (ps.time)))(mult)(e) in let x'EST_value = eval_Expression(expr)(e)(mk_PState((v'.sto), (v'.time))) in (if (((v'.val) = <err>) or (not is_((x.val), Vector)))then mk_EST_value(<err>, (ps.sto), zerot)elseif ((((((x.val).type).upper) - (((x.val).type).lower)) <> ((((v'.val).type).upper) - (((v'.val).type).lower))) or ((not gt(((v.type).type), (((x.val).type).type))) or (cases (((x.val).type).type) 'case mk_VoidType(t) -> (t = {Phi})others ((((x.val).type).fl) = {Phi})end)))then mk_EST_value(<err>, (ps.sto), zerot)else let vleft'Vector = mk_Vector(vector_subv(val, (type.lower), ((((v'.val).type).lower) - 1)), mk_VectorType((type.lower), ((((v'.val).type).lower) - 1), (type.type), (type.fl))), vmid'Expressible_value = (x.val), vright'Vector = mk_Vector(vector_subv(val, ((((v'.val).type).upper) + 1), (type.upper)), mk_VectorType(((((v'.val).type).upper) + 1), (type.upper), (type.type), (type.fl))) in let new_vec'Vector = vector_concat(vector_concat(vleft, vmid), vright), new_time'Time = dtplus([(x.time), t_vector_concat, t_vector_concat, vector_subv, vector_subv]) in mk_EST_value(mk_Void(<nil>, mk_VoidType({})), update(l)(mk_Storable_value(new_vec))((ps.sto)), new_time))))eval_StrAssignment' (StrAssignment -> (Env -> (PState -> EST_value)))	eval_StrAssignment(mk_StrAssignment(dest, expr))(e)(ps) ==let ls'seq of (Denotable_value) = [access_env(dest(i))(e) | i in set (inds dest)] in (if (exists [l in set (elems ls)] & (not is_(l, Location)))then mk_EST_value(<err>, (ps.sto), zerot)else let x'EST_value = eval_Expression(expr)(e)(ps) in (if (not is_((x.val), Structure))then mk_EST_value(<err>, (ps.sto), zerot)elseif ((len ls) <> struc_length(((x.val).type)))then mk_EST_value(<err>, (ps.sto), zerot)else let nvals'seq of (Storable_value) = [access(ls(i))((ps.sto)) | i in set (inds ls)] in let vals'seq of ((Int | Real | Structure | Tr | Union | Vector | Void)) = [let mk_Storable_value(v)'Storable_value = nvals(i) in v | i in set (inds nvals)] in let dest_tps'seq of ((Float | IntType | StructureType | TrType | UnionType | VectorType | VoidType)) = [(vals(i).type) | i in set (inds vals)], x_tps'seq of (CompType) = [(((x.val).type).tps)(i) | i in set (inds (((x.val).type).tps))] in (if (exists [i in set (inds dest_tps)] & (not gt(dest_tps(i), x_tps(i))))then mk_EST_value(<err>, (ps.sto), zerot)else let ys'seq of (Storable_value) = [mk_Storable_value(construct_ev(((x.val).val)(i), (((x.val).type).tps)(i))) | i in set (inds ((x.val).val))], new_t'Time = dtplus([(x.time), t_access, t_construct_ev, t_multi_update((len ys))]) in mk_EST_value(mk_Void(<nil>, mk_VoidType({})), multi_update(ls)(ys)((ps.sto)), new_t))))eval_TimedExpression' (TimedExpression -> (Env -> (PState -> EST_value)))	eval_TimedExpression(mk_TimedExpression(texpr))(e)(ps) ==(if is_(texpr, TimeTakes)then eval_TimeTakes(texpr)(e)(ps)else eval_TimeAssertion(texpr)(e)(ps))eval_TimeTakes' (TimeTakes -> (Env -> (PState -> EST_value)))	eval_TimeTakes(mk_TimeTakes(expr, time))(e)(ps) ==let x'EST_value = eval_Expression(expr)(e)(mu(ps, time |-> zerot)), t'(Errvalue | Time) = eval_TimeInterval(time)(e) in (if (((x.val) = <err>) or (t = <err>))then mk_EST_value(<err>, (ps.sto), zerot)elseif timeleq((x.time), t)then mu(x, time |-> tplus((ps.time), (x.time)))else mk_EST_value(<err>, (ps.sto), zerot))eval_TimeInterval' (TimeInterval -> (Env -> (Errvalue | Time)))	eval_TimeInterval(time)(e) ==let range'(Errvalue | set of (int)) = eval_Range(time)(e) in (if ((range = <err>) or (min(range) < 0))then <err>else mk_(min(range), max(range)))eval_TimeAssertion' (TimeAssertion -> (Env -> (PState -> EST_value)))	eval_TimeAssertion(mk_TimeAssertion(expr, time))(e)(ps) ==let x'EST_value = eval_Expression(expr)(e)(mu(ps, time |-> zerot)), t'(Errvalue | Time) = eval_TimeInterval(time)(e) in (if (((x.val) = <err>) or (t = <err>))then mk_EST_value(<err>, (ps.sto), zerot)elseif timeleq(t, (x.time))then mu(x, time |-> tplus((ps.time), t))else mk_EST_value(<err>, (ps.sto), zerot))Iterate' ((EST_value -> EST_value) * nat -> (EST_value -> EST_value))	Iterate(f, n) ==(if (n = 0)then (lambda [x'(unresolved DEFAULT`EST_value)] & x)elseif (n = 1)then felse (f comp Iterate(f, (n - 1))))NIterate' ((EST_Iterate -> EST_Iterate) * nat -> (EST_Iterate -> EST_Iterate))	NIterate(f, n) ==(if (n = 0)then (lambda [x'(unresolved DEFAULT`EST_Iterate)] & x)elseif (n = 1)then felse (f comp NIterate(f, (n - 1))))end DEFAULT
