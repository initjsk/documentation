WARNING:bar.vdmsl:5000:30,7:Definition 'bagb' not used.
WARNING:bar.vdmsl:5000:18,8:Definition 'Count' not used.
WARNING:bar.vdmsl:5000:29,7:Definition 'baga' not used.
RESULT:result:-1:-1,-1:module BAGexportsexport type struct Bagexport type struct Elemexport function Empty'(() -> (unresolved BAG`Bag))export function Add'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Remove'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Count'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> nat)export function In'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> bool)export function Join'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Union'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function SubBag'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> bool)export function Difference'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Size'((unresolved BAG`Bag) -> nat)export function Intersection'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function SeqToBag'(seq of ((unresolved BAG`Elem)) -> (unresolved BAG`Bag))export value baga, bagb'(unresolved BAG`Bag)definitionsstatic private Elem = (<A> | <B> | <C> | <D> | <E>)static private Bag = map (Elem) to (nat1)Min' (nat * nat -> nat)	Min(i, j) ==(if (i < j)then ielse j)Max' (nat * nat -> nat)	Max(i, j) ==(if (i > j)then ielse j)AuxSeqToBag' (seq of (Elem) * Bag -> Bag)	AuxSeqToBag(s, b) ==(cases s 'case [] -> b,case [e] ^ rest -> AuxSeqToBag(rest, Add(e, b))end)LenPar1' (seq of (Elem) * Bag -> nat)	LenPar1(list, -) ==(len list)Empty' (() -> Bag)	Empty() =={}Add' (Elem * Bag -> Bag)	Add(e, b) ==(if (e in set (dom b))then (b ++ {e |-> (b(e) + 1)})else (b ++ {e |-> 1}))Remove' (Elem * Bag -> Bag)	Remove(e, b) ==(if (e in set (dom b))then (if (b(e) = 1)then ({e} <-' b)else (b ++ {e |-> (b(e) - 1)}))else b)Count' (Elem * Bag -> nat)	Count(e, b) ==(if (e in set (dom b))then b(e)else 0)In' (Elem * Bag -> bool)	In(e, b) ==(e in set (dom b))Join' (Bag * Bag -> Bag)	Join(b1, b2) =={e |-> Max(Count(e, b1), Count(e, b2)) | e in set ((dom b1) union (dom b2))}Union' (Bag * Bag -> Bag)	Union(b1, b2) =={e |-> (Count(e, b1) + Count(e, b2)) | e in set ((dom b1) union (dom b2))}SubBag' (Bag * Bag -> bool)	SubBag(b1, b2) ==(forall e in set (dom b1) & (Count(e, b1) <= Count(e, b2)))Difference' (Bag * Bag -> Bag)	Difference(b1, b2) =={e |-> (Count(e, b1) - Count(e, b2)) | e in set (dom b1) & (Count(e, b1) > Count(e, b2))}Size' (Bag -> nat)	Size(b) ==(if (b = {})then 0else let e in set (dom b) in (b(e) + Size(({e} <-' b))))CardDom' (Bag -> nat)	CardDom(b) ==(card (dom b))Intersection' (Bag * Bag -> Bag)	Intersection(b1, b2) =={e |-> Min(Count(e, b1), Count(e, b2)) | e in set ((dom b1) inter (dom b2))}SeqToBag' (seq of (Elem) -> Bag)	SeqToBag(s) ==AuxSeqToBag(s, Empty())static private baga'Bag = {<A> |-> 3, <B> |-> 2, <C> |-> 4}static private bagb'Bag = {<A> |-> 1, <C> |-> 5, <D> |-> 4, <E> |-> 1}end BAG, module BARimportsfrom BAGimport type Bagimport type Elem = (<A> | <B> | <C> | <D> | <E>)import function Empty'(() -> Bag)import function Add'(Elem * Bag -> Bag)import function Remove'(Elem * Bag -> Bag)import function Count'(Elem * Bag -> nat)import function In'(Elem * Bag -> bool)import function Join'(Bag * Bag -> Bag)import function Union'(Bag * Bag -> Bag)import function SubBag'(Bag * Bag -> bool)import function Difference'(Bag * Bag -> Bag)import function Size'(Bag -> nat)import function Intersection'(Bag * Bag -> Bag)import function SeqToBag'(seq of (Elem) -> Bag)import value 'Bagimport value 'Bagexportsexport alldefinitionsstatic private Drink = Elemstatic private Cellar = Bagstatic private Bar = Bagstatic private Supplier = seq of (char)static private Pub = (Cellar * Bar)static private BarLevel = Bagstatic private CellarLevel = Bagstatic private Stock = Bagstatic private Order = BagBuyStock' (map (Supplier) to (Stock) * Supplier * Order * Pub -> Pub)	BuyStock(supps, s, stock, mk_(c, r)) ==mk_(BAG`Union(c, stock), r)	pre ((s in set (dom supps)) and BAG`SubBag(stock, supps(s)))RestockBar' (Pub * BarLevel -> Pub)	RestockBar(mk_(c, r), bl) ==let missing'Bag = BAG`Difference(bl, r) in let can_restock'Bag = BAG`Intersection(missing, c) in mk_(BAG`Difference(c, can_restock), BAG`Union(r, can_restock))Round' (seq of (Drink) * Pub -> Pub)	Round(sold, mk_(c, r)) ==mk_(c, BAG`Difference(r, BAG`SeqToBag(sold)))	pre BAG`SubBag(BAG`SeqToBag(sold), r)RestockCellar' (CellarLevel * Pub * map (Supplier) to (Stock) -> Pub)	RestockCellar(cl, mk_(c, r), sb) ==(if (sb = {})then mk_(c, r)else let s in set (dom sb) in let missing'Bag = BAG`Difference(cl, c) in (if (BAG`Size(missing) > 0)then let can_restock'Bag = BAG`Intersection(missing, sb(s)) in RestockCellar(cl, mk_(BAG`Union(c, can_restock), r), ({s} <-' sb))else mk_(c, r)))CardCellar' (CellarLevel * Pub * map (Supplier) to (Stock) -> nat)	CardCellar(-, -, sb) ==(card (dom sb))Drink1' (Drink * Pub -> Pub)	Drink1(dr, mk_(c, r)) ==mk_(c, BAG`Remove(dr, r))	pre BAG`In(dr, r)Disaster' (Pub -> bool)	Disaster(mk_(c, r)) ==((c = BAG`Empty()) and (r = BAG`Empty()))Unwanted' (Drink * Pub -> Pub)	Unwanted(dr, mk_(c, r)) ==mk_(c, BAG`Add(dr, r))HighestStock' (map (Supplier) to (Stock) -> Bag)	HighestStock(supps) ==(if ((dom supps) = {})then BAG`Empty()else let s in set (dom supps) in BAG`Join(supps(s), HighestStock(({s} <-' supps))))CardDom' (map (Supplier) to (Stock) -> nat)	CardDom(m) ==(card (dom m))TotalDrinks' (Pub -> nat)	TotalDrinks(mk_(c, r)) ==(BAG`Size(c) + BAG`Size(r))static private cellarlevel1'map ((<A> | <B> | <C>)) to (nat1) = {<A> |-> 5, <B> |-> 5, <C> |-> 3}static private barlevel1'map ((<A> | <B> | <C>)) to (nat1) = {<A> |-> 2, <B> |-> 2, <C> |-> 5}static private cellar1'map ((<A> | <B> | <C>)) to (nat1) = {<A> |-> 8, <B> |-> 5, <C> |-> 4}static private cellar2'map ((<B> | <C>)) to (nat1) = {<B> |-> 1, <C> |-> 4}static private bar1'map ((<A> | <B> | <C>)) to (nat1) = {<A> |-> 2, <B> |-> 3, <C> |-> 6}static private bar2'map ((<A> | <C>)) to (nat1) = {<A> |-> 3, <C> |-> 2}static private bar3'map ((<A> | <B>)) to (nat1) = {<A> |-> 3, <B> |-> 3}static private pub1'(map ((<A> | <B> | <C>)) to (nat1) * map ((<A> | <B> | <C>)) to (nat1)) = mk_(cellar1, bar1)static private pub2'(map ((<A> | <B> | <C>)) to (nat1) * map ((<A> | <C>)) to (nat1)) = mk_(cellar1, bar2)static private pub3'(map ((<B> | <C>)) to (nat1) * map ((<A> | <B> | <C>)) to (nat1)) = mk_(cellar2, bar1)static private pub4'(map ((<B> | <C>)) to (nat1) * map ((<A> | <C>)) to (nat1)) = mk_(cellar2, bar2)static private pub5'(map ((<A> | <B> | <C>)) to (nat1) * map ((<A> | <B>)) to (nat1)) = mk_(cellar1, bar3)static private supps1'map (seq1 of (char)) to ((map ((<B> | <C>)) to (nat1) | map (<A>) to (nat1))) = {"Fizz" |-> {<A> |-> 10}, "Real" |-> {<B> |-> 10, <C> |-> 2}, "Scrumpy" |-> {<B> |-> 1, <C> |-> 10}}static private supps2'map (seq1 of (char)) to ((map ((<B> | <C>)) to (nat1) | map (<A>) to (nat1))) = {"Fizz" |-> {<A> |-> 10}, "Real" |-> {<B> |-> 1, <C> |-> 5}, "Scrumpy" |-> {<B> |-> 1, <C> |-> 10}}end BAR, module BAGTESTimportsfrom BAGimport allexportsexport alldefinitionsTestBagAll' (() -> bool)	TestBagAll() ==let b1'bool = TestAdd1(), b2'bool = TestAdd2(), b3'bool = TestCount1(), b4'bool = TestCount2(), b5'bool = TestDifference(), b6'bool = TestEmpty(), b7'bool = TestIn1(), b8'bool = TestIn2(), b9'bool = TestIntersection(), b10'bool = TestJoin(), b11'bool = TestRemove1(), b12'bool = TestRemove2(), b13'bool = TestRemove3(), b14'bool = TestSeqToBag(), b15'bool = TestSize(), b16'bool = TestSubBag1(), b17'bool = TestSubBag2(), b18'bool = TestUnion() in (b1 and (b2 and (b3 and (b4 and (b5 and (b6 and (b7 and (b8 and (b9 and (b10 and (b11 and (b12 and (b13 and (b14 and (b15 and (b16 and (b17 and b18)))))))))))))))))TestAdd1' (() -> bool)	TestAdd1() ==(BAG`Add(<C>, BAG`baga) = {<A> |-> 3, <B> |-> 2, <C> |-> 5})TestAdd2' (() -> bool)	TestAdd2() ==(BAG`Add(<D>, BAG`baga) = {<A> |-> 3, <B> |-> 2, <C> |-> 4, <D> |-> 1})TestCount1' (() -> bool)	TestCount1() ==(BAG`Count(<D>, BAG`baga) = 0)TestCount2' (() -> bool)	TestCount2() ==(BAG`Count(<D>, BAG`bagb) = 4)TestDifference' (() -> bool)	TestDifference() ==(BAG`Difference(BAG`baga, BAG`bagb) = {<A> |-> 2, <B> |-> 2})TestEmpty' (() -> bool)	TestEmpty() ==(BAG`Empty() = {})TestIn1' (() -> bool)	TestIn1() ==BAG`In(<A>, BAG`baga)TestIn2' (() -> bool)	TestIn2() ==(not BAG`In(<D>, BAG`baga))TestIntersection' (() -> bool)	TestIntersection() ==(BAG`Intersection(BAG`baga, BAG`bagb) = {<A> |-> 1, <C> |-> 4})TestJoin' (() -> bool)	TestJoin() ==(BAG`Join(BAG`baga, BAG`bagb) = {<A> |-> 3, <B> |-> 2, <C> |-> 5, <D> |-> 4, <E> |-> 1})TestRemove1' (() -> bool)	TestRemove1() ==(BAG`Remove(<A>, BAG`bagb) = {<C> |-> 5, <D> |-> 4, <E> |-> 1})TestRemove2' (() -> bool)	TestRemove2() ==(BAG`Remove(<A>, BAG`baga) = {<A> |-> 2, <B> |-> 2, <C> |-> 4})TestRemove3' (() -> bool)	TestRemove3() ==(BAG`Remove(<D>, BAG`baga) = BAG`baga)TestSeqToBag' (() -> bool)	TestSeqToBag() ==(BAG`SeqToBag([<A>, <A>, <B>, <C>, <A>]) = {<A> |-> 3, <B> |-> 1, <C> |-> 1})TestSize' (() -> bool)	TestSize() ==(BAG`Size(BAG`baga) = 9)TestSubBag1' (() -> bool)	TestSubBag1() ==(not BAG`SubBag(BAG`baga, BAG`bagb))TestSubBag2' (() -> bool)	TestSubBag2() ==BAG`SubBag({<A> |-> 2, <C> |-> 4}, BAG`baga)TestUnion' (() -> bool)	TestUnion() ==(BAG`Union(BAG`baga, BAG`bagb) = {<A> |-> 4, <B> |-> 2, <C> |-> 9, <D> |-> 4, <E> |-> 1})end BAGTEST
