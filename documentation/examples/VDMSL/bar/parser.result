RESULT:result:-1:-1,-1:module BAGTESTimportsfrom BAGimport allexportsexport alldefinitionsTestBagAll' (() -> bool)	TestBagAll() ==let b1 = TestAdd1(), b2 = TestAdd2(), b3 = TestCount1(), b4 = TestCount2(), b5 = TestDifference(), b6 = TestEmpty(), b7 = TestIn1(), b8 = TestIn2(), b9 = TestIntersection(), b10 = TestJoin(), b11 = TestRemove1(), b12 = TestRemove2(), b13 = TestRemove3(), b14 = TestSeqToBag(), b15 = TestSize(), b16 = TestSubBag1(), b17 = TestSubBag2(), b18 = TestUnion() in (b1 and (b2 and (b3 and (b4 and (b5 and (b6 and (b7 and (b8 and (b9 and (b10 and (b11 and (b12 and (b13 and (b14 and (b15 and (b16 and (b17 and b18)))))))))))))))))TestAdd1' (() -> bool)	TestAdd1() ==(BAG`Add(<C>, BAG`baga) = {<A> |-> 3, <B> |-> 2, <C> |-> 5})TestAdd2' (() -> bool)	TestAdd2() ==(BAG`Add(<D>, BAG`baga) = {<A> |-> 3, <B> |-> 2, <C> |-> 4, <D> |-> 1})TestCount1' (() -> bool)	TestCount1() ==(BAG`Count(<D>, BAG`baga) = 0)TestCount2' (() -> bool)	TestCount2() ==(BAG`Count(<D>, BAG`bagb) = 4)TestDifference' (() -> bool)	TestDifference() ==(BAG`Difference(BAG`baga, BAG`bagb) = {<A> |-> 2, <B> |-> 2})TestEmpty' (() -> bool)	TestEmpty() ==(BAG`Empty() = {})TestIn1' (() -> bool)	TestIn1() ==BAG`In(<A>, BAG`baga)TestIn2' (() -> bool)	TestIn2() ==(not BAG`In(<D>, BAG`baga))TestIntersection' (() -> bool)	TestIntersection() ==(BAG`Intersection(BAG`baga, BAG`bagb) = {<A> |-> 1, <C> |-> 4})TestJoin' (() -> bool)	TestJoin() ==(BAG`Join(BAG`baga, BAG`bagb) = {<A> |-> 3, <B> |-> 2, <C> |-> 5, <D> |-> 4, <E> |-> 1})TestRemove1' (() -> bool)	TestRemove1() ==(BAG`Remove(<A>, BAG`bagb) = {<C> |-> 5, <D> |-> 4, <E> |-> 1})TestRemove2' (() -> bool)	TestRemove2() ==(BAG`Remove(<A>, BAG`baga) = {<A> |-> 2, <B> |-> 2, <C> |-> 4})TestRemove3' (() -> bool)	TestRemove3() ==(BAG`Remove(<D>, BAG`baga) = BAG`baga)TestSeqToBag' (() -> bool)	TestSeqToBag() ==(BAG`SeqToBag([<A>, <A>, <B>, <C>, <A>]) = {<A> |-> 3, <B> |-> 1, <C> |-> 1})TestSize' (() -> bool)	TestSize() ==(BAG`Size(BAG`baga) = 9)TestSubBag1' (() -> bool)	TestSubBag1() ==(not BAG`SubBag(BAG`baga, BAG`bagb))TestSubBag2' (() -> bool)	TestSubBag2() ==BAG`SubBag({<A> |-> 2, <C> |-> 4}, BAG`baga)TestUnion' (() -> bool)	TestUnion() ==(BAG`Union(BAG`baga, BAG`bagb) = {<A> |-> 4, <B> |-> 2, <C> |-> 9, <D> |-> 4, <E> |-> 1})end BAGTEST, module BAGexportsexport type struct Bagexport type struct Elemexport function Empty'(() -> (unresolved BAG`Bag))export function Add'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Remove'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Count'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> nat)export function In'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> bool)export function Join'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Union'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function SubBag'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> bool)export function Difference'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function Size'((unresolved BAG`Bag) -> nat)export function Intersection'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))export function SeqToBag'(seq of ((unresolved BAG`Elem)) -> (unresolved BAG`Bag))export value baga, bagb'(unresolved BAG`Bag)definitionsstatic private Elem = (<A> | <B> | <C> | <D> | <E>)static private Bag = map ((unresolved BAG`Elem)) to (nat1)Min' (nat * nat -> nat)	Min(i, j) ==(if (i < j)then ielse j)Max' (nat * nat -> nat)	Max(i, j) ==(if (i > j)then ielse j)AuxSeqToBag' (seq of ((unresolved BAG`Elem)) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	AuxSeqToBag(s, b) ==(cases s 'case [] -> b,case [e] ^ rest -> AuxSeqToBag(rest, Add(e, b))end)LenPar1' (seq of ((unresolved BAG`Elem)) * (unresolved BAG`Bag) -> nat)	LenPar1(list, -) ==(len list)Empty' (() -> (unresolved BAG`Bag))	Empty() =={}Add' ((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	Add(e, b) ==(if (e in set (dom b))then (b ++ {e |-> (b(e) + 1)})else (b ++ {e |-> 1}))Remove' ((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	Remove(e, b) ==(if (e in set (dom b))then (if (b(e) = 1)then ({e} <-' b)else (b ++ {e |-> (b(e) - 1)}))else b)Count' ((unresolved BAG`Elem) * (unresolved BAG`Bag) -> nat)	Count(e, b) ==(if (e in set (dom b))then b(e)else 0)In' ((unresolved BAG`Elem) * (unresolved BAG`Bag) -> bool)	In(e, b) ==(e in set (dom b))Join' ((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	Join(b1, b2) =={e |-> Max(Count(e, b1), Count(e, b2)) | e in set ((dom b1) union (dom b2))}Union' ((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	Union(b1, b2) =={e |-> (Count(e, b1) + Count(e, b2)) | e in set ((dom b1) union (dom b2))}SubBag' ((unresolved BAG`Bag) * (unresolved BAG`Bag) -> bool)	SubBag(b1, b2) ==(forall e in set (dom b1) & (Count(e, b1) <= Count(e, b2)))Difference' ((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	Difference(b1, b2) =={e |-> (Count(e, b1) - Count(e, b2)) | e in set (dom b1) & (Count(e, b1) > Count(e, b2))}Size' ((unresolved BAG`Bag) -> nat)	Size(b) ==(if (b = {})then 0else let e in set (dom b) in (b(e) + Size(({e} <-' b))))CardDom' ((unresolved BAG`Bag) -> nat)	CardDom(b) ==(card (dom b))Intersection' ((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))	Intersection(b1, b2) =={e |-> Min(Count(e, b1), Count(e, b2)) | e in set ((dom b1) inter (dom b2))}SeqToBag' (seq of ((unresolved BAG`Elem)) -> (unresolved BAG`Bag))	SeqToBag(s) ==AuxSeqToBag(s, Empty())static private baga'(unresolved BAG`Bag) = {<A> |-> 3, <B> |-> 2, <C> |-> 4}static private bagb'(unresolved BAG`Bag) = {<A> |-> 1, <C> |-> 5, <D> |-> 4, <E> |-> 1}end BAG, module BARimportsfrom BAGimport type Bagimport type Elem = (<A> | <B> | <C> | <D> | <E>)import function Empty'(() -> (unresolved BAG`Bag))import function Add'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))import function Remove'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))import function Count'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> nat)import function In'((unresolved BAG`Elem) * (unresolved BAG`Bag) -> bool)import function Join'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))import function Union'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))import function SubBag'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> bool)import function Difference'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))import function Size'((unresolved BAG`Bag) -> nat)import function Intersection'((unresolved BAG`Bag) * (unresolved BAG`Bag) -> (unresolved BAG`Bag))import function SeqToBag'(seq of ((unresolved BAG`Elem)) -> (unresolved BAG`Bag))import value '(unresolved BAG`Bag)import value '(unresolved BAG`Bag)exportsexport alldefinitionsstatic private Drink = (unresolved BAG`Elem)static private Cellar = (unresolved BAG`Bag)static private Bar = (unresolved BAG`Bag)static private Supplier = seq of (char)static private Pub = ((unresolved BAR`Cellar) * (unresolved BAR`Bar))static private BarLevel = (unresolved BAG`Bag)static private CellarLevel = (unresolved BAG`Bag)static private Stock = (unresolved BAG`Bag)static private Order = (unresolved BAG`Bag)BuyStock' (map ((unresolved BAR`Supplier)) to ((unresolved BAR`Stock)) * (unresolved BAR`Supplier) * (unresolved BAR`Order) * (unresolved BAR`Pub) -> (unresolved BAR`Pub))	BuyStock(supps, s, stock, mk_(c, r)) ==mk_(BAG`Union(c, stock), r)	pre ((s in set (dom supps)) and BAG`SubBag(stock, supps(s)))RestockBar' ((unresolved BAR`Pub) * (unresolved BAR`BarLevel) -> (unresolved BAR`Pub))	RestockBar(mk_(c, r), bl) ==let missing = BAG`Difference(bl, r) in let can_restock = BAG`Intersection(missing, c) in mk_(BAG`Difference(c, can_restock), BAG`Union(r, can_restock))Round' (seq of ((unresolved BAR`Drink)) * (unresolved BAR`Pub) -> (unresolved BAR`Pub))	Round(sold, mk_(c, r)) ==mk_(c, BAG`Difference(r, BAG`SeqToBag(sold)))	pre BAG`SubBag(BAG`SeqToBag(sold), r)RestockCellar' ((unresolved BAR`CellarLevel) * (unresolved BAR`Pub) * map ((unresolved BAR`Supplier)) to ((unresolved BAR`Stock)) -> (unresolved BAR`Pub))	RestockCellar(cl, mk_(c, r), sb) ==(if (sb = {})then mk_(c, r)else let s in set (dom sb) in let missing = BAG`Difference(cl, c) in (if (BAG`Size(missing) > 0)then let can_restock = BAG`Intersection(missing, sb(s)) in RestockCellar(cl, mk_(BAG`Union(c, can_restock), r), ({s} <-' sb))else mk_(c, r)))CardCellar' ((unresolved BAR`CellarLevel) * (unresolved BAR`Pub) * map ((unresolved BAR`Supplier)) to ((unresolved BAR`Stock)) -> nat)	CardCellar(-, -, sb) ==(card (dom sb))Drink1' ((unresolved BAR`Drink) * (unresolved BAR`Pub) -> (unresolved BAR`Pub))	Drink1(dr, mk_(c, r)) ==mk_(c, BAG`Remove(dr, r))	pre BAG`In(dr, r)Disaster' ((unresolved BAR`Pub) -> bool)	Disaster(mk_(c, r)) ==((c = BAG`Empty()) and (r = BAG`Empty()))Unwanted' ((unresolved BAR`Drink) * (unresolved BAR`Pub) -> (unresolved BAR`Pub))	Unwanted(dr, mk_(c, r)) ==mk_(c, BAG`Add(dr, r))HighestStock' (map ((unresolved BAR`Supplier)) to ((unresolved BAR`Stock)) -> (unresolved BAG`Bag))	HighestStock(supps) ==(if ((dom supps) = {})then BAG`Empty()else let s in set (dom supps) in BAG`Join(supps(s), HighestStock(({s} <-' supps))))CardDom' (map ((unresolved BAR`Supplier)) to ((unresolved BAR`Stock)) -> nat)	CardDom(m) ==(card (dom m))TotalDrinks' ((unresolved BAR`Pub) -> nat)	TotalDrinks(mk_(c, r)) ==(BAG`Size(c) + BAG`Size(r))static private cellarlevel1 = {<A> |-> 5, <B> |-> 5, <C> |-> 3}static private barlevel1 = {<A> |-> 2, <B> |-> 2, <C> |-> 5}static private cellar1 = {<A> |-> 8, <B> |-> 5, <C> |-> 4}static private cellar2 = {<B> |-> 1, <C> |-> 4}static private bar1 = {<A> |-> 2, <B> |-> 3, <C> |-> 6}static private bar2 = {<A> |-> 3, <C> |-> 2}static private bar3 = {<A> |-> 3, <B> |-> 3}static private pub1 = mk_(cellar1, bar1)static private pub2 = mk_(cellar1, bar2)static private pub3 = mk_(cellar2, bar1)static private pub4 = mk_(cellar2, bar2)static private pub5 = mk_(cellar1, bar3)static private supps1 = {"Fizz" |-> {<A> |-> 10}, "Real" |-> {<B> |-> 10, <C> |-> 2}, "Scrumpy" |-> {<B> |-> 1, <C> |-> 10}}static private supps2 = {"Fizz" |-> {<A> |-> 10}, "Real" |-> {<B> |-> 1, <C> |-> 5}, "Scrumpy" |-> {<B> |-> 1, <C> |-> 10}}end BAR
