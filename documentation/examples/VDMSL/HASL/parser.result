RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private HAInputs = seq of ((unresolved DEFAULT`HAInput))static private HAInput = ((unresolved DEFAULT`Change) * (unresolved DEFAULT`TargetTemp) * (unresolved DEFAULT`CurrentTemp) * (unresolved DEFAULT`TargetHumid) * (unresolved DEFAULT`CurrentHumid))static private Change = boolstatic private TargetTemp = nat	inv num == (num <= 100)static private CurrentTemp = nat	inv num == (num <= 100)static private TargetHumid = nat	inv num == (num <= 100)static private CurrentHumid = nat	inv num == (num <= 100)static private HAOut = seq of ((unresolved DEFAULT`OutStep))static private OutStep = ((unresolved DEFAULT`EnvManipulation) * (unresolved DEFAULT`AbsTime))static private AbsTime = natstatic private EnvManipulation = (<CloseWindow> | <DecTemp> | <IncTemp> | <LeaveTemp> | <OpenWindow>)static private TempChangeDuration'nat = 2static private HumidChangeDuration'nat = 4static private StepLength'nat = 1HomeAutomation' ((unresolved DEFAULT`HAInputs) -> (unresolved DEFAULT`HAOut))	HomeAutomation(haInputs) ==HA(haInputs, [], 0)HA' ((unresolved DEFAULT`HAInputs) * (unresolved DEFAULT`HAOut) * nat -> (unresolved DEFAULT`HAOut))	HA(haInputs, outputSoFar, curTime) ==(if (haInputs = [])then outputSoFarelse let mk_(change, targetTemp, currentTemp, targetHumid, currentHumid) = (hd haInputs), rest = (tl haInputs), nextTime = (curTime + StepLength) in (if (outputSoFar <> [])then let mk_(-, timeOfLastInput) = outputSoFar((len outputSoFar)) in (if ((curTime <= timeOfLastInput) and change)then let interruptedOutput = InterruptOutput(outputSoFar, curTime), newOutput = CounterOutput(interruptedOutput, curTime) in HA(rest, AddOutput(targetTemp, currentTemp, targetHumid, currentHumid, curTime, newOutput), nextTime)else ChangeHA(haInputs, outputSoFar, curTime))else ChangeHA(haInputs, outputSoFar, curTime)))ChangeHA' ((unresolved DEFAULT`HAInputs) * (unresolved DEFAULT`HAOut) * (unresolved DEFAULT`AbsTime) -> (unresolved DEFAULT`HAOut))	ChangeHA(haInputs, outputSoFar, curTime) ==let mk_(change, targetTemp, currentTemp, targetHumid, currentHumid) = (hd haInputs), rest = (tl haInputs), nextTime = (curTime + StepLength) in (if changethen HA(rest, AddOutput(targetTemp, currentTemp, targetHumid, currentHumid, curTime, outputSoFar), nextTime)else HA(rest, outputSoFar, nextTime))AddOutput' (nat * nat * nat * nat * nat * seq of ((unresolved DEFAULT`OutStep)) -> seq of ((unresolved DEFAULT`OutStep)))	AddOutput(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar) ==(if (targetHumid <> curHumid)then HumidChanged(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar)elseif (targetTemp <> curTemp)then TempChanged(targetTemp, curTemp, curTime, outputSoFar)else outputSoFar)TempChanged' (nat * nat * nat * seq of ((unresolved DEFAULT`OutStep)) -> seq of ((unresolved DEFAULT`OutStep)))	TempChanged(targetTemp, curTemp, curTime, outputSoFar) ==let nextTime = (curTime + ((abs (curTemp - targetTemp)) * TempChangeDuration)), action = (if (curTemp > targetTemp)then <DecTemp>else <IncTemp>) in ((outputSoFar ^ [mk_(action, curTime)]) ^ [mk_(<LeaveTemp>, nextTime)])HumidChanged' (nat * nat * nat * nat * nat * seq of ((unresolved DEFAULT`OutStep)) -> seq of ((unresolved DEFAULT`OutStep)))	HumidChanged(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar) ==let tempChanged = (((curHumid - targetHumid) * HumidChangeDuration) / TempChangeDuration), action = (if ((curTemp - tempChanged) > targetTemp)then <DecTemp>else <IncTemp>), timeChange = (curTime + ((curHumid - targetHumid) * HumidChangeDuration)) in ((outputSoFar ^ [mk_(<OpenWindow>, curTime)]) ^ (if ((curTemp - tempChanged) <> targetTemp)then [mk_(<CloseWindow>, timeChange), mk_(action, timeChange), mk_(<LeaveTemp>, (timeChange + (((abs (curTemp - targetTemp)) - tempChanged) * TempChangeDuration)))]else [mk_(<CloseWindow>, timeChange)]))InterruptOutput' (seq of ((unresolved DEFAULT`OutStep)) * nat -> seq of ((unresolved DEFAULT`OutStep)))	InterruptOutput(output, curTime) ==[output(i) | i in set (inds output) & let mk_(-, t) = output(i) in (t <= curTime)]CounterOutput' (seq of ((unresolved DEFAULT`OutStep)) * nat -> seq of ((unresolved DEFAULT`OutStep)))	CounterOutput(output, curTime) ==let mk_(lastOutput, -) = output((len output)) in (if (lastOutput = <OpenWindow>)then (output ^ [mk_(<CloseWindow>, curTime)])elseif ((lastOutput = <IncTemp>) or (lastOutput = <DecTemp>))then (output ^ [mk_(<LeaveTemp>, curTime)])else output)end DEFAULT
