WARNING:HA.vdmsl:5012:40,3:Recursive function has no measure.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private HAInputs = seq of (HAInput)static private HAInput = (Change * TargetTemp * CurrentTemp * TargetHumid * CurrentHumid)static private Change = boolstatic private TargetTemp = nat	inv num == (num <= 100)static private CurrentTemp = nat	inv num == (num <= 100)static private TargetHumid = nat	inv num == (num <= 100)static private CurrentHumid = nat	inv num == (num <= 100)static private HAOut = seq of (OutStep)static private OutStep = (EnvManipulation * AbsTime)static private AbsTime = natstatic private EnvManipulation = (<CloseWindow> | <DecTemp> | <IncTemp> | <LeaveTemp> | <OpenWindow>)static private TempChangeDuration'nat = 2static private HumidChangeDuration'nat = 4static private StepLength'nat = 1HomeAutomation' (HAInputs -> HAOut)	HomeAutomation(haInputs) ==HA(haInputs, [], 0)HA' (HAInputs * HAOut * nat -> HAOut)	HA(haInputs, outputSoFar, curTime) ==(if (haInputs = [])then outputSoFarelse let mk_(change, targetTemp, currentTemp, targetHumid, currentHumid)'HAInput = (hd haInputs), rest'HAInputs = (tl haInputs), nextTime'nat = (curTime + StepLength) in (if (outputSoFar <> [])then let mk_(-, timeOfLastInput)'OutStep = outputSoFar((len outputSoFar)) in (if ((curTime <= timeOfLastInput) and change)then let interruptedOutput'seq of (OutStep) = InterruptOutput(outputSoFar, curTime), newOutput'seq of (OutStep) = CounterOutput(interruptedOutput, curTime) in HA(rest, AddOutput(targetTemp, currentTemp, targetHumid, currentHumid, curTime, newOutput), nextTime)else ChangeHA(haInputs, outputSoFar, curTime))else ChangeHA(haInputs, outputSoFar, curTime)))ChangeHA' (HAInputs * HAOut * AbsTime -> HAOut)	ChangeHA(haInputs, outputSoFar, curTime) ==let mk_(change, targetTemp, currentTemp, targetHumid, currentHumid)'HAInput = (hd haInputs), rest'HAInputs = (tl haInputs), nextTime'nat = (curTime + StepLength) in (if changethen HA(rest, AddOutput(targetTemp, currentTemp, targetHumid, currentHumid, curTime, outputSoFar), nextTime)else HA(rest, outputSoFar, nextTime))AddOutput' (nat * nat * nat * nat * nat * seq of (OutStep) -> seq of (OutStep))	AddOutput(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar) ==(if (targetHumid <> curHumid)then HumidChanged(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar)elseif (targetTemp <> curTemp)then TempChanged(targetTemp, curTemp, curTime, outputSoFar)else outputSoFar)TempChanged' (nat * nat * nat * seq of (OutStep) -> seq of (OutStep))	TempChanged(targetTemp, curTemp, curTime, outputSoFar) ==let nextTime'nat = (curTime + ((abs (curTemp - targetTemp)) * TempChangeDuration)), action'(<DecTemp> | <IncTemp>) = (if (curTemp > targetTemp)then <DecTemp>else <IncTemp>) in ((outputSoFar ^ [mk_(action, curTime)]) ^ [mk_(<LeaveTemp>, nextTime)])HumidChanged' (nat * nat * nat * nat * nat * seq of (OutStep) -> seq of (OutStep))	HumidChanged(targetTemp, curTemp, targetHumid, curHumid, curTime, outputSoFar) ==let tempChanged'real = (((curHumid - targetHumid) * HumidChangeDuration) / TempChangeDuration), action'(<DecTemp> | <IncTemp>) = (if ((curTemp - tempChanged) > targetTemp)then <DecTemp>else <IncTemp>), timeChange'int = (curTime + ((curHumid - targetHumid) * HumidChangeDuration)) in ((outputSoFar ^ [mk_(<OpenWindow>, curTime)]) ^ (if ((curTemp - tempChanged) <> targetTemp)then [mk_(<CloseWindow>, timeChange), mk_(action, timeChange), mk_(<LeaveTemp>, (timeChange + (((abs (curTemp - targetTemp)) - tempChanged) * TempChangeDuration)))]else [mk_(<CloseWindow>, timeChange)]))InterruptOutput' (seq of (OutStep) * nat -> seq of (OutStep))	InterruptOutput(output, curTime) ==[output(i) | i in set (inds output) & let mk_(-, t)'OutStep = output(i) in (t <= curTime)]CounterOutput' (seq of (OutStep) * nat -> seq of (OutStep))	CounterOutput(output, curTime) ==let mk_(lastOutput, -)'OutStep = output((len output)) in (if (lastOutput = <OpenWindow>)then (output ^ [mk_(<CloseWindow>, curTime)])elseif ((lastOutput = <IncTemp>) or (lastOutput = <DecTemp>))then (output ^ [mk_(<LeaveTemp>, curTime)])else output)end DEFAULT
