RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Tracker = compose Tracker of containers'ContainerInfo, phases'PhaseInfo end	inv mk_Tracker(containers, phases) == (Consistent(containers, phases) and (PhasesDistinguished(phases) and MaterialSafe(containers, phases)))static private ContainerInfo = map (ContainerId) to (Container)static private PhaseInfo = map (PhaseId) to (Phase)static private Container = compose Container of fiss_mass'real, material'Material endstatic private Phase = compose Phase of contents'set of (ContainerId), expected_materials'set of (Material), capacity'nat end	inv p == (((card (p.contents)) <= (p.capacity)) and ((p.expected_materials) <> {}))static private ContainerId = tokenstatic private PhaseId = tokenstatic private Material = tokenIntroduce' (Tracker * ContainerId * real * Material -> Tracker)	Introduce(trk, cid, quan, mat) ==mk_Tracker(((trk.containers) munion {cid |-> mk_Container(quan, mat)}), (trk.phases))	pre (cid not in set (dom (trk.containers)))Permission' (Tracker * ContainerId * PhaseId -> bool)	Permission(mk_Tracker(containers, phases), cid, dest) ==((cid in set (dom containers)) and ((dest in set (dom phases)) and (((card (phases(dest).contents)) < (phases(dest).capacity)) and ((containers(cid).material) in set (phases(dest).expected_materials)))))Remove' (Tracker * ContainerId * PhaseId -> Tracker)	Remove(mk_Tracker(containers, phases), cid, source) ==let pha'Phase = mk_Phase(((phases(source).contents) \ {cid}), (phases(source).expected_materials), (phases(source).capacity)) in mk_Tracker(containers, (phases ++ {source |-> pha}))	pre ((source in set (dom phases)) and (cid in set (phases(source).contents)))Move' (Tracker * ContainerId * PhaseId * PhaseId -> Tracker)	Move(trk, cid, ptoid, pfromid) ==let cont'Phase = (trk.phases)(ptoid) in let pha'Phase = mk_Phase(((cont.contents) union {cid}), (cont.expected_materials), (cont.capacity)) in mk_Tracker((trk.containers), ((Remove(trk, cid, pfromid).phases) ++ {ptoid |-> pha}))	pre (Permission(trk, cid, ptoid) and pre_Remove(trk, cid, pfromid))Delete' (Tracker * ContainerId * PhaseId -> Tracker)	Delete(tkr, cid, source) ==mk_Tracker(({cid} <-' (tkr.containers)), (Remove(tkr, cid, source).phases))	pre pre_Remove(tkr, cid, source)Consistent' (ContainerInfo * PhaseInfo -> bool)	Consistent(containers, phases) ==(forall ph in set (rng phases) & ((ph.contents) subset (dom containers)))PhasesDistinguished' (PhaseInfo -> bool)	PhasesDistinguished(phases) ==(not (exists [p1, p2 in set (dom phases)] & ((p1 <> p2) and (((phases(p1).contents) inter (phases(p2).contents)) <> {}))))MaterialSafe' (ContainerInfo * PhaseInfo -> bool)	MaterialSafe(containers, phases) ==(forall ph in set (rng phases) & (forall cid in set (ph.contents) & ((cid in set (dom containers)) and ((containers(cid).material) in set (ph.expected_materials)))))static private glass'token = mk_token("Glass")static private liquid'token = mk_token("liquid")static private metal'token = mk_token("metal")static private plastic'token = mk_token("plastic")static private all_material'set of (token) = {glass, liquid, metal, plastic}static private unpacking_inital'Phase = mk_Phase({}, all_material, 5)static private sorting_inital'Phase = mk_Phase({}, all_material, 6)static private assay_inital'Phase = mk_Phase({}, all_material, 5)static private compaction_inital'Phase = mk_Phase({}, {glass, metal, plastic}, 3)static private storage_inital'Phase = mk_Phase({}, {glass, metal, plastic}, 50)static private coninfo_inital'map (?) to (?) = {}static private cid1'ContainerId = mk_token(42)static private phases_inital'map (token) to (Phase) = {mk_token("Unpacking") |-> unpacking_inital, mk_token("Sorting") |-> sorting_inital, mk_token("Assay") |-> assay_inital, mk_token("Compaction") |-> compaction_inital, mk_token("Storage") |-> storage_inital}static private tracker_inital'Tracker = mk_Tracker(coninfo_inital, phases_inital)SetUp' (() -> Tracker)	SetUp() ==tracker_initalend DEFAULT
