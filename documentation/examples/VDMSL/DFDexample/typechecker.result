WARNING:dfdexample.vdmsl:5012:1303,16:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:1833,13:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:738,14:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:1212,11:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:638,13:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:1057,14:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:1132,11:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:198,12:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:1254,7:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5012:1113,7:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5000:1158,13:Definition 'out' not used.
WARNING:dfdexample.vdmsl:5012:23,10:Recursive function has no measure.
WARNING:dfdexample.vdmsl:5000:1604,3:Definition 'SA' not used.
WARNING:dfdexample.vdmsl:5000:1865,9:Definition 'Document' not used.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsTransHDFD' (HDFD * MSs * (<EXPL> | <IMPL>) -> set of (Module))	TransHDFD(hdfd, mss, style) ==let mainmod'Module = MakeDFDModule(hdfd, mss, style) in let mk_(-, -, -, dfdmap, -)'HDFD = hdfd in let mods'set of (Module) = (dunion {TransHDFD(dfd, mss, style) | [dfd in set (rng dfdmap)]}) in ({mainmod} union mods)MakeDFDModule' (HDFD * MSs * (<EXPL> | <IMPL>) -> Module)	MakeDFDModule(mk_(dfdid, dss, dfdtopo, dfdmap, dfdsig), mss, style) ==let i'Interface = MakeInterface(dfdid, dss, dfdtopo, dfdsig, dfdmap), defs'Definitions = MakeDefinitions(dfdid, dss, dfdtopo, dfdsig, mss, style) in mk_(ModIdConf(dfdid), i, defs)MakeInterface' (DFDId * DSs * DFDTopo * DFDSig * DFDMap -> Interface)	MakeInterface(dfdid, dss, dfdtopo, dfdsig, dfdmap) ==let tmimp'Import = MakeTypeModImp(dss, (dom dfdtopo)), dfdmimps'set of (Import) = MakeDFDModImps((dom dfdmap), dfdsig), exp'Export = MakeOpExp(dfdid, dfdsig(dfdid)) in mk_(({tmimp} union dfdmimps), exp)	pre (dfdid in set (dom dfdsig))MakeTypeModImp' (DSs * set of (FlowId) -> Import)	MakeTypeModImp(dss, fids) ==let tysigs'set of (TypeSig) = ({mk_TypeSig(DSIdConf(dsid)) | [dsid in set dss]} union {mk_TypeSig(FlowIdTypeConf(fid)) | [fid in set fids]}) in mk_(TypeModConf(), tysigs)MakeDFDModImps' (set of (DFDId) * DFDSig -> set of (Import))	MakeDFDModImps(dfdids, dfdsig) =={mk_(ModIdConf(id), {MakeOpSig(id, dfdsig(id))}) | [id in set dfdids]}	pre (dfdids subset (dom dfdsig))MakeOpExp' (DFDId * Signature -> Export)	MakeOpExp(dfdid, sig) =={MakeOpSig(dfdid, sig)}MakeOpSig' (DFDId * Signature -> OpSig)	MakeOpSig(dfdid, sig) ==let opty'OpType = MakeOpType(sig), opst'seq of (Id) = MakeOpState(sig) in mk_OpSig(OpIdConf(dfdid), opty, opst)MakeOpType' (Signature -> OpType)	MakeOpType(mk_(il, ol, -)) ==mk_OpType(MakeType(il), MakeType(ol))MakeType' (seq of (FlowId) -> [Type])	MakeType(fidl) ==(cases (len fidl) 'case 0 -> nil,case 1 -> FlowIdTypeConf((hd fidl))others mk_ProductType([FlowIdTypeConf(fidl(i)) | i in set (inds fidl)])end)MakeOpState' (Signature -> seq of (Id))	MakeOpState(mk_(-, -, sl)) ==[let mk_(s, -)'(StId * Mode) = sl(i) in StateVarConf(s) | i in set (inds sl)]MakeDefinitions' (DFDId * DSs * DFDTopo * DFDSig * MSs * (<EXPL> | <IMPL>) -> Definitions)	MakeDefinitions(dfdid, dss, dfdtopo, dfdsig, mss, style) ==let dst'[StateDef] = MakeState(dfdid, dss, CollectExtDFs(dfdtopo)), msdescs'set of (Definition) = MakeMSDescs(dfdsig, mss), dfdop'OpDef = MakeDFDOp(dfdid, dfdtopo, dfdsig, style) in (if (dst = nil)then ({dfdop} union msdescs)else ({dst, dfdop} union msdescs))MakeState' (DFDId * DSs * set of (FlowId) -> [StateDef])	MakeState(dfdid, dss, fids) ==(if ((dss = {}) and (fids = {}))then nilelse let fl'seq of (Field) = MakeFieldList((dss union fids)) in mk_StateDef(StateIdConf(dfdid), fl))MakeFieldList' (set of (StId) -> seq of (Field))	MakeFieldList(ids) ==(if (ids = {})then []else let id in set ids in ([MakeField(id)] ^ MakeFieldList((ids \ {id}))))Card' (set of (StId) -> nat)	Card(s) ==(card s)MakeField' (StId -> Field)	MakeField(id) ==mk_Field(StateVarConf(id), StateTypeConf(id))MakeMSDescs' (DFDSig * MSs -> set of (Definition))	MakeMSDescs(dfdsig, mss) ==(if (forall id in set (dom dfdsig) & is_(id, DFDId))then {}else let id in set (dom dfdsig) be st is_(id, MSId) in let def''(ImplOp | MS) = (if (id in set (dom mss))then mss(id)else MakeOp(id, dfdsig(id))) in ({def'} union MakeMSDescs(({id} <-' dfdsig), mss)))MakeOp' (MSId * (seq of (FlowId) * seq of (FlowId) * State) -> ImplOp)	MakeOp(msid, mk_(din, out, dst)) ==let partpl'seq of (ParType) = MakeInpPar(din), residtp'[IdType] = MakeOutPair(out), dext'seq of (ExtVarInf) = MakeExt(dst), body'ImplOpBody = mk_ImplOpBody(nil, mk_BoolLit(true)) in mk_ImplOp(OpIdConf(msid), partpl, residtp, dext, body)MakeInpPar' (seq of (FlowId) -> seq of (ParType))	MakeInpPar(fidl) ==[mk_ParType(mk_PatternId(FlowIdVarConf(fidl(i))), FlowIdTypeConf(fidl(i))) | i in set (inds fidl)]MakeOutPair' (seq of (FlowId) -> [IdType])	MakeOutPair(fidl) ==(cases (len fidl) 'case 0 -> nil,case 1 -> mk_IdType(FlowIdVarConf((hd fidl)), FlowIdTypeConf((hd fidl)))others let t'ProductType = mk_ProductType([FlowIdTypeConf(fidl(i)) | i in set (inds fidl)]) in mk_IdType(ResultIdConf(), t)end)MakeExt' (State -> seq of (ExtVarInf))	MakeExt(dst) ==[MakeExtVar(dst(i)) | i in set (inds dst)]MakeExtVar' ((StId * Mode) -> ExtVarInf)	MakeExtVar(mk_(id, mode)) ==mk_ExtVarInf(mode, VarConf(id), TypeConf(id))MakeDFDOp' (DFDId * DFDTopo * DFDSig * (<EXPL> | <IMPL>) -> OpDef)	MakeDFDOp(dfdid, dfdtopo, dfdsig, style) ==(if (style = <EXPL>)then MakeDFDExplOp(dfdid, dfdtopo, dfdsig)else MakeDFDImplOp(dfdid, dfdtopo, dfdsig))	pre (if (style = <EXPL>)then pre_MakeDFDExplOp(dfdid, dfdtopo, dfdsig)else pre_MakeDFDImplOp(dfdid, dfdtopo, dfdsig))MakeDFDImplOp' (DFDId * DFDTopo * DFDSig -> ImplOp)	MakeDFDImplOp(dfdid, dfdtopo, dfdsig) ==let mk_(din, out, dst)'Signature = dfdsig(dfdid) in let partpl'seq of (ParType) = MakeInpPar(din), residtp'[IdType] = MakeOutPair(out), dext'seq of (ExtVarInf) = MakeExt(dst), body'ImplOpBody = MakeImplOpBody(dfdid, dfdtopo, dfdsig) in mk_ImplOp(OpIdConf(dfdid), partpl, residtp, dext, body)	pre ((dfdid in set (dom dfdsig)) and pre_MakeImplOpBody(dfdid, dfdtopo, dfdsig))MakeImplOpBody' (DFDId * DFDTopo * DFDSig -> ImplOpBody)	MakeImplOpBody(dfdid, dfdtopo, dfdsig) ==let intm'map (StId) to (nat) = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm'map (StId) to (nat) = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))}, dpre'Expr = MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm), dpost'Expr = MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm) in mk_ImplOpBody(dpre, dpost)	pre let intm'map (StId) to (nat) = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm'map (StId) to (nat) = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in (pre_MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) and pre_MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm))static private IntM = map (StId) to (nat)MakePreExpr' (DFDId * DFDTopo * DFDSig * IntM * IntM -> Expr)	MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) ==let mk_(-, out, dst)'Signature = dfdsig(dfdid) in let fids'set of (FlowId) = NeedsQuant(dfdtopo, dfdsig, {}, {}), pred'Expr = MakePrePred(dfdtopo, dfdsig, intm, maxm) in (if QuantNec(out, dst, fids, intm, maxm)then let bind'MultTypeBind = MakeExistsBind(fids, dst, intm, maxm, <PRE>) in mk_ExistsExpr(bind, pred)else pred)	pre (dfdid in set (dom dfdsig))MakePrePred' (DFDTopo * DFDSig * IntM * IntM -> Expr)	MakePrePred(dfdtopo, dfdsig, intm, maxm) ==let eos'set of (seq1 of (ProcId)) = ExecutionOrders(dfdtopo) in DBinOp(<OR>, {MakePreForEO(piseq, dfdsig, intm, maxm) | [piseq in set eos]})MakePreForEO' (seq1 of (ProcId) * DFDSig * IntM * IntM -> Expr)	MakePreForEO(piseq, dfdsig, intm, maxm) ==let nid'ProcId = (hd piseq) in let intm''map (StId) to (nat) = {stid |-> (if (mk_(stid, <READWRITE>) in set CollectStIds({dfdsig(nid)}))then (intm(stid) + 1)else intm(stid)) | stid in set (dom intm)} in let dpre'Apply = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <PRE>, <PRE>), dpost'Apply = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <PRE>, <POST>) in (if ((len piseq) = 1)then dpreelse let pred'BinaryExpr = mk_BinaryExpr(dpre, <AND>, dpost) in mk_BinaryExpr(pred, <AND>, MakePreForEO((tl piseq), dfdsig, intm', maxm)))MakePostExpr' (DFDId * DFDTopo * DFDSig * IntM * IntM -> Expr)	MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm) ==let mk_(-, out, dst)'Signature = dfdsig(dfdid), fids'set of (FlowId) = NeedsQuant(dfdtopo, dfdsig, (elems out), {}), body'Expr = MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm) in (if ((len out) <= 1)then bodyelse mk_LetExpr(MakePattern(out), ResultIdConf(), body))	pre let mk_(-, out, dst)'Signature = dfdsig(dfdid), fids'set of (FlowId) = NeedsQuant(dfdtopo, dfdsig, (elems out), {}) in pre_MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm)MakeInExpr' (seq of (FlowId) * State * set of (FlowId) * DFDTopo * DFDSig * IntM * IntM -> Expr)	MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm) ==let pred'Expr = MakePostPred(dfdtopo, dfdsig, intm, maxm) in (if QuantNec(out, dst, fids, intm, maxm)then let bind'MultTypeBind = MakeExistsBind(fids, dst, intm, maxm, <POST>) in mk_ExistsExpr(bind, pred)else pred)	pre pre_MakeExistsBind(fids, dst, intm, maxm, <POST>)MakePostPred' (DFDTopo * DFDSig * IntM * IntM -> Expr)	MakePostPred(dfdtopo, dfdsig, intm, maxm) ==let eos'set of (seq1 of (ProcId)) = ExecutionOrders(dfdtopo) in DBinOp(<OR>, {MakePostForEO(piseq, dfdsig, intm, maxm) | [piseq in set eos]})MakePostForEO' (seq1 of (ProcId) * DFDSig * IntM * IntM -> Expr)	MakePostForEO(piseq, dfdsig, intm, maxm) ==let nid'ProcId = (hd piseq) in let intm''map (StId) to (nat) = {stid |-> (if (mk_(stid, <READWRITE>) in set CollectStIds({dfdsig(nid)}))then (intm(stid) + 1)else intm(stid)) | stid in set (dom intm)} in let dpre'Apply = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <POST>, <PRE>), dpost'Apply = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <POST>, <POST>) in (if ((len piseq) = 1)then mk_BinaryExpr(dpre, <AND>, dpost)else let pred'BinaryExpr = mk_BinaryExpr(dpre, <AND>, dpost) in mk_BinaryExpr(pred, <AND>, MakePostForEO((tl piseq), dfdsig, intm', maxm)))	pre let nid'ProcId = (hd piseq) in ((nid in set (dom dfdsig)) and (pre_MakeQuotedApply(nid, dfdsig(nid), intm, maxm, <POST>, <PRE>) and pre_MakeQuotedApply(nid, dfdsig(nid), intm, maxm, <POST>, <POST>)))MakeExistsBind' (set of (FlowId) * State * IntM * IntM * (<POST> | <PRE>) -> MultTypeBind)	MakeExistsBind(fs, dst, intm, maxm, c) ==let outl'seq of (TypeBind) = MakeTypeBindList(fs), stl'seq of (TypeBind) = [let mk_(s, -)'(StId * Mode) = dst(i), p'seq of (PatternId) = MakePatternIds(s, (intm(s) + 1), maxm(s), c) in mk_TypeBind(p, StateTypeConf(s)) | i in set (inds dst) & let mk_(-, m)'(StId * Mode) = dst(i) in (m = <READWRITE>)] in mk_MultTypeBind((outl ^ stl))	pre (forall mk_(s, <READWRITE>) in set (elems dst) & ((s in set (dom intm)) and (s in set (dom maxm))))ExecutionOrders' (DFDTopo -> set of (seq1 of (ProcId)))	ExecutionOrders(dfdtopo) ==let top'set of (([ProcId] * [ProcId])) = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or (is_(fid, MSId) or (fid = nil))) and (is_(tid, DFDId) or (is_(tid, MSId) or (tid = nil))))}, top2'set of (([ProcId] * [ProcId])) = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in let piset'set of ([ProcId]) = ((dunion {{pi_1, pi_2} | [mk_(pi_1, pi_2) in set top]}) \ {nil}) in {piseq | [piseq in set PossibleSeqs(piset)] & (forall i, j in set (inds piseq) & ((j < i) => (piseq(j) not in set TransClosure(piseq(i), top2, {}))))}MakeQuotedApply' ((DFDId | MSId) * Signature * IntM * IntM * (<POST> | <PRE>) * (<POST> | <PRE>) -> Apply)	MakeQuotedApply(id, mk_(din, out, dst), intm, maxm, c, c2) ==let inarg'seq of (Id) = [FlowIdVarConf(din(i)) | i in set (inds din)], oldstarg'seq of (Id) = [let mk_(s, m)'(StId * Mode) = dst(i) in (if (m = <READ>)then StateVarIntConf(s, intm(s), maxm(s), c)else StateVarIntConf(s, (intm(s) - 1), maxm(s), c)) | i in set (inds dst)], outarg'seq of (Id) = [FlowIdVarConf(out(i)) | i in set (inds out)], starg'seq of (Id) = [let mk_(s, -)'(StId * Mode) = dst(i) in StateVarIntConf(s, intm(s), maxm(s), c) | i in set (inds dst) & let mk_(-, m)'(StId * Mode) = dst(i) in (m = <READWRITE>)] in (if (c2 = <PRE>)then mk_Apply(("pre_" ^ OpIdConf(id)), (inarg ^ oldstarg))else mk_Apply(("post_" ^ OpIdConf(id)), (((inarg ^ oldstarg) ^ outarg) ^ starg)))	pre (forall mk_(s, m) in set (elems dst) & (((s in set (dom intm)) and ((s in set (dom maxm)) and (m = <READWRITE>))) => (intm(s) > 0)))MakeDFDExplOp' (DFDId * DFDTopo * DFDSig -> ExplOp)	MakeDFDExplOp(dfdid, dfdtopo, dfdsig) ==let mk_(din, -, -)'Signature = dfdsig(dfdid), eos'set of (seq1 of (ProcId)) = ExecutionOrders(dfdtopo), intm'map (StId) to (nat) = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm'map (StId) to (nat) = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in let optype'OpType = MakeOpType(dfdsig(dfdid)), parms'seq of (PatternId) = [mk_PatternId(FlowIdVarConf(din(i))) | i in set (inds din)], bodys'set of (Stmt) = {MakeStmtForEO(piseq, dfdid, dfdsig) | [piseq in set eos]}, dpre'Expr = MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) in let body'Stmt = MakeNonDetStmt(bodys) in mk_ExplOp(OpIdConf(dfdid), optype, parms, body, dpre)	pre ((dfdid in set (dom dfdsig)) and let intm'map (StId) to (nat) = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm'map (StId) to (nat) = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in (pre_MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) and (forall piseq in set ExecutionOrders(dfdtopo) & pre_MakeStmtForEO(piseq, dfdid, dfdsig))))MakeStmtForEO' (seq1 of (ProcId) * DFDId * DFDSig -> Stmt)	MakeStmtForEO(piseq, dfdid, dfdsig) ==let nid'ProcId = (hd piseq) in let mk_(call, pat)'(Call * [Pattern]) = MakeCallAndPat(nid, dfdsig(nid)), kind'(<OPCALL> | <OPRES>) = FindKind(dfdsig(nid)) in (if ((len piseq) = 1)then let mk_(-, out, -)'Signature = dfdsig(dfdid) in let ret'Return = mk_Return(MakeResult(out)) in (if (kind = <OPRES>)then mk_DefStmt(pat, call, ret)else mk_Sequence([call, ret]))else let rest'Stmt = MakeStmtForEO((tl piseq), dfdid, dfdsig) in (if (kind = <OPRES>)then mk_DefStmt(pat, call, rest)else (if is_(rest, Sequence)then let mk_Sequence(sl)'Stmt = rest in mk_Sequence(([call] ^ sl))else mk_Sequence([call, rest]))))	pre ((hd piseq) in set (dom dfdsig))MakeCallAndPat' ((DFDId | MSId) * Signature -> (Call * [Pattern]))	MakeCallAndPat(id, mk_(din, out, -)) ==let inarg'seq of (Id) = [FlowIdVarConf(din(i)) | i in set (inds din)], outarg'seq of (Id) = [FlowIdVarConf(out(i)) | i in set (inds out)] in mk_(mk_Call(OpIdConf(id), inarg), MakePattern(outarg))FindKind' (Signature -> (<OPCALL> | <OPRES>))	FindKind(sig) ==(cases sig 'case mk_(-, [], -) -> <OPCALL>others <OPRES>end)MakePattern' (seq of (Id) -> [Pattern])	MakePattern(idl) ==(cases (len idl) 'case 0 -> nil,case 1 -> mk_PatternId((hd idl))others mk_TuplePattern([mk_PatternId(idl(i)) | i in set (inds idl)])end)MakeResult' (seq1 of (Id) -> Expr)	MakeResult(idl) ==(if ((len idl) = 1)then FlowIdVarConf((hd idl))else mk_TupleConstructor([FlowIdVarConf(idl(i)) | i in set (inds idl)]))DBinOp' (BinaryOp * set of (Expr) -> Expr)	DBinOp(op, es) ==let e in set es in (if ((card es) = 1)then eelse mk_BinaryExpr(e, op, DBinOp(op, (es \ {e}))))	pre (es <> {})CollectExtDFs' (DFDTopo -> set of (FlowId))	CollectExtDFs(dfdtopo) =={fid | [fid in set (dom dfdtopo)] & let mk_(pid_1, pid_2)'([ProcId] * [ProcId]) = dfdtopo(fid) in (is_(pid_1, EPId) or is_(pid_2, EPId))}NeedsQuant' (DFDTopo * DFDSig * set of (FlowId) * set of (ProcId) -> set of (FlowId))	NeedsQuant(dfdtopo, dfdsig, notneeded, pids) ==let top'set of (([ProcId] * [ProcId])) = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in (if ((dom dfdsig) = pids)then {}else let pid in set ((dom dfdsig) \ pids) in (if ((TransClosure(pid, top, {}) = {}) and (EquivClass(top, {pid}) = (dom dfdsig)))then NeedsQuant(dfdtopo, dfdsig, notneeded, (pids union {pid}))else let mk_(-, out, -)'Signature = dfdsig(pid) in ((NeedsQuant(dfdtopo, dfdsig, notneeded, (pids union {pid})) union (elems out)) \ notneeded)))QuantNec' (seq of (FlowId) * State * set of (FlowId) * IntM * IntM -> bool)	QuantNec(out, dst, fids, intm, maxm) ==((fids <> {}) or (exists [mk_(s, m) in set (elems dst)] & ((m = <READWRITE>) and (intm(s) < maxm(s)))))	pre (forall mk_(s, -) in set (elems dst) & ((s in set (dom intm)) and (s in set (dom maxm))))MakeTypeBindList' (set of (FlowId) -> seq of (TypeBind))	MakeTypeBindList(fids) ==(if (fids = {})then []else let fid in set fids in let pat'seq1 of (PatternId) = [mk_PatternId(FlowIdVarConf(fid))], first'TypeBind = mk_TypeBind(pat, FlowIdTypeConf(fid)) in ([first] ^ MakeTypeBindList((fids \ {fid}))))CardFId' (set of (FlowId) -> nat)	CardFId(s) ==(card s)MakePatternIds' ((DSId | Id) * nat * nat * (<POST> | <PRE>) -> seq of (PatternId))	MakePatternIds(id, n, max, c) ==(if ((n = max) and (c = <POST>))then [mk_PatternId(StateVarConf(id))]else (cases n 'case 0 -> (if (c = <PRE>)then [mk_PatternId(StateVarConf(id))]else [mk_PatternId(StateOldVarConf(id))])others MakePatternSeq(StateVarConf(id), n, max)end))MakePatternSeq' (Id * nat * nat -> seq of (PatternId))	MakePatternSeq(id, n, max) ==(if (n = max)then [mk_PatternId((id ^ "'"))]else ([mk_PatternId((id ^ "'"))] ^ MakePatternSeq((id ^ "'"), (n + 1), max)))	pre (n <= max)TowardsMax' (Id * nat * nat -> nat)	TowardsMax(-, n, max) ==(max - n)EquivClass' (set of ((ProcId * ProcId)) * set of ((DFDId | MSId)) -> set of ((DFDId | MSId)))	EquivClass(top, ids) ==(if (exists [mk_(fid, tid) in set top] & (((fid in set ids) and (tid not in set ids)) or ((tid in set ids) and (fid not in set ids))))then let mk_(fid, tid) in set top be st (((fid in set ids) and (tid not in set ids)) or ((tid in set ids) and (fid not in set ids))) in EquivClass(top, (ids union {fid, tid}))else ids)MakeNonDetStmt' (set of (Stmt) -> Stmt)	MakeNonDetStmt(stmts) ==(cases (card stmts) 'case 1 -> let {s}'set of (Stmt) = stmts in sothers mk_NonDetStmt(stmts)end)	pre ((card stmts) <> 0)CollectStIds' (set of (Signature) -> set of ((StId * Mode)))	CollectStIds(sigs) ==(dunion {(elems dst) | [mk_(-, -, dst) in set sigs]})NoOfWr' (set of (Signature) * StId -> nat)	NoOfWr(sigs, stid) ==(if (sigs = {})then 0else let sig in set sigs in let mk_(-, -, dst)'Signature = sig in (if (mk_(stid, <READWRITE>) in set (elems dst))then (1 + NoOfWr((sigs \ {sig}), stid))else NoOfWr((sigs \ {sig}), stid)))Reduce' (nat -> nat)	Reduce(n) ==(if ((n = 0) or (n = 1))then nelse (n - 1))ModIdConf' (DFDId -> Id)	ModIdConf(mk_DFDId(id)) ==(id ^ "Module")StateIdConf' (DFDId -> Id)	StateIdConf(mk_DFDId(id)) ==(id ^ "State")DSIdConf' (DSId -> Id)	DSIdConf(mk_DSId(id)) ==idOpIdConf' ((DFDId | Id | MSId) -> Id)	OpIdConf(id) ==(cases id 'case mk_MSId(id') -> id',case mk_DFDId(id') -> id'others idend)StateVarIntConf' ((DSId | Id) * nat * nat * (<POST> | <PRE>) -> Id)	StateVarIntConf(id, n, max, c) ==(if ((max = n) and (c = <POST>))then StateVarConf(id)else (cases n 'case 0 -> (if (c = <PRE>)then StateVarConf(id)else StateOldVarConf(id)),case 1 -> (StateVarConf(id) ^ "'")others (StateVarIntConf(id, (n - 1), max, c) ^ "'")end))VarConf' (StId -> Id)	VarConf(id) ==(if is_(id, DSId)then StateVarConf(id)else FlowIdVarConf(id))TypeConf' ((DSId | FlowId) -> Id)	TypeConf(id) ==(if is_(id, DSId)then StateTypeConf(id)else FlowIdTypeConf(id))FlowIdVarConf' (Id -> Id)	FlowIdVarConf(id) ==ToLower(id)FlowIdTypeConf' (Id -> Id)	FlowIdTypeConf(id) ==ToUpper(id)StateTypeConf' ((DSId | Id) -> Id)	StateTypeConf(id) ==ToUpper(id)StateVarConf' ((DSId | Id) -> Id)	StateVarConf(id) ==ToLower(id)StateOldVarConf' ((DSId | Id) -> Id)	StateOldVarConf(id) ==(ToLower(id) ^ "old")TypeModConf' (() -> Id)	TypeModConf() =="TypeModule"ResultIdConf' (() -> Id)	ResultIdConf() =="r"PossibleSeqs' (set of (ProcId) -> set of (seq of (ProcId)))	PossibleSeqs(pids) ==(if (pids = {})then {}else (if ((card pids) = 1)then {[pid] | [pid in set pids]}else let pid in set pids in let rest'set of (seq of (ProcId)) = PossibleSeqs((pids \ {pid})) in (dunion {InsertPId(pid, seq') | [seq' in set rest]})))CardPSet' (set of (ProcId) -> nat)	CardPSet(s) ==(card s)InsertPId' (ProcId * seq of (ProcId) -> set of (seq of (ProcId)))	InsertPId(pid, seq') =={(((seq'(1, ... ,i)) ^ [pid]) ^ (seq'((i + 1), ... ,(len seq')))) | [i in set {0, ... ,(len seq')}]}ToLower' ((DFDId | DSId | EPId | Id | MSId) -> Id)	ToLower(id) ==let realid'(DFDId | DSId | EPId | Id | MSId | seq of (char)) = (cases id 'case mk_DSId(id') -> id',case mk_DFDId(id') -> id',case mk_EPId(id') -> id',case mk_MSId(id') -> id'others idend) in [LowerChar(realid(i)) | i in set (inds realid)]LowerChar' (char -> char)	LowerChar(c) ==(cases c 'case char value [A] -> 'a',case char value [B] -> 'b',case char value [C] -> 'c',case char value [D] -> 'd',case char value [E] -> 'e',case char value [F] -> 'f',case char value [G] -> 'g',case char value [H] -> 'h',case char value [I] -> 'i',case char value [J] -> 'j',case char value [K] -> 'k',case char value [L] -> 'l',case char value [M] -> 'm',case char value [N] -> 'n',case char value [O] -> 'o',case char value [P] -> 'p',case char value [Q] -> 'q',case char value [R] -> 'r',case char value [S] -> 's',case char value [T] -> 't',case char value [U] -> 'u',case char value [V] -> 'v',case char value [W] -> 'w',case char value [X] -> 'x',case char value [Y] -> 'y',case char value [Z] -> 'z'others cend)ToUpper' ((DFDId | DSId | EPId | Id | MSId) -> Id)	ToUpper(id) ==let realid'(DFDId | DSId | EPId | Id | MSId | seq of (char)) = (cases id 'case mk_DSId(id') -> id',case mk_DFDId(id') -> id',case mk_EPId(id') -> id',case mk_MSId(id') -> id'others idend) in [UpperChar(realid(i)) | i in set (inds realid)]UpperChar' (char -> char)	UpperChar(c) ==(cases c 'case char value [a] -> 'A',case char value [b] -> 'B',case char value [c] -> 'C',case char value [d] -> 'D',case char value [e] -> 'E',case char value [f] -> 'F',case char value [g] -> 'G',case char value [h] -> 'H',case char value [i] -> 'I',case char value [j] -> 'J',case char value [k] -> 'K',case char value [l] -> 'L',case char value [m] -> 'M',case char value [n] -> 'N',case char value [o] -> 'O',case char value [p] -> 'P',case char value [q] -> 'Q',case char value [r] -> 'R',case char value [s] -> 'S',case char value [t] -> 'T',case char value [u] -> 'U',case char value [v] -> 'V',case char value [w] -> 'W',case char value [x] -> 'X',case char value [y] -> 'Y',case char value [z] -> 'Z'others cend)static private SA = (HDFD * DD * MSs)	inv mk_(hdfd, dd, -) == (FlowTypeDefined(hdfd, dd) and TopLevelSigOK(hdfd))static private HDFD = (DFDId * DSs * DFDTopo * DFDMap * DFDSig)static private DSs = set of (DSId)static private DSId = compose DSId of 1'seq of (char) endstatic private DFDTopo = map (FlowId) to (([ProcId] * [ProcId]))	inv dfdtopo == let top'set of (([ProcId] * [ProcId])) = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in (NotRecursive(top) and (forall flowid in set (dom dfdtopo) & FlowConnectOK(dfdtopo(flowid))))static private FlowId = seq of (char)static private ProcId = (DFDId | EPId | MSId)static private DFDMap = map (DFDId) to (HDFD)static private DFDSig = map ((DFDId | MSId)) to (Signature)static private Signature = (Input * Output * State)	inv mk_(-, out, sta) == ((sta = []) => (((out <> []) and (out = [])) => (exists [mk_(-, m) in set (elems sta)] & (m = <READWRITE>))))static private Input = seq of (FlowId)static private Output = seq of (FlowId)static private State = seq of ((StId * Mode))static private StId = (DSId | FlowId)static private Mode = (<READ> | <READWRITE>)static private DD = map (Id) to (Type)static private MSs = map (MSId) to (MS)static private MS = OpDefstatic private DFDId = compose DFDId of 1'seq of (char) endstatic private EPId = compose EPId of 1'seq of (char) endstatic private MSId = compose MSId of 1'seq of (char) endFlowTypeDefined' (HDFD * DD -> bool)	FlowTypeDefined(mk_(-, -, dfdtop, -, -), dd) ==(forall fid in set (dom dfdtop) & (FlowIdTypeConf(fid) in set (dom dd)))TopLevelSigOK' (HDFD -> bool)	TopLevelSigOK(mk_(sysid, -, dfdtop, -, dfdsig)) ==((sysid in set (dom dfdsig)) and let mk_(din, out, dst)'Signature = dfdsig(sysid) in ((din = []) and ((out = []) and (forall flowid in set (dom dfdtop) & let mk_(fid, tid)'([ProcId] * [ProcId]) = dfdtop(flowid) in ((is_(fid, EPId) => (mk_(flowid, <READ>) in set (elems dst))) and (is_(tid, EPId) => (mk_(flowid, <READWRITE>) in set (elems dst))))))))DFDSigConsistent' (DFDId * DFDTopo * DSs * DFDMap * DFDSig -> bool)	DFDSigConsistent(id, dfdtop, dss, dfdmap, dfdsig) ==(DSConnected(dss, dfdsig) and (SigsAllRight(dfdtop, dfdsig) and (IdsInSigsAvail(dss, dfdtop, (rng dfdsig)) and SigsForAllUsedIds(id, (rng dfdtop), dfdmap, dfdsig))))DSConnected' (DSs * DFDSig -> bool)	DSConnected(dss, dfdsig) ==(forall dsid in set dss & (exists [mk_(-, -, dst) in set (rng dfdsig)] & (exists [i in set (inds dst)] & let mk_(id, -)'(StId * Mode) = dst(i) in (dsid = id))))SigsAllRight' (DFDTopo * DFDSig -> bool)	SigsAllRight(dfdtop, dfdsig) ==(forall flowid in set (dom dfdtop) & (cases dfdtop(flowid) 'case mk_(id, mk_EPId(-)) -> let mk_(-, -, dst)'Signature = dfdsig(id) in (mk_(flowid, <READWRITE>) in set (elems dst)),case mk_(mk_EPId(-), id) -> let mk_(-, -, dst)'Signature = dfdsig(id) in (mk_(flowid, <READ>) in set (elems dst)),case mk_(nil, id) -> let mk_(din, -, -)'Signature = dfdsig(id) in (flowid in set (elems din)),case mk_(id, nil) -> let mk_(-, out, -)'Signature = dfdsig(id) in (flowid in set (elems out)),case mk_(fid, tid) -> let mk_(-, out, -)'Signature = dfdsig(fid), mk_(din, -, -)'Signature = dfdsig(tid) in ((flowid in set (elems out)) and (flowid in set (elems din)))end))IdsInSigsAvail' (DSs * DFDTopo * set of (Signature) -> bool)	IdsInSigsAvail(dss, dfdtop, sigs) ==let fids'set of (FlowId) = CollectExtDFs(dfdtop) in (forall mk_(din, out, dst) in set sigs & (((elems din) subset (dom dfdtop)) and (((elems out) subset (dom dfdtop)) and ((elems dst) subset {mk_(id, m) | [id in set (dss union fids), m in set {<READ>, <READWRITE>}]}))))LowerLevelUsed' (DFDTopo * DFDMap -> bool)	LowerLevelUsed(dfdtop, dfdmap) ==let ids'set of (DFDId) = (dom dfdmap) in (forall mk_(fid, tid) in set (rng dfdtop) & ((is_(fid, DFDId) => (fid in set ids)) and (is_(tid, DFDId) => (tid in set ids))))SigsForAllUsedIds' (DFDId * set of (([ProcId] * [ProcId])) * DFDMap * DFDSig -> bool)	SigsForAllUsedIds(id, top, dfdmap, dfdsig) ==((forall dfdid in set (dom dfdmap) & let mk_(-, -, -, -, dfdsig')'HDFD = dfdmap(dfdid) in (dfdsig'(dfdid) = dfdsig(dfdid))) and let sigs'set of ((DFDId | MSId)) = (dom dfdsig) in ((id in set sigs) and (forall mk_(fid, tid) in set top & (((is_(fid, MSId) or is_(fid, DFDId)) => (fid in set sigs)) and ((is_(tid, MSId) or is_(tid, DFDId)) => (tid in set sigs))))))FlowConnectOK' (([ProcId] * [ProcId]) -> bool)	FlowConnectOK(mk_(fid, tid)) ==(((is_(fid, EPId) or (fid = nil)) => (is_(tid, DFDId) or is_(tid, MSId))) and ((is_(tid, EPId) or (tid = nil)) => (is_(fid, DFDId) or is_(fid, MSId))))NotRecursive' (set of (((DFDId | MSId) * (DFDId | MSId))) -> bool)	NotRecursive(top) ==(forall mk_(f, -) in set top & (f not in set TransClosure(f, top, {})))TransClosure' ((DFDId | MSId) * set of (((DFDId | MSId) * (DFDId | MSId))) * set of ((DFDId | MSId)) -> set of ((DFDId | MSId)))	TransClosure(pid, top, dset) ==(if (exists [mk_(fromid, toid) in set top] & (((fromid = pid) or (fromid in set dset)) and (toid not in set dset)))then let mk_(fromid, toid) in set top be st (((fromid = pid) or (fromid in set dset)) and (toid not in set dset)) in TransClosure(pid, top, (dset union {toid}))else dset)static private Document = set of (Module)static private Module = (ModuleId * Interface * Definitions)static private ModuleId = seq of (char)static private Interface = (Imports * Export)static private Imports = set of (Import)static private Import = (ModuleId * ModuleSig)static private Export = ModuleSigstatic private ModuleSig = set of (Sig)static private Sig = (OpSig | TypeSig)static private TypeSig = compose TypeSig of 1'TypeId endstatic private TypeId = seq of (char)static private OpSig = compose OpSig of id'Id, optype'OpType, stids'seq of (Id) endstatic private Definitions = set of (Definition)static private Definition = (OpDef | StateDef)static private StateDef = compose StateDef of id'Id, fields'seq of (Field) endstatic private Field = compose Field of sel'[Id], type'Type endstatic private OpDef = (ExplOp | ImplOp)static private ExplOp = compose ExplOp of id'Id, optype'OpType, parms'seq of (Pattern), body'Stmt, dpre'Expr endstatic private ImplOp = compose ImplOp of id'Id, partp'seq of (ParType), residtp'[IdType], dext'seq of (ExtVarInf), body'ImplOpBody endstatic private ImplOpBody = compose ImplOpBody of dpre'[Expr], dpost'Expr endstatic private ParType = compose ParType of pat'Pattern, type'Type endstatic private IdType = compose IdType of id'Id, type'Type endstatic private ExtVarInf = compose ExtVarInf of mode'ReadWriteMode, id'Id, type'Type endstatic private ReadWriteMode = (<READ> | <READWRITE>)static private OpType = compose OpType of dom''[Type], rng''[Type] endstatic private Type = (BasicType | EnumType | MapType | OptionalType | ProductType | SeqType | SetType | TypeId | UnionType)static private ProductType = compose ProductType of product'seq1 of (Type) endstatic private MapType = compose MapType of d'Type, r'Type endstatic private SetType = compose SetType of 1'Type endstatic private SeqType = compose SeqType of 1'Type endstatic private BasicType = (<BOOL> | <CHAR> | <TOKEN>)static private EnumType = compose EnumType of 1'seq of (char) endstatic private OptionalType = compose OptionalType of 1'Type endstatic private UnionType = compose UnionType of 1'set of (Type) endstatic private Stmt = (<IDENT> | Call | DclStmt | DefStmt | NonDetStmt | Return | Sequence)static private DclStmt = compose DclStmt of dcls'set of (AssDef), body'Stmt endstatic private AssDef = compose AssDef of var'Id, tp'Type endstatic private DefStmt = compose DefStmt of lhs'Pattern, rhs'(Call | Expr), din'Stmt endstatic private NonDetStmt = compose NonDetStmt of stmts'set of (Stmt) endstatic private Call = compose Call of oprt'Id, args'seq of (Expr) endstatic private Sequence = compose Sequence of stmts'seq1 of (Stmt) endstatic private Return = compose Return of val'[Expr] endstatic private Expr = (Apply | BinaryExpr | BoolLit | Id | IfExpr | LetExpr | QuantExpr | TupleConstructor)static private LetExpr = compose LetExpr of lhs'Pattern, rhs'Expr, din'Expr endstatic private IfExpr = compose IfExpr of test'Expr, con'Expr, alt'Expr endstatic private QuantExpr = ExistsExprstatic private ExistsExpr = compose ExistsExpr of bind'MultTypeBind, pred'Expr endstatic private BinaryExpr = compose BinaryExpr of left'Expr, op'BinaryOp, right'Expr endstatic private BinaryOp = (<AND> | <EQUAL> | <MEMB> | <OR>)static private TupleConstructor = compose TupleConstructor of fields'seq1 of (Expr) endstatic private Apply = compose Apply of name'Expr, arg'seq of (Expr) endstatic private BoolLit = compose BoolLit of 1'bool endstatic private MultTypeBind = compose MultTypeBind of mtb'seq1 of (TypeBind) endstatic private TypeBind = compose TypeBind of pats'seq of (Pattern), tp'Type endstatic private Pattern = (PatternId | TuplePattern)static private PatternId = compose PatternId of name'[Id] endstatic private TuplePattern = compose TuplePattern of fields'seq1 of (Pattern) endstatic private Id = seq of (char)end DEFAULT
