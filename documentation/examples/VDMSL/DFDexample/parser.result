RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsTransHDFD' ((unresolved DEFAULT`HDFD) * (unresolved DEFAULT`MSs) * ((<EXPL> | <IMPL>)) -> set of ((unresolved DEFAULT`Module)))	TransHDFD(hdfd, mss, style) ==let mainmod = MakeDFDModule(hdfd, mss, style) in let mk_(-, -, -, dfdmap, -) = hdfd in let mods = (dunion {TransHDFD(dfd, mss, style) | [dfd in set (rng dfdmap)]}) in ({mainmod} union mods)MakeDFDModule' ((unresolved DEFAULT`HDFD) * (unresolved DEFAULT`MSs) * ((<EXPL> | <IMPL>)) -> (unresolved DEFAULT`Module))	MakeDFDModule(mk_(dfdid, dss, dfdtopo, dfdmap, dfdsig), mss, style) ==let i = MakeInterface(dfdid, dss, dfdtopo, dfdsig, dfdmap), defs = MakeDefinitions(dfdid, dss, dfdtopo, dfdsig, mss, style) in mk_(ModIdConf(dfdid), i, defs)MakeInterface' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DSs) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`DFDMap) -> (unresolved DEFAULT`Interface))	MakeInterface(dfdid, dss, dfdtopo, dfdsig, dfdmap) ==let tmimp = MakeTypeModImp(dss, (dom dfdtopo)), dfdmimps = MakeDFDModImps((dom dfdmap), dfdsig), exp = MakeOpExp(dfdid, dfdsig(dfdid)) in mk_(({tmimp} union dfdmimps), exp)	pre (dfdid in set (dom dfdsig))MakeTypeModImp' ((unresolved DEFAULT`DSs) * set of ((unresolved DEFAULT`FlowId)) -> (unresolved DEFAULT`Import))	MakeTypeModImp(dss, fids) ==let tysigs = ({mk_TypeSig(DSIdConf(dsid)) | [dsid in set dss]} union {mk_TypeSig(FlowIdTypeConf(fid)) | [fid in set fids]}) in mk_(TypeModConf(), tysigs)MakeDFDModImps' (set of ((unresolved DEFAULT`DFDId)) * (unresolved DEFAULT`DFDSig) -> set of ((unresolved DEFAULT`Import)))	MakeDFDModImps(dfdids, dfdsig) =={mk_(ModIdConf(id), {MakeOpSig(id, dfdsig(id))}) | [id in set dfdids]}	pre (dfdids subset (dom dfdsig))MakeOpExp' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`Signature) -> (unresolved DEFAULT`Export))	MakeOpExp(dfdid, sig) =={MakeOpSig(dfdid, sig)}MakeOpSig' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`Signature) -> (unresolved DEFAULT`OpSig))	MakeOpSig(dfdid, sig) ==let opty = MakeOpType(sig), opst = MakeOpState(sig) in mk_OpSig(OpIdConf(dfdid), opty, opst)MakeOpType' ((unresolved DEFAULT`Signature) -> (unresolved DEFAULT`OpType))	MakeOpType(mk_(il, ol, -)) ==mk_OpType(MakeType(il), MakeType(ol))MakeType' (seq of ((unresolved DEFAULT`FlowId)) -> [(unresolved DEFAULT`Type)])	MakeType(fidl) ==(cases (len fidl) 'case 0 -> nil,case 1 -> FlowIdTypeConf((hd fidl))others mk_ProductType([FlowIdTypeConf(fidl(i)) | i in set (inds fidl)])end)MakeOpState' ((unresolved DEFAULT`Signature) -> seq of ((unresolved DEFAULT`Id)))	MakeOpState(mk_(-, -, sl)) ==[let mk_(s, -) = sl(i) in StateVarConf(s) | i in set (inds sl)]MakeDefinitions' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DSs) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`MSs) * ((<EXPL> | <IMPL>)) -> (unresolved DEFAULT`Definitions))	MakeDefinitions(dfdid, dss, dfdtopo, dfdsig, mss, style) ==let dst = MakeState(dfdid, dss, CollectExtDFs(dfdtopo)), msdescs = MakeMSDescs(dfdsig, mss), dfdop = MakeDFDOp(dfdid, dfdtopo, dfdsig, style) in (if (dst = nil)then ({dfdop} union msdescs)else ({dst, dfdop} union msdescs))MakeState' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DSs) * set of ((unresolved DEFAULT`FlowId)) -> [(unresolved DEFAULT`StateDef)])	MakeState(dfdid, dss, fids) ==(if ((dss = {}) and (fids = {}))then nilelse let fl = MakeFieldList((dss union fids)) in mk_StateDef(StateIdConf(dfdid), fl))MakeFieldList' (set of ((unresolved DEFAULT`StId)) -> seq of ((unresolved DEFAULT`Field)))	MakeFieldList(ids) ==(if (ids = {})then []else let id in set ids in ([MakeField(id)] ^ MakeFieldList((ids \ {id}))))Card' (set of ((unresolved DEFAULT`StId)) -> nat)	Card(s) ==(card s)MakeField' ((unresolved DEFAULT`StId) -> (unresolved DEFAULT`Field))	MakeField(id) ==mk_Field(StateVarConf(id), StateTypeConf(id))MakeMSDescs' ((unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`MSs) -> set of ((unresolved DEFAULT`Definition)))	MakeMSDescs(dfdsig, mss) ==(if (forall id in set (dom dfdsig) & is_(id, DFDId))then {}else let id in set (dom dfdsig) be st is_(id, MSId) in let def' = (if (id in set (dom mss))then mss(id)else MakeOp(id, dfdsig(id))) in ({def'} union MakeMSDescs(({id} <-' dfdsig), mss)))MakeOp' ((unresolved DEFAULT`MSId) * ((seq of ((unresolved DEFAULT`FlowId)) * seq of ((unresolved DEFAULT`FlowId)) * (unresolved DEFAULT`State))) -> (unresolved DEFAULT`ImplOp))	MakeOp(msid, mk_(din, out, dst)) ==let partpl = MakeInpPar(din), residtp = MakeOutPair(out), dext = MakeExt(dst), body = mk_ImplOpBody(nil, mk_BoolLit(true)) in mk_ImplOp(OpIdConf(msid), partpl, residtp, dext, body)MakeInpPar' (seq of ((unresolved DEFAULT`FlowId)) -> seq of ((unresolved DEFAULT`ParType)))	MakeInpPar(fidl) ==[mk_ParType(mk_PatternId(FlowIdVarConf(fidl(i))), FlowIdTypeConf(fidl(i))) | i in set (inds fidl)]MakeOutPair' (seq of ((unresolved DEFAULT`FlowId)) -> [(unresolved DEFAULT`IdType)])	MakeOutPair(fidl) ==(cases (len fidl) 'case 0 -> nil,case 1 -> mk_IdType(FlowIdVarConf((hd fidl)), FlowIdTypeConf((hd fidl)))others let t = mk_ProductType([FlowIdTypeConf(fidl(i)) | i in set (inds fidl)]) in mk_IdType(ResultIdConf(), t)end)MakeExt' ((unresolved DEFAULT`State) -> seq of ((unresolved DEFAULT`ExtVarInf)))	MakeExt(dst) ==[MakeExtVar(dst(i)) | i in set (inds dst)]MakeExtVar' ((((unresolved DEFAULT`StId) * (unresolved DEFAULT`Mode))) -> (unresolved DEFAULT`ExtVarInf))	MakeExtVar(mk_(id, mode)) ==mk_ExtVarInf(mode, VarConf(id), TypeConf(id))MakeDFDOp' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * ((<EXPL> | <IMPL>)) -> (unresolved DEFAULT`OpDef))	MakeDFDOp(dfdid, dfdtopo, dfdsig, style) ==(if (style = <EXPL>)then MakeDFDExplOp(dfdid, dfdtopo, dfdsig)else MakeDFDImplOp(dfdid, dfdtopo, dfdsig))	pre (if (style = <EXPL>)then pre_MakeDFDExplOp(dfdid, dfdtopo, dfdsig)else pre_MakeDFDImplOp(dfdid, dfdtopo, dfdsig))MakeDFDImplOp' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) -> (unresolved DEFAULT`ImplOp))	MakeDFDImplOp(dfdid, dfdtopo, dfdsig) ==let mk_(din, out, dst) = dfdsig(dfdid) in let partpl = MakeInpPar(din), residtp = MakeOutPair(out), dext = MakeExt(dst), body = MakeImplOpBody(dfdid, dfdtopo, dfdsig) in mk_ImplOp(OpIdConf(dfdid), partpl, residtp, dext, body)	pre ((dfdid in set (dom dfdsig)) and pre_MakeImplOpBody(dfdid, dfdtopo, dfdsig))MakeImplOpBody' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) -> (unresolved DEFAULT`ImplOpBody))	MakeImplOpBody(dfdid, dfdtopo, dfdsig) ==let intm = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))}, dpre = MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm), dpost = MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm) in mk_ImplOpBody(dpre, dpost)	pre let intm = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in (pre_MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) and pre_MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm))static private IntM = map ((unresolved DEFAULT`StId)) to (nat)MakePreExpr' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) ==let mk_(-, out, dst) = dfdsig(dfdid) in let fids = NeedsQuant(dfdtopo, dfdsig, {}, {}), pred = MakePrePred(dfdtopo, dfdsig, intm, maxm) in (if QuantNec(out, dst, fids, intm, maxm)then let bind = MakeExistsBind(fids, dst, intm, maxm, <PRE>) in mk_ExistsExpr(bind, pred)else pred)	pre (dfdid in set (dom dfdsig))MakePrePred' ((unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakePrePred(dfdtopo, dfdsig, intm, maxm) ==let eos = ExecutionOrders(dfdtopo) in DBinOp(<OR>, {MakePreForEO(piseq, dfdsig, intm, maxm) | [piseq in set eos]})MakePreForEO' (seq1 of ((unresolved DEFAULT`ProcId)) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakePreForEO(piseq, dfdsig, intm, maxm) ==let nid = (hd piseq) in let intm' = {stid |-> (if (mk_(stid, <READWRITE>) in set CollectStIds({dfdsig(nid)}))then (intm(stid) + 1)else intm(stid)) | stid in set (dom intm)} in let dpre = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <PRE>, <PRE>), dpost = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <PRE>, <POST>) in (if ((len piseq) = 1)then dpreelse let pred = mk_BinaryExpr(dpre, <AND>, dpost) in mk_BinaryExpr(pred, <AND>, MakePreForEO((tl piseq), dfdsig, intm', maxm)))MakePostExpr' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakePostExpr(dfdid, dfdtopo, dfdsig, intm, maxm) ==let mk_(-, out, dst) = dfdsig(dfdid), fids = NeedsQuant(dfdtopo, dfdsig, (elems out), {}), body = MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm) in (if ((len out) <= 1)then bodyelse mk_LetExpr(MakePattern(out), ResultIdConf(), body))	pre let mk_(-, out, dst) = dfdsig(dfdid), fids = NeedsQuant(dfdtopo, dfdsig, (elems out), {}) in pre_MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm)MakeInExpr' (seq of ((unresolved DEFAULT`FlowId)) * (unresolved DEFAULT`State) * set of ((unresolved DEFAULT`FlowId)) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakeInExpr(out, dst, fids, dfdtopo, dfdsig, intm, maxm) ==let pred = MakePostPred(dfdtopo, dfdsig, intm, maxm) in (if QuantNec(out, dst, fids, intm, maxm)then let bind = MakeExistsBind(fids, dst, intm, maxm, <POST>) in mk_ExistsExpr(bind, pred)else pred)	pre pre_MakeExistsBind(fids, dst, intm, maxm, <POST>)MakePostPred' ((unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakePostPred(dfdtopo, dfdsig, intm, maxm) ==let eos = ExecutionOrders(dfdtopo) in DBinOp(<OR>, {MakePostForEO(piseq, dfdsig, intm, maxm) | [piseq in set eos]})MakePostForEO' (seq1 of ((unresolved DEFAULT`ProcId)) * (unresolved DEFAULT`DFDSig) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> (unresolved DEFAULT`Expr))	MakePostForEO(piseq, dfdsig, intm, maxm) ==let nid = (hd piseq) in let intm' = {stid |-> (if (mk_(stid, <READWRITE>) in set CollectStIds({dfdsig(nid)}))then (intm(stid) + 1)else intm(stid)) | stid in set (dom intm)} in let dpre = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <POST>, <PRE>), dpost = MakeQuotedApply(nid, dfdsig(nid), intm', maxm, <POST>, <POST>) in (if ((len piseq) = 1)then mk_BinaryExpr(dpre, <AND>, dpost)else let pred = mk_BinaryExpr(dpre, <AND>, dpost) in mk_BinaryExpr(pred, <AND>, MakePostForEO((tl piseq), dfdsig, intm', maxm)))	pre let nid = (hd piseq) in ((nid in set (dom dfdsig)) and (pre_MakeQuotedApply(nid, dfdsig(nid), intm, maxm, <POST>, <PRE>) and pre_MakeQuotedApply(nid, dfdsig(nid), intm, maxm, <POST>, <POST>)))MakeExistsBind' (set of ((unresolved DEFAULT`FlowId)) * (unresolved DEFAULT`State) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) * ((<POST> | <PRE>)) -> (unresolved DEFAULT`MultTypeBind))	MakeExistsBind(fs, dst, intm, maxm, c) ==let outl = MakeTypeBindList(fs), stl = [let mk_(s, -) = dst(i), p = MakePatternIds(s, (intm(s) + 1), maxm(s), c) in mk_TypeBind(p, StateTypeConf(s)) | i in set (inds dst) & let mk_(-, m) = dst(i) in (m = <READWRITE>)] in mk_MultTypeBind((outl ^ stl))	pre (forall mk_(s, <READWRITE>) in set (elems dst) & ((s in set (dom intm)) and (s in set (dom maxm))))ExecutionOrders' ((unresolved DEFAULT`DFDTopo) -> set of (seq1 of ((unresolved DEFAULT`ProcId))))	ExecutionOrders(dfdtopo) ==let top = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or (is_(fid, MSId) or (fid = nil))) and (is_(tid, DFDId) or (is_(tid, MSId) or (tid = nil))))}, top2 = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in let piset = ((dunion {{pi_1, pi_2} | [mk_(pi_1, pi_2) in set top]}) \ {nil}) in {piseq | [piseq in set PossibleSeqs(piset)] & (forall i, j in set (inds piseq) & ((j < i) => (piseq(j) not in set TransClosure(piseq(i), top2, {}))))}MakeQuotedApply' ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId))) * (unresolved DEFAULT`Signature) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) * ((<POST> | <PRE>)) * ((<POST> | <PRE>)) -> (unresolved DEFAULT`Apply))	MakeQuotedApply(id, mk_(din, out, dst), intm, maxm, c, c2) ==let inarg = [FlowIdVarConf(din(i)) | i in set (inds din)], oldstarg = [let mk_(s, m) = dst(i) in (if (m = <READ>)then StateVarIntConf(s, intm(s), maxm(s), c)else StateVarIntConf(s, (intm(s) - 1), maxm(s), c)) | i in set (inds dst)], outarg = [FlowIdVarConf(out(i)) | i in set (inds out)], starg = [let mk_(s, -) = dst(i) in StateVarIntConf(s, intm(s), maxm(s), c) | i in set (inds dst) & let mk_(-, m) = dst(i) in (m = <READWRITE>)] in (if (c2 = <PRE>)then mk_Apply(("pre_" ^ OpIdConf(id)), (inarg ^ oldstarg))else mk_Apply(("post_" ^ OpIdConf(id)), (((inarg ^ oldstarg) ^ outarg) ^ starg)))	pre (forall mk_(s, m) in set (elems dst) & (((s in set (dom intm)) and ((s in set (dom maxm)) and (m = <READWRITE>))) => (intm(s) > 0)))MakeDFDExplOp' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) -> (unresolved DEFAULT`ExplOp))	MakeDFDExplOp(dfdid, dfdtopo, dfdsig) ==let mk_(din, -, -) = dfdsig(dfdid), eos = ExecutionOrders(dfdtopo), intm = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in let optype = MakeOpType(dfdsig(dfdid)), parms = [mk_PatternId(FlowIdVarConf(din(i))) | i in set (inds din)], bodys = {MakeStmtForEO(piseq, dfdid, dfdsig) | [piseq in set eos]}, dpre = MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) in let body = MakeNonDetStmt(bodys) in mk_ExplOp(OpIdConf(dfdid), optype, parms, body, dpre)	pre ((dfdid in set (dom dfdsig)) and let intm = {stid |-> 0 | mk_(stid, -) in set CollectStIds((rng dfdsig))}, maxm = {stid |-> Reduce(NoOfWr((rng dfdsig), stid)) | mk_(stid, -) in set CollectStIds((rng dfdsig))} in (pre_MakePreExpr(dfdid, dfdtopo, dfdsig, intm, maxm) and (forall piseq in set ExecutionOrders(dfdtopo) & pre_MakeStmtForEO(piseq, dfdid, dfdsig))))MakeStmtForEO' (seq1 of ((unresolved DEFAULT`ProcId)) * (unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDSig) -> (unresolved DEFAULT`Stmt))	MakeStmtForEO(piseq, dfdid, dfdsig) ==let nid = (hd piseq) in let mk_(call, pat) = MakeCallAndPat(nid, dfdsig(nid)), kind = FindKind(dfdsig(nid)) in (if ((len piseq) = 1)then let mk_(-, out, -) = dfdsig(dfdid) in let ret = mk_Return(MakeResult(out)) in (if (kind = <OPRES>)then mk_DefStmt(pat, call, ret)else mk_Sequence([call, ret]))else let rest = MakeStmtForEO((tl piseq), dfdid, dfdsig) in (if (kind = <OPRES>)then mk_DefStmt(pat, call, rest)else (if is_(rest, Sequence)then let mk_(unresolved DEFAULT`Sequence)(sl) = rest in mk_Sequence(([call] ^ sl))else mk_Sequence([call, rest]))))	pre ((hd piseq) in set (dom dfdsig))MakeCallAndPat' ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId))) * (unresolved DEFAULT`Signature) -> ((unresolved DEFAULT`Call) * [(unresolved DEFAULT`Pattern)]))	MakeCallAndPat(id, mk_(din, out, -)) ==let inarg = [FlowIdVarConf(din(i)) | i in set (inds din)], outarg = [FlowIdVarConf(out(i)) | i in set (inds out)] in mk_(mk_Call(OpIdConf(id), inarg), MakePattern(outarg))FindKind' ((unresolved DEFAULT`Signature) -> (<OPCALL> | <OPRES>))	FindKind(sig) ==(cases sig 'case mk_(-, [], -) -> <OPCALL>others <OPRES>end)MakePattern' (seq of ((unresolved DEFAULT`Id)) -> [(unresolved DEFAULT`Pattern)])	MakePattern(idl) ==(cases (len idl) 'case 0 -> nil,case 1 -> mk_PatternId((hd idl))others mk_TuplePattern([mk_PatternId(idl(i)) | i in set (inds idl)])end)MakeResult' (seq1 of ((unresolved DEFAULT`Id)) -> (unresolved DEFAULT`Expr))	MakeResult(idl) ==(if ((len idl) = 1)then FlowIdVarConf((hd idl))else mk_TupleConstructor([FlowIdVarConf(idl(i)) | i in set (inds idl)]))DBinOp' ((unresolved DEFAULT`BinaryOp) * set of ((unresolved DEFAULT`Expr)) -> (unresolved DEFAULT`Expr))	DBinOp(op, es) ==let e in set es in (if ((card es) = 1)then eelse mk_BinaryExpr(e, op, DBinOp(op, (es \ {e}))))	pre (es <> {})CollectExtDFs' ((unresolved DEFAULT`DFDTopo) -> set of ((unresolved DEFAULT`FlowId)))	CollectExtDFs(dfdtopo) =={fid | [fid in set (dom dfdtopo)] & let mk_(pid_1, pid_2) = dfdtopo(fid) in (is_(pid_1, EPId) or is_(pid_2, EPId))}NeedsQuant' ((unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) * set of ((unresolved DEFAULT`FlowId)) * set of ((unresolved DEFAULT`ProcId)) -> set of ((unresolved DEFAULT`FlowId)))	NeedsQuant(dfdtopo, dfdsig, notneeded, pids) ==let top = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in (if ((dom dfdsig) = pids)then {}else let pid in set ((dom dfdsig) \ pids) in (if ((TransClosure(pid, top, {}) = {}) and (EquivClass(top, {pid}) = (dom dfdsig)))then NeedsQuant(dfdtopo, dfdsig, notneeded, (pids union {pid}))else let mk_(-, out, -) = dfdsig(pid) in ((NeedsQuant(dfdtopo, dfdsig, notneeded, (pids union {pid})) union (elems out)) \ notneeded)))QuantNec' (seq of ((unresolved DEFAULT`FlowId)) * (unresolved DEFAULT`State) * set of ((unresolved DEFAULT`FlowId)) * (unresolved DEFAULT`IntM) * (unresolved DEFAULT`IntM) -> bool)	QuantNec(out, dst, fids, intm, maxm) ==((fids <> {}) or (exists [mk_(s, m) in set (elems dst)] & ((m = <READWRITE>) and (intm(s) < maxm(s)))))	pre (forall mk_(s, -) in set (elems dst) & ((s in set (dom intm)) and (s in set (dom maxm))))MakeTypeBindList' (set of ((unresolved DEFAULT`FlowId)) -> seq of ((unresolved DEFAULT`TypeBind)))	MakeTypeBindList(fids) ==(if (fids = {})then []else let fid in set fids in let pat = [mk_PatternId(FlowIdVarConf(fid))], first = mk_TypeBind(pat, FlowIdTypeConf(fid)) in ([first] ^ MakeTypeBindList((fids \ {fid}))))CardFId' (set of ((unresolved DEFAULT`FlowId)) -> nat)	CardFId(s) ==(card s)MakePatternIds' ((((unresolved DEFAULT`DSId) | (unresolved DEFAULT`Id))) * nat * nat * ((<POST> | <PRE>)) -> seq of ((unresolved DEFAULT`PatternId)))	MakePatternIds(id, n, max, c) ==(if ((n = max) and (c = <POST>))then [mk_PatternId(StateVarConf(id))]else (cases n 'case 0 -> (if (c = <PRE>)then [mk_PatternId(StateVarConf(id))]else [mk_PatternId(StateOldVarConf(id))])others MakePatternSeq(StateVarConf(id), n, max)end))MakePatternSeq' ((unresolved DEFAULT`Id) * nat * nat -> seq of ((unresolved DEFAULT`PatternId)))	MakePatternSeq(id, n, max) ==(if (n = max)then [mk_PatternId((id ^ "'"))]else ([mk_PatternId((id ^ "'"))] ^ MakePatternSeq((id ^ "'"), (n + 1), max)))	pre (n <= max)TowardsMax' ((unresolved DEFAULT`Id) * nat * nat -> nat)	TowardsMax(-, n, max) ==(max - n)EquivClass' (set of ((((unresolved DEFAULT`ProcId) * (unresolved DEFAULT`ProcId)))) * set of ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))) -> set of ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))))	EquivClass(top, ids) ==(if (exists [mk_(fid, tid) in set top] & (((fid in set ids) and (tid not in set ids)) or ((tid in set ids) and (fid not in set ids))))then let mk_(fid, tid) in set top be st (((fid in set ids) and (tid not in set ids)) or ((tid in set ids) and (fid not in set ids))) in EquivClass(top, (ids union {fid, tid}))else ids)MakeNonDetStmt' (set of ((unresolved DEFAULT`Stmt)) -> (unresolved DEFAULT`Stmt))	MakeNonDetStmt(stmts) ==(cases (card stmts) 'case 1 -> let {s} = stmts in sothers mk_NonDetStmt(stmts)end)	pre ((card stmts) <> 0)CollectStIds' (set of ((unresolved DEFAULT`Signature)) -> set of ((((unresolved DEFAULT`StId) * (unresolved DEFAULT`Mode)))))	CollectStIds(sigs) ==(dunion {(elems dst) | [mk_(-, -, dst) in set sigs]})NoOfWr' (set of ((unresolved DEFAULT`Signature)) * (unresolved DEFAULT`StId) -> nat)	NoOfWr(sigs, stid) ==(if (sigs = {})then 0else let sig in set sigs in let mk_(-, -, dst) = sig in (if (mk_(stid, <READWRITE>) in set (elems dst))then (1 + NoOfWr((sigs \ {sig}), stid))else NoOfWr((sigs \ {sig}), stid)))Reduce' (nat -> nat)	Reduce(n) ==(if ((n = 0) or (n = 1))then nelse (n - 1))ModIdConf' ((unresolved DEFAULT`DFDId) -> (unresolved DEFAULT`Id))	ModIdConf(mk_(unresolved DEFAULT`DFDId)(id)) ==(id ^ "Module")StateIdConf' ((unresolved DEFAULT`DFDId) -> (unresolved DEFAULT`Id))	StateIdConf(mk_(unresolved DEFAULT`DFDId)(id)) ==(id ^ "State")DSIdConf' ((unresolved DEFAULT`DSId) -> (unresolved DEFAULT`Id))	DSIdConf(mk_(unresolved DEFAULT`DSId)(id)) ==idOpIdConf' (((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`Id) | (unresolved DEFAULT`MSId)) -> (unresolved DEFAULT`Id))	OpIdConf(id) ==(cases id 'case mk_(unresolved DEFAULT`MSId)(id') -> id',case mk_(unresolved DEFAULT`DFDId)(id') -> id'others idend)StateVarIntConf' ((((unresolved DEFAULT`DSId) | (unresolved DEFAULT`Id))) * nat * nat * ((<POST> | <PRE>)) -> (unresolved DEFAULT`Id))	StateVarIntConf(id, n, max, c) ==(if ((max = n) and (c = <POST>))then StateVarConf(id)else (cases n 'case 0 -> (if (c = <PRE>)then StateVarConf(id)else StateOldVarConf(id)),case 1 -> (StateVarConf(id) ^ "'")others (StateVarIntConf(id, (n - 1), max, c) ^ "'")end))VarConf' ((unresolved DEFAULT`StId) -> (unresolved DEFAULT`Id))	VarConf(id) ==(if is_(id, DSId)then StateVarConf(id)else FlowIdVarConf(id))TypeConf' (((unresolved DEFAULT`DSId) | (unresolved DEFAULT`FlowId)) -> (unresolved DEFAULT`Id))	TypeConf(id) ==(if is_(id, DSId)then StateTypeConf(id)else FlowIdTypeConf(id))FlowIdVarConf' ((unresolved DEFAULT`Id) -> (unresolved DEFAULT`Id))	FlowIdVarConf(id) ==ToLower(id)FlowIdTypeConf' ((unresolved DEFAULT`Id) -> (unresolved DEFAULT`Id))	FlowIdTypeConf(id) ==ToUpper(id)StateTypeConf' (((unresolved DEFAULT`DSId) | (unresolved DEFAULT`Id)) -> (unresolved DEFAULT`Id))	StateTypeConf(id) ==ToUpper(id)StateVarConf' (((unresolved DEFAULT`DSId) | (unresolved DEFAULT`Id)) -> (unresolved DEFAULT`Id))	StateVarConf(id) ==ToLower(id)StateOldVarConf' (((unresolved DEFAULT`DSId) | (unresolved DEFAULT`Id)) -> (unresolved DEFAULT`Id))	StateOldVarConf(id) ==(ToLower(id) ^ "old")TypeModConf' (() -> (unresolved DEFAULT`Id))	TypeModConf() =="TypeModule"ResultIdConf' (() -> (unresolved DEFAULT`Id))	ResultIdConf() =="r"PossibleSeqs' (set of ((unresolved DEFAULT`ProcId)) -> set of (seq of ((unresolved DEFAULT`ProcId))))	PossibleSeqs(pids) ==(if (pids = {})then {}else (if ((card pids) = 1)then {[pid] | [pid in set pids]}else let pid in set pids in let rest = PossibleSeqs((pids \ {pid})) in (dunion {InsertPId(pid, seq') | [seq' in set rest]})))CardPSet' (set of ((unresolved DEFAULT`ProcId)) -> nat)	CardPSet(s) ==(card s)InsertPId' ((unresolved DEFAULT`ProcId) * seq of ((unresolved DEFAULT`ProcId)) -> set of (seq of ((unresolved DEFAULT`ProcId))))	InsertPId(pid, seq') =={(((seq'(1, ... ,i)) ^ [pid]) ^ (seq'((i + 1), ... ,(len seq')))) | [i in set {0, ... ,(len seq')}]}ToLower' (((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`DSId) | (unresolved DEFAULT`EPId) | (unresolved DEFAULT`Id) | (unresolved DEFAULT`MSId)) -> (unresolved DEFAULT`Id))	ToLower(id) ==let realid = (cases id 'case mk_(unresolved DEFAULT`DSId)(id') -> id',case mk_(unresolved DEFAULT`DFDId)(id') -> id',case mk_(unresolved DEFAULT`EPId)(id') -> id',case mk_(unresolved DEFAULT`MSId)(id') -> id'others idend) in [LowerChar(realid(i)) | i in set (inds realid)]LowerChar' (char -> char)	LowerChar(c) ==(cases c 'case char value [A] -> 'a',case char value [B] -> 'b',case char value [C] -> 'c',case char value [D] -> 'd',case char value [E] -> 'e',case char value [F] -> 'f',case char value [G] -> 'g',case char value [H] -> 'h',case char value [I] -> 'i',case char value [J] -> 'j',case char value [K] -> 'k',case char value [L] -> 'l',case char value [M] -> 'm',case char value [N] -> 'n',case char value [O] -> 'o',case char value [P] -> 'p',case char value [Q] -> 'q',case char value [R] -> 'r',case char value [S] -> 's',case char value [T] -> 't',case char value [U] -> 'u',case char value [V] -> 'v',case char value [W] -> 'w',case char value [X] -> 'x',case char value [Y] -> 'y',case char value [Z] -> 'z'others cend)ToUpper' (((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`DSId) | (unresolved DEFAULT`EPId) | (unresolved DEFAULT`Id) | (unresolved DEFAULT`MSId)) -> (unresolved DEFAULT`Id))	ToUpper(id) ==let realid = (cases id 'case mk_(unresolved DEFAULT`DSId)(id') -> id',case mk_(unresolved DEFAULT`DFDId)(id') -> id',case mk_(unresolved DEFAULT`EPId)(id') -> id',case mk_(unresolved DEFAULT`MSId)(id') -> id'others idend) in [UpperChar(realid(i)) | i in set (inds realid)]UpperChar' (char -> char)	UpperChar(c) ==(cases c 'case char value [a] -> 'A',case char value [b] -> 'B',case char value [c] -> 'C',case char value [d] -> 'D',case char value [e] -> 'E',case char value [f] -> 'F',case char value [g] -> 'G',case char value [h] -> 'H',case char value [i] -> 'I',case char value [j] -> 'J',case char value [k] -> 'K',case char value [l] -> 'L',case char value [m] -> 'M',case char value [n] -> 'N',case char value [o] -> 'O',case char value [p] -> 'P',case char value [q] -> 'Q',case char value [r] -> 'R',case char value [s] -> 'S',case char value [t] -> 'T',case char value [u] -> 'U',case char value [v] -> 'V',case char value [w] -> 'W',case char value [x] -> 'X',case char value [y] -> 'Y',case char value [z] -> 'Z'others cend)static private SA = ((unresolved DEFAULT`HDFD) * (unresolved DEFAULT`DD) * (unresolved DEFAULT`MSs))	inv mk_(hdfd, dd, -) == (FlowTypeDefined(hdfd, dd) and TopLevelSigOK(hdfd))static private HDFD = ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DSs) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDMap) * (unresolved DEFAULT`DFDSig))static private DSs = set of ((unresolved DEFAULT`DSId))static private DSId = compose DSId of 1'seq of (char) endstatic private DFDTopo = map ((unresolved DEFAULT`FlowId)) to ((([(unresolved DEFAULT`ProcId)] * [(unresolved DEFAULT`ProcId)])))	inv dfdtopo == let top = {mk_(fid, tid) | [mk_(fid, tid) in set (rng dfdtopo)] & ((is_(fid, DFDId) or is_(fid, MSId)) and (is_(tid, DFDId) or is_(tid, MSId)))} in (NotRecursive(top) and (forall flowid in set (dom dfdtopo) & FlowConnectOK(dfdtopo(flowid))))static private FlowId = seq of (char)static private ProcId = ((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`EPId) | (unresolved DEFAULT`MSId))static private DFDMap = map ((unresolved DEFAULT`DFDId)) to ((unresolved DEFAULT`HDFD))static private DFDSig = map ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))) to ((unresolved DEFAULT`Signature))static private Signature = ((unresolved DEFAULT`Input) * (unresolved DEFAULT`Output) * (unresolved DEFAULT`State))	inv mk_(-, out, sta) == ((sta = []) => (((out <> []) and (out = [])) => (exists [mk_(-, m) in set (elems sta)] & (m = <READWRITE>))))static private Input = seq of ((unresolved DEFAULT`FlowId))static private Output = seq of ((unresolved DEFAULT`FlowId))static private State = seq of ((((unresolved DEFAULT`StId) * (unresolved DEFAULT`Mode))))static private StId = ((unresolved DEFAULT`DSId) | (unresolved DEFAULT`FlowId))static private Mode = (<READ> | <READWRITE>)static private DD = map ((unresolved DEFAULT`Id)) to ((unresolved DEFAULT`Type))static private MSs = map ((unresolved DEFAULT`MSId)) to ((unresolved DEFAULT`MS))static private MS = (unresolved DEFAULT`OpDef)static private DFDId = compose DFDId of 1'seq of (char) endstatic private EPId = compose EPId of 1'seq of (char) endstatic private MSId = compose MSId of 1'seq of (char) endFlowTypeDefined' ((unresolved DEFAULT`HDFD) * (unresolved DEFAULT`DD) -> bool)	FlowTypeDefined(mk_(-, -, dfdtop, -, -), dd) ==(forall fid in set (dom dfdtop) & (FlowIdTypeConf(fid) in set (dom dd)))TopLevelSigOK' ((unresolved DEFAULT`HDFD) -> bool)	TopLevelSigOK(mk_(sysid, -, dfdtop, -, dfdsig)) ==((sysid in set (dom dfdsig)) and let mk_(din, out, dst) = dfdsig(sysid) in ((din = []) and ((out = []) and (forall flowid in set (dom dfdtop) & let mk_(fid, tid) = dfdtop(flowid) in ((is_(fid, EPId) => (mk_(flowid, <READ>) in set (elems dst))) and (is_(tid, EPId) => (mk_(flowid, <READWRITE>) in set (elems dst))))))))DFDSigConsistent' ((unresolved DEFAULT`DFDId) * (unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DSs) * (unresolved DEFAULT`DFDMap) * (unresolved DEFAULT`DFDSig) -> bool)	DFDSigConsistent(id, dfdtop, dss, dfdmap, dfdsig) ==(DSConnected(dss, dfdsig) and (SigsAllRight(dfdtop, dfdsig) and (IdsInSigsAvail(dss, dfdtop, (rng dfdsig)) and SigsForAllUsedIds(id, (rng dfdtop), dfdmap, dfdsig))))DSConnected' ((unresolved DEFAULT`DSs) * (unresolved DEFAULT`DFDSig) -> bool)	DSConnected(dss, dfdsig) ==(forall dsid in set dss & (exists [mk_(-, -, dst) in set (rng dfdsig)] & (exists [i in set (inds dst)] & let mk_(id, -) = dst(i) in (dsid = id))))SigsAllRight' ((unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDSig) -> bool)	SigsAllRight(dfdtop, dfdsig) ==(forall flowid in set (dom dfdtop) & (cases dfdtop(flowid) 'case mk_(id, mk_(unresolved DEFAULT`EPId)(-)) -> let mk_(-, -, dst) = dfdsig(id) in (mk_(flowid, <READWRITE>) in set (elems dst)),case mk_(mk_(unresolved DEFAULT`EPId)(-), id) -> let mk_(-, -, dst) = dfdsig(id) in (mk_(flowid, <READ>) in set (elems dst)),case mk_(nil, id) -> let mk_(din, -, -) = dfdsig(id) in (flowid in set (elems din)),case mk_(id, nil) -> let mk_(-, out, -) = dfdsig(id) in (flowid in set (elems out)),case mk_(fid, tid) -> let mk_(-, out, -) = dfdsig(fid), mk_(din, -, -) = dfdsig(tid) in ((flowid in set (elems out)) and (flowid in set (elems din)))end))IdsInSigsAvail' ((unresolved DEFAULT`DSs) * (unresolved DEFAULT`DFDTopo) * set of ((unresolved DEFAULT`Signature)) -> bool)	IdsInSigsAvail(dss, dfdtop, sigs) ==let fids = CollectExtDFs(dfdtop) in (forall mk_(din, out, dst) in set sigs & (((elems din) subset (dom dfdtop)) and (((elems out) subset (dom dfdtop)) and ((elems dst) subset {mk_(id, m) | [id in set (dss union fids), m in set {<READ>, <READWRITE>}]}))))LowerLevelUsed' ((unresolved DEFAULT`DFDTopo) * (unresolved DEFAULT`DFDMap) -> bool)	LowerLevelUsed(dfdtop, dfdmap) ==let ids = (dom dfdmap) in (forall mk_(fid, tid) in set (rng dfdtop) & ((is_(fid, DFDId) => (fid in set ids)) and (is_(tid, DFDId) => (tid in set ids))))SigsForAllUsedIds' ((unresolved DEFAULT`DFDId) * set of ((([(unresolved DEFAULT`ProcId)] * [(unresolved DEFAULT`ProcId)]))) * (unresolved DEFAULT`DFDMap) * (unresolved DEFAULT`DFDSig) -> bool)	SigsForAllUsedIds(id, top, dfdmap, dfdsig) ==((forall dfdid in set (dom dfdmap) & let mk_(-, -, -, -, dfdsig') = dfdmap(dfdid) in (dfdsig'(dfdid) = dfdsig(dfdid))) and let sigs = (dom dfdsig) in ((id in set sigs) and (forall mk_(fid, tid) in set top & (((is_(fid, MSId) or is_(fid, DFDId)) => (fid in set sigs)) and ((is_(tid, MSId) or is_(tid, DFDId)) => (tid in set sigs))))))FlowConnectOK' ((([(unresolved DEFAULT`ProcId)] * [(unresolved DEFAULT`ProcId)])) -> bool)	FlowConnectOK(mk_(fid, tid)) ==(((is_(fid, EPId) or (fid = nil)) => (is_(tid, DFDId) or is_(tid, MSId))) and ((is_(tid, EPId) or (tid = nil)) => (is_(fid, DFDId) or is_(fid, MSId))))NotRecursive' (set of ((((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId))) * (((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))))) -> bool)	NotRecursive(top) ==(forall mk_(f, -) in set top & (f not in set TransClosure(f, top, {})))TransClosure' ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId))) * set of ((((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId))) * (((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))))) * set of ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))) -> set of ((((unresolved DEFAULT`DFDId) | (unresolved DEFAULT`MSId)))))	TransClosure(pid, top, dset) ==(if (exists [mk_(fromid, toid) in set top] & (((fromid = pid) or (fromid in set dset)) and (toid not in set dset)))then let mk_(fromid, toid) in set top be st (((fromid = pid) or (fromid in set dset)) and (toid not in set dset)) in TransClosure(pid, top, (dset union {toid}))else dset)static private Document = set of ((unresolved DEFAULT`Module))static private Module = ((unresolved DEFAULT`ModuleId) * (unresolved DEFAULT`Interface) * (unresolved DEFAULT`Definitions))static private ModuleId = seq of (char)static private Interface = ((unresolved DEFAULT`Imports) * (unresolved DEFAULT`Export))static private Imports = set of ((unresolved DEFAULT`Import))static private Import = ((unresolved DEFAULT`ModuleId) * (unresolved DEFAULT`ModuleSig))static private Export = (unresolved DEFAULT`ModuleSig)static private ModuleSig = set of ((unresolved DEFAULT`Sig))static private Sig = ((unresolved DEFAULT`OpSig) | (unresolved DEFAULT`TypeSig))static private TypeSig = compose TypeSig of 1'(unresolved DEFAULT`TypeId) endstatic private TypeId = seq of (char)static private OpSig = compose OpSig of id'(unresolved DEFAULT`Id), optype'(unresolved DEFAULT`OpType), stids'seq of ((unresolved DEFAULT`Id)) endstatic private Definitions = set of ((unresolved DEFAULT`Definition))static private Definition = ((unresolved DEFAULT`OpDef) | (unresolved DEFAULT`StateDef))static private StateDef = compose StateDef of id'(unresolved DEFAULT`Id), fields'seq of ((unresolved DEFAULT`Field)) endstatic private Field = compose Field of sel'[(unresolved DEFAULT`Id)], type'(unresolved DEFAULT`Type) endstatic private OpDef = ((unresolved DEFAULT`ExplOp) | (unresolved DEFAULT`ImplOp))static private ExplOp = compose ExplOp of id'(unresolved DEFAULT`Id), optype'(unresolved DEFAULT`OpType), parms'seq of ((unresolved DEFAULT`Pattern)), body'(unresolved DEFAULT`Stmt), dpre'(unresolved DEFAULT`Expr) endstatic private ImplOp = compose ImplOp of id'(unresolved DEFAULT`Id), partp'seq of ((unresolved DEFAULT`ParType)), residtp'[(unresolved DEFAULT`IdType)], dext'seq of ((unresolved DEFAULT`ExtVarInf)), body'(unresolved DEFAULT`ImplOpBody) endstatic private ImplOpBody = compose ImplOpBody of dpre'[(unresolved DEFAULT`Expr)], dpost'(unresolved DEFAULT`Expr) endstatic private ParType = compose ParType of pat'(unresolved DEFAULT`Pattern), type'(unresolved DEFAULT`Type) endstatic private IdType = compose IdType of id'(unresolved DEFAULT`Id), type'(unresolved DEFAULT`Type) endstatic private ExtVarInf = compose ExtVarInf of mode'(unresolved DEFAULT`ReadWriteMode), id'(unresolved DEFAULT`Id), type'(unresolved DEFAULT`Type) endstatic private ReadWriteMode = (<READ> | <READWRITE>)static private OpType = compose OpType of dom''[(unresolved DEFAULT`Type)], rng''[(unresolved DEFAULT`Type)] endstatic private Type = ((unresolved DEFAULT`BasicType) | (unresolved DEFAULT`EnumType) | (unresolved DEFAULT`MapType) | (unresolved DEFAULT`OptionalType) | (unresolved DEFAULT`ProductType) | (unresolved DEFAULT`SeqType) | (unresolved DEFAULT`SetType) | (unresolved DEFAULT`TypeId) | (unresolved DEFAULT`UnionType))static private ProductType = compose ProductType of product'seq1 of ((unresolved DEFAULT`Type)) endstatic private MapType = compose MapType of d'(unresolved DEFAULT`Type), r'(unresolved DEFAULT`Type) endstatic private SetType = compose SetType of 1'(unresolved DEFAULT`Type) endstatic private SeqType = compose SeqType of 1'(unresolved DEFAULT`Type) endstatic private BasicType = (<BOOL> | <CHAR> | <TOKEN>)static private EnumType = compose EnumType of 1'seq of (char) endstatic private OptionalType = compose OptionalType of 1'(unresolved DEFAULT`Type) endstatic private UnionType = compose UnionType of 1'set of ((unresolved DEFAULT`Type)) endstatic private Stmt = ((unresolved DEFAULT`Call) | (unresolved DEFAULT`DclStmt) | (unresolved DEFAULT`DefStmt) | (unresolved DEFAULT`NonDetStmt) | (unresolved DEFAULT`Return) | (unresolved DEFAULT`Sequence) | <IDENT>)static private DclStmt = compose DclStmt of dcls'set of ((unresolved DEFAULT`AssDef)), body'(unresolved DEFAULT`Stmt) endstatic private AssDef = compose AssDef of var'(unresolved DEFAULT`Id), tp'(unresolved DEFAULT`Type) endstatic private DefStmt = compose DefStmt of lhs'(unresolved DEFAULT`Pattern), rhs'((unresolved DEFAULT`Call) | (unresolved DEFAULT`Expr)), din'(unresolved DEFAULT`Stmt) endstatic private NonDetStmt = compose NonDetStmt of stmts'set of ((unresolved DEFAULT`Stmt)) endstatic private Call = compose Call of oprt'(unresolved DEFAULT`Id), args'seq of ((unresolved DEFAULT`Expr)) endstatic private Sequence = compose Sequence of stmts'seq1 of ((unresolved DEFAULT`Stmt)) endstatic private Return = compose Return of val'[(unresolved DEFAULT`Expr)] endstatic private Expr = ((unresolved DEFAULT`Apply) | (unresolved DEFAULT`BinaryExpr) | (unresolved DEFAULT`BoolLit) | (unresolved DEFAULT`Id) | (unresolved DEFAULT`IfExpr) | (unresolved DEFAULT`LetExpr) | (unresolved DEFAULT`QuantExpr) | (unresolved DEFAULT`TupleConstructor))static private LetExpr = compose LetExpr of lhs'(unresolved DEFAULT`Pattern), rhs'(unresolved DEFAULT`Expr), din'(unresolved DEFAULT`Expr) endstatic private IfExpr = compose IfExpr of test'(unresolved DEFAULT`Expr), con'(unresolved DEFAULT`Expr), alt'(unresolved DEFAULT`Expr) endstatic private QuantExpr = (unresolved DEFAULT`ExistsExpr)static private ExistsExpr = compose ExistsExpr of bind'(unresolved DEFAULT`MultTypeBind), pred'(unresolved DEFAULT`Expr) endstatic private BinaryExpr = compose BinaryExpr of left'(unresolved DEFAULT`Expr), op'(unresolved DEFAULT`BinaryOp), right'(unresolved DEFAULT`Expr) endstatic private BinaryOp = (<AND> | <EQUAL> | <MEMB> | <OR>)static private TupleConstructor = compose TupleConstructor of fields'seq1 of ((unresolved DEFAULT`Expr)) endstatic private Apply = compose Apply of name'(unresolved DEFAULT`Expr), arg'seq of ((unresolved DEFAULT`Expr)) endstatic private BoolLit = compose BoolLit of 1'bool endstatic private MultTypeBind = compose MultTypeBind of mtb'seq1 of ((unresolved DEFAULT`TypeBind)) endstatic private TypeBind = compose TypeBind of pats'seq of ((unresolved DEFAULT`Pattern)), tp'(unresolved DEFAULT`Type) endstatic private Pattern = ((unresolved DEFAULT`PatternId) | (unresolved DEFAULT`TuplePattern))static private PatternId = compose PatternId of name'[(unresolved DEFAULT`Id)] endstatic private TuplePattern = compose TuplePattern of fields'seq1 of ((unresolved DEFAULT`Pattern)) endstatic private Id = seq of (char)end DEFAULT
