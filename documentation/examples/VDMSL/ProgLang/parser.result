RESULT:result:-1:-1,-1:module ASTexportsexport alldefinitionsstatic private Program = compose Program of decls'seq of ((unresolved AST`Declaration)), stmt'(unresolved AST`Stmt) endstatic private Declaration = compose Declaration of id'(unresolved AST`Identifier), tp'(unresolved AST`Type), val'[(unresolved AST`Value)] endstatic private Identifier = seq1 of (char)static private Type = (<BoolType> | <IntType>)static private Value = ((unresolved AST`BoolVal) | (unresolved AST`IntVal))static private BoolVal = compose BoolVal of val'bool endstatic private IntVal = compose IntVal of val'int endstatic private Stmt = ((unresolved AST`AssignStmt) | (unresolved AST`BlockStmt) | (unresolved AST`CondStmt) | (unresolved AST`ForStmt) | (unresolved AST`RepeatStmt))static private BlockStmt = compose BlockStmt of decls'seq of ((unresolved AST`Declaration)), stmts'seq1 of ((unresolved AST`Stmt)) endstatic private AssignStmt = compose AssignStmt of lhs'(unresolved AST`Variable), rhs'(unresolved AST`Expr) endstatic private Variable = compose Variable of id'(unresolved AST`Identifier) endstatic private Expr = ((unresolved AST`BinaryExpr) | (unresolved AST`Value) | (unresolved AST`Variable))static private BinaryExpr = compose BinaryExpr of lhs'(unresolved AST`Expr), op'(unresolved AST`Operator), rhs'(unresolved AST`Expr) endstatic private Operator = (<Add> | <And> | <Div> | <Eq> | <Gt> | <Lt> | <Mul> | <Or> | <Sub>)static private CondStmt = compose CondStmt of guard'(unresolved AST`Expr), thenst'(unresolved AST`Stmt), elsest'(unresolved AST`Stmt) endstatic private ForStmt = compose ForStmt of start'(unresolved AST`AssignStmt), stop'(unresolved AST`Expr), stmt'(unresolved AST`Stmt) endstatic private RepeatStmt = compose RepeatStmt of repeat'(unresolved AST`Stmt), until'(unresolved AST`Expr) endend AST, module Testimportsfrom ASTimport allfrom STATSEMimport allfrom DYNSEMimport allexportsexport alldefinitionsstatic private binexpr'(unresolved AST`Expr) = mk_AST`BinaryExpr(mk_AST`IntVal(4), <Add>, mk_AST`IntVal(5))RunTypeCheck' (() -> (bool * [(unresolved AST`Type)]))	RunTypeCheck() ==STATSEM`wf_Expr(binexpr, {})RunEval' (() -> (unresolved AST`Value))	RunEval() ==DYNSEM`EvalExpr(binexpr, {})end Test, module DYNSEMimportsfrom ASTimport allfrom STATSEMimport allexportsexport alldefinitionsstatic private DynEnv = map ((unresolved AST`Identifier)) to ((unresolved AST`Value))EvalProgram' ((unresolved AST`Program) -> (unresolved DYNSEM`DynEnv))	EvalProgram(mk_(unresolved AST`Program)(decls, stmt)) ==EvalStmt(stmt, EvalDeclarations(decls))	pre (STATSEM`wf_Program(mk_AST`Program(decls, stmt)) and pre_EvalStmt(stmt, EvalDeclarations(decls)))EvalDeclarations' (seq of ((unresolved AST`Declaration)) -> (unresolved DYNSEM`DynEnv))	EvalDeclarations(decls) =={id |-> (if (val <> nil)then valelseif (tp = <BoolType>)then mk_AST`BoolVal(false)else mk_AST`IntVal(0)) | mk_(unresolved AST`Declaration)(id, tp, val) in set (elems decls)}EvalStmt' ((unresolved AST`Stmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalStmt(stmt, denv) ==(cases true 'case (is_(stmt, AST`BlockStmt)) -> EvalBlockStmt(stmt, denv),case (is_(stmt, AST`AssignStmt)) -> EvalAssignStmt(stmt, denv),case (is_(stmt, AST`CondStmt)) -> EvalCondStmt(stmt, denv),case (is_(stmt, AST`ForStmt)) -> EvalForStmt(stmt, denv),case (is_(stmt, AST`RepeatStmt)) -> EvalRepeatStmt(stmt, denv)end)	pre ((is_(stmt, AST`BlockStmt) => pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) => pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) => pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) => pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) => pre_EvalRepeatStmt(stmt, denv))))))EvalBlockStmt' ((unresolved AST`BlockStmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalBlockStmt(mk_(unresolved AST`BlockStmt)(decls, stmts), denv) ==let ldenv = EvalDeclarations(decls) in let denv' = EvalStmts(stmts, (denv ++ ldenv)) in (denv ++ ((dom ldenv) <-' denv'))	pre let ldenv = EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv))EvalStmts' (seq of ((unresolved AST`Stmt)) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalStmts(stmts, denv) ==(cases stmts 'case [] -> denvothers EvalStmts((tl stmts), EvalStmt((hd stmts), denv))end)	pre ((stmts <> []) => pre_EvalStmt((hd stmts), denv))LenStmt' (seq of ((unresolved AST`Stmt)) * (unresolved DYNSEM`DynEnv) -> nat)	LenStmt(l, -) ==(len l)EvalAssignStmt' ((unresolved AST`AssignStmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalAssignStmt(mk_(unresolved AST`AssignStmt)(lhs, rhs), denv) ==(denv ++ {(lhs.id) |-> EvalExpr(rhs, denv)})	pre pre_EvalExpr(rhs, denv)EvalCondStmt' ((unresolved AST`CondStmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalCondStmt(mk_(unresolved AST`CondStmt)(guard, thenst, elsest), denv) ==(if (EvalExpr(guard, denv).val)then EvalStmt(thenst, denv)else EvalStmt(elsest, denv))	pre (pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)then pre_EvalStmt(thenst, denv)else pre_EvalStmt(elsest, denv)))EvalRepeatStmt' ((unresolved AST`RepeatStmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalRepeatStmt(mk_(unresolved AST`RepeatStmt)(repeat, until), denv) ==let denv' = EvalStmt(repeat, denv) in (if (EvalExpr(until, denv').val)then denv'else EvalRepeatStmt(mk_AST`RepeatStmt(repeat, until), denv'))	pre (pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv)))EvalForStmt' ((unresolved AST`ForStmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalForStmt(mk_(unresolved AST`ForStmt)(start, stop, stmt), denv) ==let denv' = EvalAssignStmt(start, denv) in EvalForLoop((start.lhs), EvalExpr(stop, denv'), stmt, denv')	pre (pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv)))EvalForLoop' ((unresolved AST`Variable) * (unresolved AST`Value) * (unresolved AST`Stmt) * (unresolved DYNSEM`DynEnv) -> (unresolved DYNSEM`DynEnv))	EvalForLoop(mk_(unresolved AST`Variable)(id), val, stmt, denv) ==(if ((denv(id).val) <= (val.val))then let denv' = EvalStmt(stmt, denv) in EvalForLoop(mk_AST`Variable(id), val, stmt, (denv' ++ {id |-> mk_AST`IntVal(((denv'(id).val) + 1))}))else denv)	pre pre_EvalStmt(stmt, denv)LoopParInc' ((unresolved AST`Variable) * (unresolved AST`Value) * (unresolved AST`Stmt) * (unresolved DYNSEM`DynEnv) -> nat)	LoopParInc(mk_(unresolved AST`Variable)(id), val, -, denv) ==((val.val) - (denv(id).val))EvalExpr' ((unresolved AST`Expr) * (unresolved DYNSEM`DynEnv) -> (unresolved AST`Value))	EvalExpr(ex, denv) ==(cases ex 'case mk_(unresolved AST`BoolVal)(-) -> ex,case mk_(unresolved AST`IntVal)(-) -> ex,case mk_(unresolved AST`Variable)(id) -> denv(id),case mk_(unresolved AST`BinaryExpr)(-, -, -) -> EvalBinaryExpr(ex, denv)end)	pre (is_(ex, AST`BinaryExpr) => pre_EvalBinaryExpr(ex, denv))EvalBinaryExpr' ((unresolved AST`BinaryExpr) * (unresolved DYNSEM`DynEnv) -> (unresolved AST`Value))	EvalBinaryExpr(mk_(unresolved AST`BinaryExpr)(lhs, op, rhs), denv) ==let v1 = (EvalExpr(lhs, denv).val), v2 = (EvalExpr(rhs, denv).val) in (cases op 'case <Add> -> mk_AST`IntVal((v1 + v2)),case <Sub> -> mk_AST`IntVal((v1 - v2)),case <Div> -> mk_AST`IntVal((v1 div v2)),case <Mul> -> mk_AST`IntVal((v1 * v2)),case <Lt> -> mk_AST`BoolVal((v1 < v2)),case <Gt> -> mk_AST`BoolVal((v1 > v2)),case <Eq> -> mk_AST`BoolVal((v1 = v2)),case <And> -> mk_AST`BoolVal((v1 and v2)),case <Or> -> mk_AST`BoolVal((v1 or v2))end)	pre ((op = <Div>) => ((EvalExpr(rhs, denv).val) <> 0))end DYNSEM, module STATSEMimportsfrom ASTimport allexportsexport alldefinitionsstatic private StatEnv = map ((unresolved AST`Identifier)) to ((unresolved AST`Type))wf_Program' ((unresolved AST`Program) -> bool)	wf_Program(mk_(unresolved AST`Program)(decls, stmt)) ==(wf_Declarations(decls) and wf_Stmt(stmt, get_Declarations(decls)))wf_Declarations' (seq of ((unresolved AST`Declaration)) -> bool)	wf_Declarations(decls) ==((forall i1, i2 in set (inds decls) & ((i1 <> i2) => ((decls(i1).id) <> (decls(i2).id)))) and (forall i in set (inds decls) & (((decls(i).val) <> nil) => ((is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) = <BoolType>)) or (is_((decls(i).val), AST`IntVal) and ((decls(i).tp) = <IntType>))))))get_Declarations' (seq of ((unresolved AST`Declaration)) -> (unresolved STATSEM`StatEnv))	get_Declarations(decls) =={id |-> tp | mk_(unresolved AST`Declaration)(id, tp, -) in set (elems decls)}wf_Stmt' ((unresolved AST`Stmt) * (unresolved STATSEM`StatEnv) -> bool)	wf_Stmt(stmt, senv) ==(cases true 'case (is_(stmt, AST`BlockStmt)) -> wf_BlockStmt(stmt, senv),case (is_(stmt, AST`AssignStmt)) -> let mk_(wf_ass, -) = wf_AssignStmt(stmt, senv) in wf_ass,case (is_(stmt, AST`CondStmt)) -> wf_CondStmt(stmt, senv),case (is_(stmt, AST`ForStmt)) -> wf_ForStmt(stmt, senv),case (is_(stmt, AST`RepeatStmt)) -> wf_RepeatStmt(stmt, senv)others falseend)wf_BlockStmt' ((unresolved AST`BlockStmt) * (unresolved STATSEM`StatEnv) -> bool)	wf_BlockStmt(mk_(unresolved AST`BlockStmt)(decls, stmts), senv) ==(wf_Declarations(decls) and wf_Stmts(stmts, (senv ++ get_Declarations(decls))))wf_Stmts' (seq of ((unresolved AST`Stmt)) * (unresolved STATSEM`StatEnv) -> bool)	wf_Stmts(stmts, senv) ==(forall stmt in set (elems stmts) & wf_Stmt(stmt, senv))wf_AssignStmt' ((unresolved AST`AssignStmt) * (unresolved STATSEM`StatEnv) -> (bool * [(unresolved AST`Type)]))	wf_AssignStmt(mk_(unresolved AST`AssignStmt)(lhs, rhs), senv) ==let mk_(wf_var, tp_var) = wf_Variable(lhs, senv), mk_(wf_ex, tp_ex) = wf_Expr(rhs, senv) in mk_((wf_ex and (wf_var and (tp_var = tp_ex))), tp_var)wf_CondStmt' ((unresolved AST`CondStmt) * (unresolved STATSEM`StatEnv) -> bool)	wf_CondStmt(mk_(unresolved AST`CondStmt)(guard, thenst, elsest), senv) ==let mk_(wf_ex, tp_ex) = wf_Expr(guard, senv) in (wf_ex and ((tp_ex = <BoolType>) and (wf_Stmt(thenst, senv) and wf_Stmt(elsest, senv))))wf_RepeatStmt' ((unresolved AST`RepeatStmt) * (unresolved STATSEM`StatEnv) -> bool)	wf_RepeatStmt(mk_(unresolved AST`RepeatStmt)(repeat, until), senv) ==let mk_(wf_ex, tp_ex) = wf_Expr(until, senv) in (wf_ex and ((tp_ex = <BoolType>) and wf_Stmt(repeat, senv)))wf_ForStmt' ((unresolved AST`ForStmt) * (unresolved STATSEM`StatEnv) -> bool)	wf_ForStmt(mk_(unresolved AST`ForStmt)(start, stop, stmt), senv) ==let mk_(wf_ass, tp_ass) = wf_AssignStmt(start, senv), mk_(wf_ex, tp_ex) = wf_Expr(stop, senv) in (wf_ass and (wf_ex and ((tp_ass = <IntType>) and ((tp_ex = <IntType>) and wf_Stmt(stmt, senv)))))wf_Expr' ((unresolved AST`Expr) * (unresolved STATSEM`StatEnv) -> (bool * [(unresolved AST`Type)]))	wf_Expr(ex, senv) ==(cases true 'case (is_(ex, AST`BoolVal)) -> mk_(true, <BoolType>),case (is_(ex, AST`IntVal)) -> mk_(true, <IntType>),case (is_(ex, AST`Variable)) -> wf_Variable(ex, senv),case (is_(ex, AST`BinaryExpr)) -> wf_BinaryExpr(ex, senv)others mk_(false, <IntType>)end)wf_Variable' ((unresolved AST`Variable) * (unresolved STATSEM`StatEnv) -> (bool * [(unresolved AST`Type)]))	wf_Variable(mk_(unresolved AST`Variable)(id), senv) ==(if (id in set (dom senv))then mk_(true, senv(id))else mk_(false, nil))wf_BinaryExpr' ((unresolved AST`BinaryExpr) * (unresolved STATSEM`StatEnv) -> (bool * [(unresolved AST`Type)]))	wf_BinaryExpr(mk_(unresolved AST`BinaryExpr)(lhs, op, rhs), senv) ==let mk_(wf_lhs, tp_lhs) = wf_Expr(lhs, senv), mk_(wf_rhs, tp_rhs) = wf_Expr(rhs, senv) in (cases op 'case <Add> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Sub> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Div> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Mul> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Lt> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <BoolType>),case <Gt> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <BoolType>),case <Eq> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <BoolType>),case <And> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <BoolType>) and (tp_rhs = <BoolType>)))), <BoolType>),case <Or> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <BoolType>) and (tp_rhs = <BoolType>)))), <BoolType>)others mk_(false, nil)end)end STATSEM
