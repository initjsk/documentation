WARNING:dynsem.vdmsl:5012:117,17:Recursive function has no measure.
RESULT:result:-1:-1,-1:module STATSEMimportsfrom ASTimport allexportsexport alldefinitionsstatic private StatEnv = map (Identifier) to (Type)wf_Program' (Program -> bool)	wf_Program(mk_Program(decls, stmt)) ==(wf_Declarations(decls) and wf_Stmt(stmt, get_Declarations(decls)))wf_Declarations' (seq of (Declaration) -> bool)	wf_Declarations(decls) ==((forall i1, i2 in set (inds decls) & ((i1 <> i2) => ((decls(i1).id) <> (decls(i2).id)))) and (forall i in set (inds decls) & (((decls(i).val) <> nil) => ((is_((decls(i).val), AST`BoolVal) and ((decls(i).tp) = <BoolType>)) or (is_((decls(i).val), AST`IntVal) and ((decls(i).tp) = <IntType>))))))get_Declarations' (seq of (Declaration) -> StatEnv)	get_Declarations(decls) =={id |-> tp | mk_Declaration(id, tp, -) in set (elems decls)}wf_Stmt' (Stmt * StatEnv -> bool)	wf_Stmt(stmt, senv) ==(cases true 'case (is_(stmt, AST`BlockStmt)) -> wf_BlockStmt(stmt, senv),case (is_(stmt, AST`AssignStmt)) -> let mk_(wf_ass, -)'(bool * [Type]) = wf_AssignStmt(stmt, senv) in wf_ass,case (is_(stmt, AST`CondStmt)) -> wf_CondStmt(stmt, senv),case (is_(stmt, AST`ForStmt)) -> wf_ForStmt(stmt, senv),case (is_(stmt, AST`RepeatStmt)) -> wf_RepeatStmt(stmt, senv)others falseend)wf_BlockStmt' (BlockStmt * StatEnv -> bool)	wf_BlockStmt(mk_BlockStmt(decls, stmts), senv) ==(wf_Declarations(decls) and wf_Stmts(stmts, (senv ++ get_Declarations(decls))))wf_Stmts' (seq of (Stmt) * StatEnv -> bool)	wf_Stmts(stmts, senv) ==(forall stmt in set (elems stmts) & wf_Stmt(stmt, senv))wf_AssignStmt' (AssignStmt * StatEnv -> (bool * [Type]))	wf_AssignStmt(mk_AssignStmt(lhs, rhs), senv) ==let mk_(wf_var, tp_var)'(bool * [Type]) = wf_Variable(lhs, senv), mk_(wf_ex, tp_ex)'(bool * [Type]) = wf_Expr(rhs, senv) in mk_((wf_ex and (wf_var and (tp_var = tp_ex))), tp_var)wf_CondStmt' (CondStmt * StatEnv -> bool)	wf_CondStmt(mk_CondStmt(guard, thenst, elsest), senv) ==let mk_(wf_ex, tp_ex)'(bool * [Type]) = wf_Expr(guard, senv) in (wf_ex and ((tp_ex = <BoolType>) and (wf_Stmt(thenst, senv) and wf_Stmt(elsest, senv))))wf_RepeatStmt' (RepeatStmt * StatEnv -> bool)	wf_RepeatStmt(mk_RepeatStmt(repeat, until), senv) ==let mk_(wf_ex, tp_ex)'(bool * [Type]) = wf_Expr(until, senv) in (wf_ex and ((tp_ex = <BoolType>) and wf_Stmt(repeat, senv)))wf_ForStmt' (ForStmt * StatEnv -> bool)	wf_ForStmt(mk_ForStmt(start, stop, stmt), senv) ==let mk_(wf_ass, tp_ass)'(bool * [Type]) = wf_AssignStmt(start, senv), mk_(wf_ex, tp_ex)'(bool * [Type]) = wf_Expr(stop, senv) in (wf_ass and (wf_ex and ((tp_ass = <IntType>) and ((tp_ex = <IntType>) and wf_Stmt(stmt, senv)))))wf_Expr' (Expr * StatEnv -> (bool * [Type]))	wf_Expr(ex, senv) ==(cases true 'case (is_(ex, AST`BoolVal)) -> mk_(true, <BoolType>),case (is_(ex, AST`IntVal)) -> mk_(true, <IntType>),case (is_(ex, AST`Variable)) -> wf_Variable(ex, senv),case (is_(ex, AST`BinaryExpr)) -> wf_BinaryExpr(ex, senv)others mk_(false, <IntType>)end)wf_Variable' (Variable * StatEnv -> (bool * [Type]))	wf_Variable(mk_Variable(id), senv) ==(if (id in set (dom senv))then mk_(true, senv(id))else mk_(false, nil))wf_BinaryExpr' (BinaryExpr * StatEnv -> (bool * [Type]))	wf_BinaryExpr(mk_BinaryExpr(lhs, op, rhs), senv) ==let mk_(wf_lhs, tp_lhs)'(bool * [Type]) = wf_Expr(lhs, senv), mk_(wf_rhs, tp_rhs)'(bool * [Type]) = wf_Expr(rhs, senv) in (cases op 'case <Add> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Sub> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Div> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Mul> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <IntType>),case <Lt> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <BoolType>),case <Gt> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <BoolType>),case <Eq> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <IntType>) and (tp_rhs = <IntType>)))), <BoolType>),case <And> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <BoolType>) and (tp_rhs = <BoolType>)))), <BoolType>),case <Or> -> mk_((wf_lhs and (wf_rhs and ((tp_lhs = <BoolType>) and (tp_rhs = <BoolType>)))), <BoolType>)others mk_(false, nil)end)end STATSEM, module DYNSEMimportsfrom ASTimport allfrom STATSEMimport allexportsexport alldefinitionsstatic private DynEnv = map (Identifier) to (Value)EvalProgram' (Program -> DynEnv)	EvalProgram(mk_Program(decls, stmt)) ==EvalStmt(stmt, EvalDeclarations(decls))	pre (STATSEM`wf_Program(mk_AST`Program(decls, stmt)) and pre_EvalStmt(stmt, EvalDeclarations(decls)))EvalDeclarations' (seq of (Declaration) -> DynEnv)	EvalDeclarations(decls) =={id |-> (if (val <> nil)then valelseif (tp = <BoolType>)then mk_AST`BoolVal(false)else mk_AST`IntVal(0)) | mk_Declaration(id, tp, val) in set (elems decls)}EvalStmt' (Stmt * DynEnv -> DynEnv)	EvalStmt(stmt, denv) ==(cases true 'case (is_(stmt, AST`BlockStmt)) -> EvalBlockStmt(stmt, denv),case (is_(stmt, AST`AssignStmt)) -> EvalAssignStmt(stmt, denv),case (is_(stmt, AST`CondStmt)) -> EvalCondStmt(stmt, denv),case (is_(stmt, AST`ForStmt)) -> EvalForStmt(stmt, denv),case (is_(stmt, AST`RepeatStmt)) -> EvalRepeatStmt(stmt, denv)end)	pre ((is_(stmt, AST`BlockStmt) => pre_EvalBlockStmt(stmt, denv)) and ((is_(stmt, AST`AssignStmt) => pre_EvalAssignStmt(stmt, denv)) and ((is_(stmt, AST`CondStmt) => pre_EvalCondStmt(stmt, denv)) and ((is_(stmt, AST`ForStmt) => pre_EvalForStmt(stmt, denv)) and (is_(stmt, AST`RepeatStmt) => pre_EvalRepeatStmt(stmt, denv))))))EvalBlockStmt' (BlockStmt * DynEnv -> DynEnv)	EvalBlockStmt(mk_BlockStmt(decls, stmts), denv) ==let ldenv'DynEnv = EvalDeclarations(decls) in let denv''DynEnv = EvalStmts(stmts, (denv ++ ldenv)) in (denv ++ ((dom ldenv) <-' denv'))	pre let ldenv'DynEnv = EvalDeclarations(decls) in pre_EvalStmts(stmts, (denv ++ ldenv))EvalStmts' (seq of (Stmt) * DynEnv -> DynEnv)	EvalStmts(stmts, denv) ==(cases stmts 'case [] -> denvothers EvalStmts((tl stmts), EvalStmt((hd stmts), denv))end)	pre ((stmts <> []) => pre_EvalStmt((hd stmts), denv))LenStmt' (seq of (Stmt) * DynEnv -> nat)	LenStmt(l, -) ==(len l)EvalAssignStmt' (AssignStmt * DynEnv -> DynEnv)	EvalAssignStmt(mk_AssignStmt(lhs, rhs), denv) ==(denv ++ {(lhs.id) |-> EvalExpr(rhs, denv)})	pre pre_EvalExpr(rhs, denv)EvalCondStmt' (CondStmt * DynEnv -> DynEnv)	EvalCondStmt(mk_CondStmt(guard, thenst, elsest), denv) ==(if (EvalExpr(guard, denv).val)then EvalStmt(thenst, denv)else EvalStmt(elsest, denv))	pre (pre_EvalExpr(guard, denv) and (if (EvalExpr(guard, denv).val)then pre_EvalStmt(thenst, denv)else pre_EvalStmt(elsest, denv)))EvalRepeatStmt' (RepeatStmt * DynEnv -> DynEnv)	EvalRepeatStmt(mk_RepeatStmt(repeat, until), denv) ==let denv''DynEnv = EvalStmt(repeat, denv) in (if (EvalExpr(until, denv').val)then denv'else EvalRepeatStmt(mk_AST`RepeatStmt(repeat, until), denv'))	pre (pre_EvalStmt(repeat, denv) and pre_EvalExpr(until, EvalStmt(repeat, denv)))EvalForStmt' (ForStmt * DynEnv -> DynEnv)	EvalForStmt(mk_ForStmt(start, stop, stmt), denv) ==let denv''DynEnv = EvalAssignStmt(start, denv) in EvalForLoop((start.lhs), EvalExpr(stop, denv'), stmt, denv')	pre (pre_EvalAssignStmt(start, denv) and pre_EvalExpr(stop, EvalAssignStmt(start, denv)))EvalForLoop' (Variable * Value * Stmt * DynEnv -> DynEnv)	EvalForLoop(mk_Variable(id), val, stmt, denv) ==(if ((denv(id).val) <= (val.val))then let denv''DynEnv = EvalStmt(stmt, denv) in EvalForLoop(mk_AST`Variable(id), val, stmt, (denv' ++ {id |-> mk_AST`IntVal(((denv'(id).val) + 1))}))else denv)	pre pre_EvalStmt(stmt, denv)LoopParInc' (Variable * Value * Stmt * DynEnv -> nat)	LoopParInc(mk_Variable(id), val, -, denv) ==((val.val) - (denv(id).val))EvalExpr' (Expr * DynEnv -> Value)	EvalExpr(ex, denv) ==(cases ex 'case mk_BoolVal(-) -> ex,case mk_IntVal(-) -> ex,case mk_Variable(id) -> denv(id),case mk_BinaryExpr(-, -, -) -> EvalBinaryExpr(ex, denv)end)	pre (is_(ex, AST`BinaryExpr) => pre_EvalBinaryExpr(ex, denv))EvalBinaryExpr' (BinaryExpr * DynEnv -> Value)	EvalBinaryExpr(mk_BinaryExpr(lhs, op, rhs), denv) ==let v1'(bool | int) = (EvalExpr(lhs, denv).val), v2'(bool | int) = (EvalExpr(rhs, denv).val) in (cases op 'case <Add> -> mk_AST`IntVal((v1 + v2)),case <Sub> -> mk_AST`IntVal((v1 - v2)),case <Div> -> mk_AST`IntVal((v1 div v2)),case <Mul> -> mk_AST`IntVal((v1 * v2)),case <Lt> -> mk_AST`BoolVal((v1 < v2)),case <Gt> -> mk_AST`BoolVal((v1 > v2)),case <Eq> -> mk_AST`BoolVal((v1 = v2)),case <And> -> mk_AST`BoolVal((v1 and v2)),case <Or> -> mk_AST`BoolVal((v1 or v2))end)	pre ((op = <Div>) => ((EvalExpr(rhs, denv).val) <> 0))end DYNSEM, module ASTexportsexport alldefinitionsstatic private Program = compose Program of decls'seq of (Declaration), stmt'Stmt endstatic private Declaration = compose Declaration of id'Identifier, tp'Type, val'[Value] endstatic private Identifier = seq1 of (char)static private Type = (<BoolType> | <IntType>)static private Value = (BoolVal | IntVal)static private BoolVal = compose BoolVal of val'bool endstatic private IntVal = compose IntVal of val'int endstatic private Stmt = (AssignStmt | BlockStmt | CondStmt | ForStmt | RepeatStmt)static private BlockStmt = compose BlockStmt of decls'seq of (Declaration), stmts'seq1 of (Stmt) endstatic private AssignStmt = compose AssignStmt of lhs'Variable, rhs'Expr endstatic private Variable = compose Variable of id'Identifier endstatic private Expr = (BinaryExpr | Value | Variable)static private BinaryExpr = compose BinaryExpr of lhs'Expr, op'Operator, rhs'Expr endstatic private Operator = (<Add> | <And> | <Div> | <Eq> | <Gt> | <Lt> | <Mul> | <Or> | <Sub>)static private CondStmt = compose CondStmt of guard'Expr, thenst'Stmt, elsest'Stmt endstatic private ForStmt = compose ForStmt of start'AssignStmt, stop'Expr, stmt'Stmt endstatic private RepeatStmt = compose RepeatStmt of repeat'Stmt, until'Expr endend AST, module Testimportsfrom ASTimport allfrom STATSEMimport allfrom DYNSEMimport allexportsexport alldefinitionsstatic private binexpr'Expr = mk_AST`BinaryExpr(mk_AST`IntVal(4), <Add>, mk_AST`IntVal(5))RunTypeCheck' (() -> (bool * [Type]))	RunTypeCheck() ==STATSEM`wf_Expr(binexpr, {})RunEval' (() -> Value)	RunEval() ==DYNSEM`EvalExpr(binexpr, {})end Test
