RESULT:result:-1:-1,-1:module stationexportsexport type struct Station_topoexport type struct Tracksexport type struct Track_idexport type struct Pointsexport type struct Point_stateexport type struct Crossingsexport type struct Signalsexport type struct Signal_idexport type struct Station_stateexport type struct Track_statesexport type struct Point_statesexport type struct Signal_statesexport type struct Track_stateexport type struct Train_idexport type struct Train_typeexport type struct Point_controlexport type struct Operationexport type struct Signal_stateexport function Is_wf_Station_topo'((unresolved station`Station_topo) +> bool)export function Is_wf_Station_state'((unresolved station`Station_topo) * (unresolved station`Station_state) +> bool)definitionsstatic private Tracks = set of ((((unresolved station`Track_id) * (unresolved station`Track_id))))static private Track_id = seq of (char)NoReflexive' ((unresolved station`Tracks) +> bool)	NoReflexive(tracks) ==(forall mk_(t1, t2) in set tracks & (t1 <> t2))Symmetric' ((unresolved station`Tracks) +> bool)	Symmetric(tracks) ==(forall mk_(t1, t2) in set tracks & (mk_(t2, t1) in set tracks))Is_wf_Tracks' ((unresolved station`Tracks) +> bool)	Is_wf_Tracks(tracks) ==(NoReflexive(tracks) and Symmetric(tracks))static private Points = map ((((unresolved station`Track_id) * (unresolved station`Track_id)))) to ((map ((unresolved station`Track_id)) to ((unresolved station`Point_control))))static private Point_control = (<left> | <right>)static private Crossings = set of ((((unresolved station`Track_id) * (unresolved station`Track_id))))PointsInTracks' ((unresolved station`Tracks) * (unresolved station`Points) +> bool)	PointsInTracks(tracks, points) ==((dom points) subset tracks)Inverses' ((unresolved station`Points) +> bool)	Inverses(points) ==(forall mk_(t1, t2) in set (dom points) & ((mk_(t2, t1) in set (dom points)) and (points(mk_(t1, t2)) = points(mk_(t2, t1)))))OkDomRng' ((unresolved station`Points) +> bool)	OkDomRng(points) ==(forall mk_(t1, t2) in set (dom points) & ((points(mk_(t1, t2)) <> {}) and ((dom points(mk_(t1, t2))) subset {t1, t2})))RelateToTracks' ((unresolved station`Tracks) * (unresolved station`Points) +> bool)	RelateToTracks(tracks, points) ==((forall tpair in set (dom points) & (forall pid in set (dom points(tpair)) & ((card {t | [mk_(t, t') in set tracks] & (t' = pid)}) = 3))) and (forall mk_(t1, -) in set tracks & ((not (exists [tpair in set (dom points)] & (t1 in set (dom points(tpair))))) => ((card {t | [mk_(t, t') in set tracks] & (t' = t1)}) <= 2))))Control2Dir' ((unresolved station`Points) +> bool)	Control2Dir(points) ==(forall mk_(t1, t2) in set (dom points) & (((({t1} <' points(mk_(t1, t2))) = {t1 |-> <left>}) => (exists [mk_(t, t') in set (dom points)] & ((t = t1) and (({t1} <' points(mk_(t1, t'))) = {t1 |-> <right>})))) and ((({t1} <' points(mk_(t1, t2))) = {t1 |-> <right>}) => (exists [mk_(t, t') in set (dom points)] & ((t = t1) and (({t1} <' points(mk_(t1, t'))) = {t1 |-> <left>}))))))Is_wf_Points' ((unresolved station`Tracks) * (unresolved station`Points) +> bool)	Is_wf_Points(tracks, points) ==(PointsInTracks(tracks, points) and (Inverses(points) and (OkDomRng(points) and (RelateToTracks(tracks, points) and Control2Dir(points)))))SeperateBranches' ((unresolved station`Tracks) * (unresolved station`Crossings) +> bool)	SeperateBranches(tracks, crossings) ==((crossings inter tracks) = {})CrossInTracks' ((unresolved station`Tracks) * (unresolved station`Crossings) +> bool)	CrossInTracks(tracks, crossings) ==(forall mk_(t1, t2) in set crossings & ((exists [mk_(t3, -) in set tracks] & (t1 = t3)) and (exists [mk_(t4, -) in set tracks] & (t2 = t4))))UniqueCross' ((unresolved station`Crossings) +> bool)	UniqueCross(crossings) ==(forall mk_(t1, t2) in set crossings & ((t1 <> t2) and (forall mk_(t3, t4) in set (crossings \ {mk_(t1, t2)}) & ((t1 <> t3) and ((t1 <> t4) and ((t2 <> t3) and (t2 <> t4)))))))DiffPointsCrossings' ((unresolved station`Points) * (unresolved station`Crossings) +> bool)	DiffPointsCrossings(points, crossings) ==(forall mk_(t1, t2) in set crossings & (forall pointcontrol in set (rng points) & ((t1 not in set (dom pointcontrol)) and (t2 not in set (dom pointcontrol)))))Is_wf_Crossings' ((unresolved station`Tracks) * (unresolved station`Points) * (unresolved station`Crossings) +> bool)	Is_wf_Crossings(tracks, points, crossings) ==(SeperateBranches(tracks, crossings) and (CrossInTracks(tracks, crossings) and (UniqueCross(crossings) and DiffPointsCrossings(points, crossings))))static private Signals = map ((((unresolved station`Track_id) * (unresolved station`Track_id)))) to ((unresolved station`Signal_id))static private Signal_id = seq of (char)UniqueSignals' ((unresolved station`Signals) +> bool)	UniqueSignals(signals) ==((card (rng signals)) = (card (dom signals)))SigInTracks' ((unresolved station`Tracks) * (unresolved station`Signals) +> bool)	SigInTracks(tracks, signals) ==(forall mk_(t1, t2) in set (dom signals) & (((t1 = "ol") => ((card {t | [mk_(t, t') in set tracks] & (t' = t2)}) = 1)) and (((t2 = "ol") => ((card {t | [mk_(t, t') in set tracks] & (t' = t1)}) = 1)) and (((t1 <> "ol") and (t2 <> "ol")) => (mk_(t1, t2) in set tracks)))))Is_wf_Signals' ((unresolved station`Tracks) * (unresolved station`Signals) +> bool)	Is_wf_Signals(tracks, signals) ==(UniqueSignals(signals) and SigInTracks(tracks, signals))static private Station_topo = compose Station_topo of tracks'(unresolved station`Tracks), points'(unresolved station`Points), crossings'(unresolved station`Crossings), signals'(unresolved station`Signals) endIs_wf_Station_topo' ((unresolved station`Station_topo) +> bool)	Is_wf_Station_topo(stationtopo) ==(Is_wf_Tracks((stationtopo.tracks)) and (Is_wf_Points((stationtopo.tracks), (stationtopo.points)) and (Is_wf_Crossings((stationtopo.tracks), (stationtopo.points), (stationtopo.crossings)) and Is_wf_Signals((stationtopo.tracks), (stationtopo.signals)))))static private Station_state = compose Station_state of trackstates'(unresolved station`Track_states), pointstates'(unresolved station`Point_states), signalstates'(unresolved station`Signal_states) endstatic private Track_states = map ((unresolved station`Track_id)) to ((unresolved station`Track_state))static private Point_states = map ((unresolved station`Track_id)) to ((unresolved station`Point_state))static private Signal_states = map ((unresolved station`Signal_id)) to ((unresolved station`Signal_state))static private Track_state = map ((unresolved station`Train_id)) to ((unresolved station`Train_type))static private Train_id = seq of (char)static private Train_type = (<autonomous> | <fixedroute>)static private Point_state = ((unresolved station`Point_control) * (unresolved station`Operation))static private Operation = (<interlock> | <manual>)static private Signal_state = (<driveaspect> | <stop>)ConformTracks' ((unresolved station`Tracks) * (unresolved station`Track_states) +> bool)	ConformTracks(tracks, trackstates) ==(TracksStateInTopo(tracks, trackstates) and TracksTopoInState(tracks, trackstates))TracksStateInTopo' ((unresolved station`Tracks) * (unresolved station`Track_states) +> bool)	TracksStateInTopo(tracks, trackstates) ==(forall t in set (dom trackstates) & (exists [mk_(t1, t2) in set tracks] & ((t = t1) or (t = t2))))TracksTopoInState' ((unresolved station`Tracks) * (unresolved station`Track_states) +> bool)	TracksTopoInState(tracks, trackstates) ==(forall mk_(t1, t2) in set tracks & ((t1 in set (dom trackstates)) and (t2 in set (dom trackstates))))ConformPoints' ((unresolved station`Points) * (unresolved station`Point_states) +> bool)	ConformPoints(points, pointstates) ==(PointsStateInTopo(points, pointstates) and PointsTopoInState(points, pointstates))PointsStateInTopo' ((unresolved station`Points) * (unresolved station`Point_states) +> bool)	PointsStateInTopo(points, pointstates) ==(forall t in set (dom pointstates) & (exists [mk_(t1, t2) in set (dom points)] & (t in set (dom points(mk_(t1, t2))))))PointsTopoInState' ((unresolved station`Points) * (unresolved station`Point_states) +> bool)	PointsTopoInState(points, pointstates) ==(forall mk_(t1, t2) in set (dom points) & (((t1 in set (dom points(mk_(t1, t2)))) => (t1 in set (dom pointstates))) and ((t2 in set (dom points(mk_(t1, t2)))) => (t2 in set (dom pointstates)))))ConformSignals' ((unresolved station`Signals) * (unresolved station`Signal_states) +> bool)	ConformSignals(signals, signalstates) ==((rng signals) = (dom signalstates))Is_wf_Trains' ((unresolved station`Tracks) * (unresolved station`Points) * (unresolved station`Crossings) * (unresolved station`Track_states) +> bool)	Is_wf_Trains(tracks, points, crossings, trackstates) ==(UniqueTrain(trackstates) and let trains = Trains(trackstates, {}) in (Connected(trains, tracks) and (OkPointTrains(trains, points) and OkCrossTrains(trains, crossings))))UniqueTrain' ((unresolved station`Track_states) +> bool)	UniqueTrain(trackstates) ==(forall trackid in set (dom trackstates) & (forall trainid in set (dom trackstates(trackid)) & (((trackstates(trackid)(trainid) = <fixedroute>) => (forall trackid' in set (dom trackstates) & ((trainid in set (dom trackstates(trackid'))) => (trackstates(trackid')(trainid) = <fixedroute>)))) and ((trackstates(trackid)(trainid) = <autonomous>) => (forall trackid' in set (dom trackstates) & ((trainid in set (dom trackstates(trackid'))) => (trackstates(trackid')(trainid) = <autonomous>)))))))Trains' ((unresolved station`Track_states) * (map ((unresolved station`Train_id)) to (set of ((unresolved station`Track_id)))) +> (map ((unresolved station`Train_id)) to (set of ((unresolved station`Track_id)))))	Trains(trackstates, sorted) ==(if (trackstates = {})then sortedelse let t in set (dom trackstates) in (if (trackstates(t) = {})then Trains(({t} <-' trackstates), sorted)else Trains(({t} <-' trackstates), Update(mk_(t, trackstates(t)), sorted))))Update' ((((unresolved station`Track_id) * (unresolved station`Track_state))) * (map ((unresolved station`Train_id)) to (set of ((unresolved station`Track_id)))) +> (map ((unresolved station`Train_id)) to (set of ((unresolved station`Track_id)))))	Update(mk_(t, trackstate), sorted) ==(if (trackstate = {})then sortedelse let tid in set (dom trackstate) in (if (tid in set (dom sorted))then Update(mk_(t, ({tid} <-' trackstate)), (sorted ++ {tid |-> ({t} union sorted(tid))}))else Update(mk_(t, ({tid} <-' trackstate)), (sorted munion {tid |-> {t}}))))Connected' ((map ((unresolved station`Train_id)) to (set of ((unresolved station`Track_id)))) * (unresolved station`Tracks) +> bool)	Connected(trains, tracks) ==(forall trackset in set (rng trains) & ExistsPath(trackset, tracks))ExistsPath' (set of ((unresolved station`Track_id)) * (unresolved station`Tracks) +> bool)	ExistsPath(trackset, tracks) ==(exists [t in set trackset] & Path((trackset \ {t}), [t], tracks, {}))Path' (set of ((unresolved station`Track_id)) * seq of ((unresolved station`Track_id)) * (unresolved station`Tracks) * set of ((unresolved station`Track_id)) +> bool)	Path(trackset, connected, tracks, tried) ==(if (trackset = {})then (tried = {})else let t in set trackset in (if (mk_(t, (hd connected)) in set tracks)then Path(((trackset \ {t}) union tried), ([t] ^ connected), tracks, {})else (if (mk_(connected((len connected)), t) in set tracks)then Path(((trackset \ {t}) union tried), (connected ^ [t]), tracks, {})else Path((trackset \ {t}), connected, tracks, (tried union {t})))))OkPointTrains' ((map ((unresolved station`Train_id)) to (set of ((unresolved station`Track_id)))) * (unresolved station`Points) +> bool)	OkPointTrains(trains, points) ==(forall trackset in set (rng trains) & (forall t1, t2 in set trackset & (((mk_(t1, t2) in set (dom points)) and (t1 in set (dom points(mk_(t1, t2))))) => (forall t3 in set trackset & (((mk_(t1, t3) in set (dom points)) and (t1 in set (dom points(mk_(t1, t3))))) => (points(mk_(t1, t2))(t1) = points(mk_(t1, t3))(t1)))))))OkCrossTrains' ((map ((unresolved station`Track_id)) to (set of ((unresolved station`Track_id)))) * (unresolved station`Crossings) +> bool)	OkCrossTrains(trains, crossings) ==(forall trackidset in set (rng trains) & (forall t1, t2 in set trackidset & (mk_(t1, t2) not in set crossings)))Is_wf_Station_state' ((unresolved station`Station_topo) * (unresolved station`Station_state) +> bool)	Is_wf_Station_state(stationtopo, stationstate) ==(ConformTracks((stationtopo.tracks), (stationstate.trackstates)) and (ConformPoints((stationtopo.points), (stationstate.pointstates)) and (ConformSignals((stationtopo.signals), (stationstate.signalstates)) and Is_wf_Trains((stationtopo.tracks), (stationtopo.points), (stationtopo.crossings), (stationstate.trackstates)))))end station, module safe_reqimportsfrom stationimport type Station_topo = compose Station_topo of tracks'(unresolved station`Tracks), points'(unresolved station`Points), crossings'(unresolved station`Crossings), signals'(unresolved station`Signals) end renamed Station_topoimport type Tracks = set of ((((unresolved station`Track_id) * (unresolved station`Track_id)))) renamed Tracksimport type Track_id = seq of (char) renamed Track_idimport type Points = map ((((unresolved station`Track_id) * (unresolved station`Track_id)))) to ((map ((unresolved station`Track_id)) to ((unresolved station`Point_control)))) renamed Pointsimport type Point_control = (<left> | <right>) renamed Point_controlimport type Crossings = set of ((((unresolved station`Track_id) * (unresolved station`Track_id)))) renamed Crossingsimport type Signals = map ((((unresolved station`Track_id) * (unresolved station`Track_id)))) to ((unresolved station`Signal_id)) renamed Signalsimport type Signal_id = seq of (char) renamed Signal_idimport type Station_state = compose Station_state of trackstates'(unresolved station`Track_states), pointstates'(unresolved station`Point_states), signalstates'(unresolved station`Signal_states) end renamed Station_stateimport type Track_states = map ((unresolved station`Track_id)) to ((unresolved station`Track_state)) renamed Track_statesimport type Track_state = map ((unresolved station`Train_id)) to ((unresolved station`Train_type)) renamed Track_stateimport type Train_id = seq of (char) renamed Train_idimport type Train_type = (<autonomous> | <fixedroute>) renamed Train_typeimport type Point_states = map ((unresolved station`Track_id)) to ((unresolved station`Point_state)) renamed Point_statesimport type Point_state = ((unresolved station`Point_control) * (unresolved station`Operation)) renamed Point_stateimport type Operation = (<interlock> | <manual>) renamed Operationimport type Signal_states = map ((unresolved station`Signal_id)) to ((unresolved station`Signal_state)) renamed Signal_statesimport type Signal_state = (<driveaspect> | <stop>) renamed Signal_stateimport function Is_wf_Station_topo renamed Is_wf_Station_topo'((unresolved station`Station_topo) +> bool)import function Is_wf_Station_state renamed Is_wf_Station_state'((unresolved station`Station_topo) * (unresolved station`Station_state) +> bool)exportsexport function SafeReq'((unresolved safe_req`Station_topo) * (unresolved safe_req`Station_state) +> bool)definitionsSafeReq' ((unresolved safe_req`Station_topo) * (unresolved safe_req`Station_state) +> bool)	SafeReq(stationtopo, stationstate) ==(NoCollision(stationtopo, stationstate) and NoDerail(stationtopo, stationstate))	pre (Is_wf_Station_topo(stationtopo) and Is_wf_Station_state(stationtopo, stationstate))NoCollision' ((unresolved safe_req`Station_topo) * (unresolved safe_req`Station_state) +> bool)	NoCollision(stationtopo, stationstate) ==(forall tid in set (dom (stationstate.trackstates)) & (((card (dom (stationstate.trackstates)(tid))) <= 1) and OneTrainAtCross((stationtopo.crossings), (stationstate.trackstates))))OneTrainAtCross' ((unresolved safe_req`Crossings) * (unresolved safe_req`Track_states) +> bool)	OneTrainAtCross(crossings, trackstates) ==(forall mk_(tid1, tid2) in set crossings & (((card (dom trackstates(tid1))) + (card (dom trackstates(tid2)))) <= 1))NoDerail' ((unresolved safe_req`Station_topo) * (unresolved safe_req`Station_state) +> bool)	NoDerail(stationtopo, stationstate) ==let trains = Trains((stationstate.trackstates), {}) in (forall t in set (dom trains) & (forall t1, t2 in set trains(t) & ((mk_(t1, t2) in set (dom (stationtopo.points))) => Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))Trains' ((unresolved safe_req`Track_states) * (map ((unresolved safe_req`Train_id)) to (set of ((unresolved safe_req`Track_id)))) +> (map ((unresolved safe_req`Train_id)) to (set of ((unresolved safe_req`Track_id)))))	Trains(trackstates, sorted) ==(if (trackstates = {})then sortedelse let t in set (dom trackstates) in (if (trackstates(t) = {})then Trains(({t} <-' trackstates), sorted)else Trains(({t} <-' trackstates), Update(mk_(t, trackstates(t)), sorted))))Update' ((((unresolved safe_req`Track_id) * (unresolved safe_req`Track_state))) * (map ((unresolved safe_req`Train_id)) to (set of ((unresolved safe_req`Track_id)))) +> (map ((unresolved safe_req`Train_id)) to (set of ((unresolved safe_req`Track_id)))))	Update(mk_(t, trainids), sorted) ==(if (trainids = {})then sortedelse let tid in set (dom trainids) in (if (tid in set (dom sorted))then Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> ({t} union sorted(tid))}))else Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> {t}}))))Ok_Point_states' ((((unresolved safe_req`Track_id) * (unresolved safe_req`Track_id))) * (unresolved safe_req`Points) * (unresolved safe_req`Point_states) +> bool)	Ok_Point_states(mk_(t1, t2), points, pointstates) ==(if ({t1, t2} = (dom points(mk_(t1, t2))))then (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))else (if ({t1} = (dom points(mk_(t1, t2))))then Point_state_ok(mk_(t1, t2), t1, points, pointstates)else Point_state_ok(mk_(t1, t2), t2, points, pointstates)))	pre (mk_(t1, t2) in set (dom points))Point_state_ok' ((((unresolved safe_req`Track_id) * (unresolved safe_req`Track_id))) * (unresolved safe_req`Track_id) * (unresolved safe_req`Points) * (unresolved safe_req`Point_states) +> bool)	Point_state_ok(tpair, t, points, pointstates) ==let mk_(pcnt, -) = pointstates(t) in (points(tpair)(t) = pcnt)	pre ((t in set (dom pointstates)) and ((tpair in set (dom points)) and (t in set (dom points(tpair)))))end safe_req, module implimportsfrom stationimport type Station_topo = compose Station_topo of tracks'(unresolved station`Tracks), points'(unresolved station`Points), crossings'(unresolved station`Crossings), signals'(unresolved station`Signals) end renamed Station_topoimport type Tracks = set of ((((unresolved station`Track_id) * (unresolved station`Track_id)))) renamed Tracksimport type Track_id = seq of (char) renamed Track_idimport type Points = map ((((unresolved station`Track_id) * (unresolved station`Track_id)))) to ((map ((unresolved station`Track_id)) to ((unresolved station`Point_control)))) renamed Pointsimport type Point_control = (<left> | <right>) renamed Point_controlimport type Crossings = set of ((((unresolved station`Track_id) * (unresolved station`Track_id)))) renamed Crossingsimport type Signals = map ((((unresolved station`Track_id) * (unresolved station`Track_id)))) to ((unresolved station`Signal_id)) renamed Signalsimport type Signal_id = seq of (char) renamed Signal_idimport type Station_state = compose Station_state of trackstates'(unresolved station`Track_states), pointstates'(unresolved station`Point_states), signalstates'(unresolved station`Signal_states) end renamed Station_stateimport type Track_states = map ((unresolved station`Track_id)) to ((unresolved station`Track_state)) renamed Track_statesimport type Track_state = map ((unresolved station`Train_id)) to ((unresolved station`Train_type)) renamed Track_stateimport type Train_id = seq of (char) renamed Train_idimport type Train_type = (<autonomous> | <fixedroute>) renamed Train_typeimport type Point_states = map ((unresolved station`Track_id)) to ((unresolved station`Point_state)) renamed Point_statesimport type Point_state = ((unresolved station`Point_control) * (unresolved station`Operation)) renamed Point_stateimport type Operation = (<interlock> | <manual>) renamed Operationimport type Signal_states = map ((unresolved station`Signal_id)) to ((unresolved station`Signal_state)) renamed Signal_statesimport type Signal_state = (<driveaspect> | <stop>) renamed Signal_stateimport function Is_wf_Station_topo renamed Is_wf_Station_topo'((unresolved station`Station_topo) +> bool)import function Is_wf_Station_state renamed Is_wf_Station_state'((unresolved station`Station_topo) * (unresolved station`Station_state) +> bool)exportsexport function Impl'((unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)definitionsstatic private Areas = map ((unresolved impl`Train_id)) to ((unresolved impl`Area))static private Area = set of ((unresolved impl`Track_id))Impl' ((unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	Impl(stationtopo, stationstate) ==let areas = FindAreas(stationtopo, stationstate) in (NoCollision(areas, (stationtopo.crossings)) and NoDerail(areas, stationtopo, stationstate))	pre (Is_wf_Station_topo(stationtopo) and Is_wf_Station_state(stationtopo, stationstate))NoCollision' ((unresolved impl`Areas) * (unresolved impl`Crossings) +> bool)	NoCollision(areas, crossings) ==(forall train1, train2 in set (dom areas) & ((train1 <> train2) => (((areas(train1) inter areas(train2)) = {}) and (forall t1 in set areas(train1) & (forall t2 in set areas(train2) & (mk_(t1, t2) not in set crossings))))))NoDerail' ((unresolved impl`Areas) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	NoDerail(areas, stationtopo, stationstate) ==(NoDerailUnderTrains(stationtopo, stationstate) and NoDerailPossible(areas, stationtopo, stationstate))NoDerailUnderTrains' ((unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	NoDerailUnderTrains(stationtopo, stationstate) ==let trains = Trains((stationstate.trackstates), {}) in (forall t in set (dom trains) & (forall t1, t2 in set trains(t) & ((mk_(t1, t2) in set (dom (stationtopo.points))) => Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))NoDerailPossible' ((unresolved impl`Areas) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	NoDerailPossible(areas, stationtopo, stationstate) ==(forall area in set (rng areas) & let traintype = TrainType(area, stationstate) in (if (traintype = <fixedroute>)then NoDerailFixed(area, stationtopo, stationstate)else NoDerailAutonomous(area, stationtopo, stationstate)))Trains' ((unresolved impl`Track_states) * (map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id)))) +> (map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id)))))	Trains(trackstates, sorted) ==(if (trackstates = {})then sortedelse let t in set (dom trackstates) in (if (trackstates(t) = {})then Trains(({t} <-' trackstates), sorted)else Trains(({t} <-' trackstates), Update(mk_(t, trackstates(t)), sorted))))Update' ((((unresolved impl`Track_id) * (unresolved impl`Track_state))) * (map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id)))) +> (map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id)))))	Update(mk_(t, trainids), sorted) ==(if (trainids = {})then sortedelse let tid in set (dom trainids) in (if (tid in set (dom sorted))then Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> ({t} union sorted(tid))}))else Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> {t}}))))TrainType' ((unresolved impl`Area) * (unresolved impl`Station_state) +> (unresolved impl`Train_type))	TrainType(area, stationstate) ==let t in set area be st ((stationstate.trackstates)(t) <> {}) in let tt in set (dom (stationstate.trackstates)(t)) in (stationstate.trackstates)(t)(tt)	pre (forall t in set area & (t in set (dom (stationstate.trackstates))))NoDerailFixed' ((unresolved impl`Area) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	NoDerailFixed(area, stationtopo, stationstate) ==(forall t1, t2 in set area & ((mk_(t1, t2) in set (dom (stationtopo.points))) => (Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)) and InterlockPoints(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))Ok_Point_states' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Points) * (unresolved impl`Point_states) +> bool)	Ok_Point_states(mk_(t1, t2), points, pointstates) ==(if ({t1, t2} = (dom points(mk_(t1, t2))))then (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))else (if ({t1} = (dom points(mk_(t1, t2))))then Point_state_ok(mk_(t1, t2), t1, points, pointstates)else Point_state_ok(mk_(t1, t2), t2, points, pointstates)))	pre (mk_(t1, t2) in set (dom points))Point_state_ok' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Track_id) * (unresolved impl`Points) * (unresolved impl`Point_states) +> bool)	Point_state_ok(tpair, t, points, pointstates) ==let mk_(pcnt, -) = pointstates(t) in (points(tpair)(t) = pcnt)	pre ((t in set (dom pointstates)) and ((tpair in set (dom points)) and (t in set (dom points(tpair)))))InterlockPoints' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Points) * (unresolved impl`Point_states) +> bool)	InterlockPoints(mk_(t1, t2), points, pointstates) ==(if (IsPoint(t1, points) and IsPoint(t2, points))then (IsInterlockPoint(t1, points, pointstates) and IsInterlockPoint(t2, points, pointstates))else (if IsPoint(t1, points)then IsInterlockPoint(t1, points, pointstates)else IsInterlockPoint(t2, points, pointstates)))	pre (IsPoint(t1, points) or IsPoint(t2, points))IsPoint' ((unresolved impl`Track_id) * (unresolved impl`Points) +> bool)	IsPoint(t, points) ==(exists [mk_(t1, t2) in set (dom points)] & (t in set (dom points(mk_(t1, t2)))))IsInterlockPoint' ((unresolved impl`Track_id) * (unresolved impl`Points) * (unresolved impl`Point_states) +> bool)	IsInterlockPoint(t, points, pointstates) ==(if IsPoint(t, points)then let mk_(-, operation) = pointstates(t) in (operation = <interlock>)else false)NoDerailAutonomous' ((unresolved impl`Area) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	NoDerailAutonomous(area, stationtopo, stationstate) ==(forall t1, t2 in set area & ((mk_(t1, t2) in set (dom (stationtopo.points))) => OkAutonomPoint_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates))))OkAutonomPoint_states' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Points) * (unresolved impl`Point_states) +> bool)	OkAutonomPoint_states(mk_(t1, t2), points, pointstates) ==(if (IsInterlockPoint(t1, points, pointstates) and IsInterlockPoint(t2, points, pointstates))then (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))else (if IsInterlockPoint(t1, points, pointstates)then Point_state_ok(mk_(t1, t2), t1, points, pointstates)else (if IsInterlockPoint(t2, points, pointstates)then Point_state_ok(mk_(t1, t2), t2, points, pointstates)else true)))FindAreas' ((unresolved impl`Station_topo) * (unresolved impl`Station_state) +> (unresolved impl`Areas))	FindAreas(stationtopo, stationstate) ==let occupied = Occupied((stationstate.trackstates), {}) in DeduceAreas(occupied, stationtopo, stationstate)Occupied' ((unresolved impl`Track_states) * (map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id)))) +> map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id))))	Occupied(trackstates, occupied) ==(if (forall s in set (rng trackstates) & (s = {}))then occupiedelse let trains in set (rng trackstates) be st (trains <> {}) in let train in set (dom trains) in Occupied(RemoveTrain(train, trackstates), (occupied munion {train |-> {tid | [tid in set (dom trackstates)] & (train in set (dom trackstates(tid)))}})))	pre (forall trackstate in set (rng trackstates) & (((dom trackstate) inter (dom occupied)) = {}))RemoveTrain' ((unresolved impl`Train_id) * (unresolved impl`Track_states) +> (unresolved impl`Track_states))	RemoveTrain(train, trackstates) ==(if (trackstates = {})then {}else let tid in set (dom trackstates) in (if (train in set (dom trackstates(tid)))then RemoveTrain(train, (trackstates ++ {tid |-> ({train} <-' trackstates(tid))}))else ({tid |-> trackstates(tid)} munion RemoveTrain(train, ({tid} <-' trackstates)))))DeduceAreas' ((map ((unresolved impl`Train_id)) to (set of ((unresolved impl`Track_id)))) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> (unresolved impl`Areas))	DeduceAreas(occupied, stationtopo, stationstate) ==(if (occupied = {})then {}else let train in set (dom occupied) in let area = FindArea(occupied(train), {}, stationtopo, stationstate) in ({train |-> area} munion DeduceAreas(({train} <-' occupied), stationtopo, stationstate)))FindArea' (set of ((unresolved impl`Track_id)) * (unresolved impl`Area) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> (unresolved impl`Area))	FindArea(tracks, area, stationtopo, stationstate) ==(if (tracks = {})then areaelse let t in set tracks in let neighbours = Neighbours(t, area, stationtopo, stationstate) in FindArea(((tracks \ {t}) union neighbours), (area union {t}), stationtopo, stationstate))Neighbours' ((unresolved impl`Track_id) * set of ((unresolved impl`Track_id)) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> set of ((unresolved impl`Track_id)))	Neighbours(t, area, stationtopo, stationstate) ==let neighcand = NeighbourCandidates(t, area, (stationtopo.tracks)) in {t' | [t' in set neighcand] & OkEdge(mk_(t, t'), stationtopo, stationstate)}NeighbourCandidates' ((unresolved impl`Track_id) * set of ((unresolved impl`Track_id)) * (unresolved impl`Tracks) +> set of ((unresolved impl`Track_id)))	NeighbourCandidates(t, area, tracks) =={t' | [mk_(t1, t') in set tracks] & ((t = t1) and (t' not in set area))}OkEdge' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)	OkEdge(tpair, stationtopo, stationstate) ==(OkPoints(tpair, (stationtopo.points), (stationstate.pointstates)) and (not StopSignal(tpair, (stationtopo.signals), (stationstate.signalstates))))OkPoints' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Points) * (unresolved impl`Point_states) +> bool)	OkPoints(mk_(t, t'), points, pointstates) ==((IsInterlockPoint(t, points, pointstates) and Branch(mk_(t, t'), points)) => Point_state_ok(mk_(t, t'), t, points, pointstates))StopSignal' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Signals) * (unresolved impl`Signal_states) +> bool)	StopSignal(tpair, signals, signalstates) ==(if (tpair in set (dom signals))then let sigid = signals(tpair) in (signalstates(sigid) = <stop>)else false)Branch' ((((unresolved impl`Track_id) * (unresolved impl`Track_id))) * (unresolved impl`Points) +> bool)	Branch(mk_(t1, t2), points) ==((mk_(t1, t2) in set (dom points)) and (t1 in set (dom points(mk_(t1, t2)))))end impl, module Testexportsexport alldefinitionsstatic private tracksv = {mk_("K12", "26"), mk_("26", "K12"), mk_("25", "26"), mk_("26", "25"), mk_("25", "24"), mk_("25", "17s"), mk_("24", "25"), mk_("24", "23"), mk_("24", "15"), mk_("23", "24"), mk_("23", "22"), mk_("22", "23"), mk_("22", "21"), mk_("21", "22"), mk_("21", "A12"), mk_("A12", "21"), mk_("M12", "18"), mk_("18", "M12"), mk_("18", "17b"), mk_("17b", "18"), mk_("17s", "25"), mk_("17b", "16"), mk_("17s", "27"), mk_("16", "17b"), mk_("16", "19"), mk_("16", "15"), mk_("15", "24"), mk_("15", "16"), mk_("15", "14"), mk_("14", "15"), mk_("14", "13"), mk_("13", "14"), mk_("13", "11"), mk_("11", "13"), mk_("11", "C12"), mk_("C12", "11"), mk_("27", "17s"), mk_("27", "O12"), mk_("O12", "27"), mk_("19", "16"), mk_("19", "Q12"), mk_("Q12", "19")}static private pointsv = {mk_("25", "26") |-> {"25" |-> <right>}, mk_("26", "25") |-> {"25" |-> <right>}, mk_("25", "17s") |-> {"25" |-> <left>}, mk_("17s", "25") |-> {"25" |-> <left>}, mk_("24", "23") |-> {"24" |-> <left>}, mk_("23", "24") |-> {"24" |-> <left>}, mk_("24", "15") |-> {"24" |-> <right>, "15" |-> <right>}, mk_("15", "24") |-> {"24" |-> <right>, "15" |-> <right>}, mk_("16", "17b") |-> {"16" |-> <right>}, mk_("17b", "16") |-> {"16" |-> <right>}, mk_("16", "19") |-> {"16" |-> <left>}, mk_("19", "16") |-> {"16" |-> <left>}, mk_("16", "15") |-> {"15" |-> <left>}, mk_("15", "16") |-> {"15" |-> <left>}}static private crossingsv = {mk_("17s", "17b")}static private signalsv = {mk_("ol", "K12") |-> "N", mk_("26", "K12") |-> "K", mk_("22", "23") |-> "E2", mk_("21", "A12") |-> "D", mk_("ol", "A12") |-> "A", mk_("ol", "M12") |-> "M", mk_("18", "M12") |-> "L", mk_("13", "14") |-> "E1", mk_("11", "C12") |-> "C", mk_("ol", "C12") |-> "B", mk_("27", "O12") |-> "O", mk_("ol", "O12") |-> "R", mk_("ol", "Q12") |-> "Q", mk_("19", "Q12") |-> "P"}static private trackstatev = {"K12" |-> {}, "26" |-> {}, "25" |-> {}, "24" |-> {}, "23" |-> {}, "22" |-> {}, "21" |-> {}, "A12" |-> {}, "M12" |-> {}, "18" |-> {"t2" |-> <fixedroute>}, "17s" |-> {}, "17b" |-> {}, "16" |-> {}, "15" |-> {}, "14" |-> {}, "13" |-> {}, "11" |-> {}, "C12" |-> {}, "O12" |-> {}, "Q12" |-> {}, "19" |-> {}, "27" |-> {}}static private pointstatev = {"25" |-> mk_(<left>, <interlock>), "24" |-> mk_(<right>, <interlock>), "15" |-> mk_(<left>, <interlock>), "16" |-> mk_(<right>, <interlock>)}static private signalstatev = {"N" |-> <stop>, "K" |-> <stop>, "E2" |-> <stop>, "D" |-> <stop>, "A" |-> <stop>, "M" |-> <stop>, "L" |-> <stop>, "E1" |-> <stop>, "C" |-> <stop>, "B" |-> <stop>, "O" |-> <stop>, "R" |-> <stop>, "P" |-> <driveaspect>, "Q" |-> <stop>}end Test
