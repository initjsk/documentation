WARNING:rail.vdmsl:5000:1036,46:Definition 'Signal_states' not used.
WARNING:rail.vdmsl:5000:1032,44:Definition 'Point_state' not used.
WARNING:rail.vdmsl:5000:1347,39:Definition 'Operation' not used.
WARNING:rail.vdmsl:5012:1150,10:Recursive function has no measure.
WARNING:rail.vdmsl:5000:1345,41:Definition 'Point_state' not used.
WARNING:rail.vdmsl:5000:1028,43:Definition 'Train_type' not used.
WARNING:rail.vdmsl:5012:1656,12:Recursive function has no measure.
WARNING:rail.vdmsl:5012:1724,12:Recursive function has no measure.
WARNING:rail.vdmsl:5000:1319,46:Definition 'Point_control' not used.
WARNING:rail.vdmsl:5000:1326,38:Definition 'Signal_id' not used.
WARNING:rail.vdmsl:5012:906,8:Recursive function has no measure.
WARNING:rail.vdmsl:5000:1013,35:Definition 'Signals' not used.
WARNING:rail.vdmsl:5000:1003,23:Definition 'Tracks' not used.
WARNING:rail.vdmsl:5000:1352,0:Definition 'Signal_state' not used.
WARNING:rail.vdmsl:5000:1034,42:Definition 'Operation' not used.
WARNING:rail.vdmsl:5012:1465,10:Recursive function has no measure.
WARNING:rail.vdmsl:5000:1008,63:Definition 'Point_control' not used.
WARNING:rail.vdmsl:5012:1477,10:Recursive function has no measure.
WARNING:rail.vdmsl:5012:1137,10:Recursive function has no measure.
WARNING:rail.vdmsl:5000:1015,38:Definition 'Signal_id' not used.
WARNING:rail.vdmsl:5012:1679,15:Recursive function has no measure.
WARNING:rail.vdmsl:5000:1037,0:Definition 'Signal_state' not used.
WARNING:rail.vdmsl:5012:1697,15:Recursive function has no measure.
WARNING:rail.vdmsl:5012:834,10:Recursive function has no measure.
WARNING:rail.vdmsl:5012:854,10:Recursive function has no measure.
RESULT:result:-1:-1,-1:module stationexportsexport type struct Station_topoexport type struct Tracksexport type struct Track_idexport type struct Pointsexport type struct Point_stateexport type struct Crossingsexport type struct Signalsexport type struct Signal_idexport type struct Station_stateexport type struct Track_statesexport type struct Point_statesexport type struct Signal_statesexport type struct Track_stateexport type struct Train_idexport type struct Train_typeexport type struct Point_controlexport type struct Operationexport type struct Signal_stateexport function Is_wf_Station_topo'((unresolved station`Station_topo) +> bool)export function Is_wf_Station_state'((unresolved station`Station_topo) * (unresolved station`Station_state) +> bool)definitionsstatic private Tracks = set of ((Track_id * Track_id))static private Track_id = seq of (char)NoReflexive' (Tracks +> bool)	NoReflexive(tracks) ==(forall mk_(t1, t2) in set tracks & (t1 <> t2))Symmetric' (Tracks +> bool)	Symmetric(tracks) ==(forall mk_(t1, t2) in set tracks & (mk_(t2, t1) in set tracks))Is_wf_Tracks' (Tracks +> bool)	Is_wf_Tracks(tracks) ==(NoReflexive(tracks) and Symmetric(tracks))static private Points = map ((Track_id * Track_id)) to (map (Track_id) to (Point_control))static private Point_control = (<left> | <right>)static private Crossings = set of ((Track_id * Track_id))PointsInTracks' (Tracks * Points +> bool)	PointsInTracks(tracks, points) ==((dom points) subset tracks)Inverses' (Points +> bool)	Inverses(points) ==(forall mk_(t1, t2) in set (dom points) & ((mk_(t2, t1) in set (dom points)) and (points(mk_(t1, t2)) = points(mk_(t2, t1)))))OkDomRng' (Points +> bool)	OkDomRng(points) ==(forall mk_(t1, t2) in set (dom points) & ((points(mk_(t1, t2)) <> {}) and ((dom points(mk_(t1, t2))) subset {t1, t2})))RelateToTracks' (Tracks * Points +> bool)	RelateToTracks(tracks, points) ==((forall tpair in set (dom points) & (forall pid in set (dom points(tpair)) & ((card {t | [mk_(t, t') in set tracks] & (t' = pid)}) = 3))) and (forall mk_(t1, -) in set tracks & ((not (exists [tpair in set (dom points)] & (t1 in set (dom points(tpair))))) => ((card {t | [mk_(t, t') in set tracks] & (t' = t1)}) <= 2))))Control2Dir' (Points +> bool)	Control2Dir(points) ==(forall mk_(t1, t2) in set (dom points) & (((({t1} <' points(mk_(t1, t2))) = {t1 |-> <left>}) => (exists [mk_(t, t') in set (dom points)] & ((t = t1) and (({t1} <' points(mk_(t1, t'))) = {t1 |-> <right>})))) and ((({t1} <' points(mk_(t1, t2))) = {t1 |-> <right>}) => (exists [mk_(t, t') in set (dom points)] & ((t = t1) and (({t1} <' points(mk_(t1, t'))) = {t1 |-> <left>}))))))Is_wf_Points' (Tracks * Points +> bool)	Is_wf_Points(tracks, points) ==(PointsInTracks(tracks, points) and (Inverses(points) and (OkDomRng(points) and (RelateToTracks(tracks, points) and Control2Dir(points)))))SeperateBranches' (Tracks * Crossings +> bool)	SeperateBranches(tracks, crossings) ==((crossings inter tracks) = {})CrossInTracks' (Tracks * Crossings +> bool)	CrossInTracks(tracks, crossings) ==(forall mk_(t1, t2) in set crossings & ((exists [mk_(t3, -) in set tracks] & (t1 = t3)) and (exists [mk_(t4, -) in set tracks] & (t2 = t4))))UniqueCross' (Crossings +> bool)	UniqueCross(crossings) ==(forall mk_(t1, t2) in set crossings & ((t1 <> t2) and (forall mk_(t3, t4) in set (crossings \ {mk_(t1, t2)}) & ((t1 <> t3) and ((t1 <> t4) and ((t2 <> t3) and (t2 <> t4)))))))DiffPointsCrossings' (Points * Crossings +> bool)	DiffPointsCrossings(points, crossings) ==(forall mk_(t1, t2) in set crossings & (forall pointcontrol in set (rng points) & ((t1 not in set (dom pointcontrol)) and (t2 not in set (dom pointcontrol)))))Is_wf_Crossings' (Tracks * Points * Crossings +> bool)	Is_wf_Crossings(tracks, points, crossings) ==(SeperateBranches(tracks, crossings) and (CrossInTracks(tracks, crossings) and (UniqueCross(crossings) and DiffPointsCrossings(points, crossings))))static private Signals = map ((Track_id * Track_id)) to (Signal_id)static private Signal_id = seq of (char)UniqueSignals' (Signals +> bool)	UniqueSignals(signals) ==((card (rng signals)) = (card (dom signals)))SigInTracks' (Tracks * Signals +> bool)	SigInTracks(tracks, signals) ==(forall mk_(t1, t2) in set (dom signals) & (((t1 = "ol") => ((card {t | [mk_(t, t') in set tracks] & (t' = t2)}) = 1)) and (((t2 = "ol") => ((card {t | [mk_(t, t') in set tracks] & (t' = t1)}) = 1)) and (((t1 <> "ol") and (t2 <> "ol")) => (mk_(t1, t2) in set tracks)))))Is_wf_Signals' (Tracks * Signals +> bool)	Is_wf_Signals(tracks, signals) ==(UniqueSignals(signals) and SigInTracks(tracks, signals))static private Station_topo = compose Station_topo of tracks'Tracks, points'Points, crossings'Crossings, signals'Signals endIs_wf_Station_topo' (Station_topo +> bool)	Is_wf_Station_topo(stationtopo) ==(Is_wf_Tracks((stationtopo.tracks)) and (Is_wf_Points((stationtopo.tracks), (stationtopo.points)) and (Is_wf_Crossings((stationtopo.tracks), (stationtopo.points), (stationtopo.crossings)) and Is_wf_Signals((stationtopo.tracks), (stationtopo.signals)))))static private Station_state = compose Station_state of trackstates'Track_states, pointstates'Point_states, signalstates'Signal_states endstatic private Track_states = map (Track_id) to (Track_state)static private Point_states = map (Track_id) to (Point_state)static private Signal_states = map (Signal_id) to (Signal_state)static private Track_state = map (Train_id) to (Train_type)static private Train_id = seq of (char)static private Train_type = (<autonomous> | <fixedroute>)static private Point_state = (Point_control * Operation)static private Operation = (<interlock> | <manual>)static private Signal_state = (<driveaspect> | <stop>)ConformTracks' (Tracks * Track_states +> bool)	ConformTracks(tracks, trackstates) ==(TracksStateInTopo(tracks, trackstates) and TracksTopoInState(tracks, trackstates))TracksStateInTopo' (Tracks * Track_states +> bool)	TracksStateInTopo(tracks, trackstates) ==(forall t in set (dom trackstates) & (exists [mk_(t1, t2) in set tracks] & ((t = t1) or (t = t2))))TracksTopoInState' (Tracks * Track_states +> bool)	TracksTopoInState(tracks, trackstates) ==(forall mk_(t1, t2) in set tracks & ((t1 in set (dom trackstates)) and (t2 in set (dom trackstates))))ConformPoints' (Points * Point_states +> bool)	ConformPoints(points, pointstates) ==(PointsStateInTopo(points, pointstates) and PointsTopoInState(points, pointstates))PointsStateInTopo' (Points * Point_states +> bool)	PointsStateInTopo(points, pointstates) ==(forall t in set (dom pointstates) & (exists [mk_(t1, t2) in set (dom points)] & (t in set (dom points(mk_(t1, t2))))))PointsTopoInState' (Points * Point_states +> bool)	PointsTopoInState(points, pointstates) ==(forall mk_(t1, t2) in set (dom points) & (((t1 in set (dom points(mk_(t1, t2)))) => (t1 in set (dom pointstates))) and ((t2 in set (dom points(mk_(t1, t2)))) => (t2 in set (dom pointstates)))))ConformSignals' (Signals * Signal_states +> bool)	ConformSignals(signals, signalstates) ==((rng signals) = (dom signalstates))Is_wf_Trains' (Tracks * Points * Crossings * Track_states +> bool)	Is_wf_Trains(tracks, points, crossings, trackstates) ==(UniqueTrain(trackstates) and let trains'map (Train_id) to (set of (Track_id)) = Trains(trackstates, {}) in (Connected(trains, tracks) and (OkPointTrains(trains, points) and OkCrossTrains(trains, crossings))))UniqueTrain' (Track_states +> bool)	UniqueTrain(trackstates) ==(forall trackid in set (dom trackstates) & (forall trainid in set (dom trackstates(trackid)) & (((trackstates(trackid)(trainid) = <fixedroute>) => (forall trackid' in set (dom trackstates) & ((trainid in set (dom trackstates(trackid'))) => (trackstates(trackid')(trainid) = <fixedroute>)))) and ((trackstates(trackid)(trainid) = <autonomous>) => (forall trackid' in set (dom trackstates) & ((trainid in set (dom trackstates(trackid'))) => (trackstates(trackid')(trainid) = <autonomous>)))))))Trains' (Track_states * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Trains(trackstates, sorted) ==(if (trackstates = {})then sortedelse let t in set (dom trackstates) in (if (trackstates(t) = {})then Trains(({t} <-' trackstates), sorted)else Trains(({t} <-' trackstates), Update(mk_(t, trackstates(t)), sorted))))Update' ((Track_id * Track_state) * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Update(mk_(t, trackstate), sorted) ==(if (trackstate = {})then sortedelse let tid in set (dom trackstate) in (if (tid in set (dom sorted))then Update(mk_(t, ({tid} <-' trackstate)), (sorted ++ {tid |-> ({t} union sorted(tid))}))else Update(mk_(t, ({tid} <-' trackstate)), (sorted munion {tid |-> {t}}))))Connected' (map (Train_id) to (set of (Track_id)) * Tracks +> bool)	Connected(trains, tracks) ==(forall trackset in set (rng trains) & ExistsPath(trackset, tracks))ExistsPath' (set of (Track_id) * Tracks +> bool)	ExistsPath(trackset, tracks) ==(exists [t in set trackset] & Path((trackset \ {t}), [t], tracks, {}))Path' (set of (Track_id) * seq of (Track_id) * Tracks * set of (Track_id) +> bool)	Path(trackset, connected, tracks, tried) ==(if (trackset = {})then (tried = {})else let t in set trackset in (if (mk_(t, (hd connected)) in set tracks)then Path(((trackset \ {t}) union tried), ([t] ^ connected), tracks, {})else (if (mk_(connected((len connected)), t) in set tracks)then Path(((trackset \ {t}) union tried), (connected ^ [t]), tracks, {})else Path((trackset \ {t}), connected, tracks, (tried union {t})))))OkPointTrains' (map (Train_id) to (set of (Track_id)) * Points +> bool)	OkPointTrains(trains, points) ==(forall trackset in set (rng trains) & (forall t1, t2 in set trackset & (((mk_(t1, t2) in set (dom points)) and (t1 in set (dom points(mk_(t1, t2))))) => (forall t3 in set trackset & (((mk_(t1, t3) in set (dom points)) and (t1 in set (dom points(mk_(t1, t3))))) => (points(mk_(t1, t2))(t1) = points(mk_(t1, t3))(t1)))))))OkCrossTrains' (map (Track_id) to (set of (Track_id)) * Crossings +> bool)	OkCrossTrains(trains, crossings) ==(forall trackidset in set (rng trains) & (forall t1, t2 in set trackidset & (mk_(t1, t2) not in set crossings)))Is_wf_Station_state' (Station_topo * Station_state +> bool)	Is_wf_Station_state(stationtopo, stationstate) ==(ConformTracks((stationtopo.tracks), (stationstate.trackstates)) and (ConformPoints((stationtopo.points), (stationstate.pointstates)) and (ConformSignals((stationtopo.signals), (stationstate.signalstates)) and Is_wf_Trains((stationtopo.tracks), (stationtopo.points), (stationtopo.crossings), (stationstate.trackstates)))))end station, module safe_reqimportsfrom stationimport type Station_topo = compose Station_topo of tracks'Tracks, points'Points, crossings'Crossings, signals'Signals end renamed Station_topoimport type Tracks = set of ((Track_id * Track_id)) renamed Tracksimport type Track_id = seq of (char) renamed Track_idimport type Points = map ((Track_id * Track_id)) to (map (Track_id) to (Point_control)) renamed Pointsimport type Point_control = (<left> | <right>) renamed Point_controlimport type Crossings = set of ((Track_id * Track_id)) renamed Crossingsimport type Signals = map ((Track_id * Track_id)) to (Signal_id) renamed Signalsimport type Signal_id = seq of (char) renamed Signal_idimport type Station_state = compose Station_state of trackstates'Track_states, pointstates'Point_states, signalstates'Signal_states end renamed Station_stateimport type Track_states = map (Track_id) to (Track_state) renamed Track_statesimport type Track_state = map (Train_id) to (Train_type) renamed Track_stateimport type Train_id = seq of (char) renamed Train_idimport type Train_type = (<autonomous> | <fixedroute>) renamed Train_typeimport type Point_states = map (Track_id) to (Point_state) renamed Point_statesimport type Point_state = (Point_control * Operation) renamed Point_stateimport type Operation = (<interlock> | <manual>) renamed Operationimport type Signal_states = map (Signal_id) to (Signal_state) renamed Signal_statesimport type Signal_state = (<driveaspect> | <stop>) renamed Signal_stateimport function Is_wf_Station_topo renamed Is_wf_Station_topo'(Station_topo +> bool)import function Is_wf_Station_state renamed Is_wf_Station_state'(Station_topo * Station_state +> bool)exportsexport function SafeReq'((unresolved safe_req`Station_topo) * (unresolved safe_req`Station_state) +> bool)definitionsSafeReq' (Station_topo * Station_state +> bool)	SafeReq(stationtopo, stationstate) ==(NoCollision(stationtopo, stationstate) and NoDerail(stationtopo, stationstate))	pre (Is_wf_Station_topo(stationtopo) and Is_wf_Station_state(stationtopo, stationstate))NoCollision' (Station_topo * Station_state +> bool)	NoCollision(stationtopo, stationstate) ==(forall tid in set (dom (stationstate.trackstates)) & (((card (dom (stationstate.trackstates)(tid))) <= 1) and OneTrainAtCross((stationtopo.crossings), (stationstate.trackstates))))OneTrainAtCross' (Crossings * Track_states +> bool)	OneTrainAtCross(crossings, trackstates) ==(forall mk_(tid1, tid2) in set crossings & (((card (dom trackstates(tid1))) + (card (dom trackstates(tid2)))) <= 1))NoDerail' (Station_topo * Station_state +> bool)	NoDerail(stationtopo, stationstate) ==let trains'map (Train_id) to (set of (Track_id)) = Trains((stationstate.trackstates), {}) in (forall t in set (dom trains) & (forall t1, t2 in set trains(t) & ((mk_(t1, t2) in set (dom (stationtopo.points))) => Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))Trains' (Track_states * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Trains(trackstates, sorted) ==(if (trackstates = {})then sortedelse let t in set (dom trackstates) in (if (trackstates(t) = {})then Trains(({t} <-' trackstates), sorted)else Trains(({t} <-' trackstates), Update(mk_(t, trackstates(t)), sorted))))Update' ((Track_id * Track_state) * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Update(mk_(t, trainids), sorted) ==(if (trainids = {})then sortedelse let tid in set (dom trainids) in (if (tid in set (dom sorted))then Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> ({t} union sorted(tid))}))else Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> {t}}))))Ok_Point_states' ((Track_id * Track_id) * Points * Point_states +> bool)	Ok_Point_states(mk_(t1, t2), points, pointstates) ==(if ({t1, t2} = (dom points(mk_(t1, t2))))then (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))else (if ({t1} = (dom points(mk_(t1, t2))))then Point_state_ok(mk_(t1, t2), t1, points, pointstates)else Point_state_ok(mk_(t1, t2), t2, points, pointstates)))	pre (mk_(t1, t2) in set (dom points))Point_state_ok' ((Track_id * Track_id) * Track_id * Points * Point_states +> bool)	Point_state_ok(tpair, t, points, pointstates) ==let mk_(pcnt, -)'Point_state = pointstates(t) in (points(tpair)(t) = pcnt)	pre ((t in set (dom pointstates)) and ((tpair in set (dom points)) and (t in set (dom points(tpair)))))end safe_req, module implimportsfrom stationimport type Station_topo = compose Station_topo of tracks'Tracks, points'Points, crossings'Crossings, signals'Signals end renamed Station_topoimport type Tracks = set of ((Track_id * Track_id)) renamed Tracksimport type Track_id = seq of (char) renamed Track_idimport type Points = map ((Track_id * Track_id)) to (map (Track_id) to (Point_control)) renamed Pointsimport type Point_control = (<left> | <right>) renamed Point_controlimport type Crossings = set of ((Track_id * Track_id)) renamed Crossingsimport type Signals = map ((Track_id * Track_id)) to (Signal_id) renamed Signalsimport type Signal_id = seq of (char) renamed Signal_idimport type Station_state = compose Station_state of trackstates'Track_states, pointstates'Point_states, signalstates'Signal_states end renamed Station_stateimport type Track_states = map (Track_id) to (Track_state) renamed Track_statesimport type Track_state = map (Train_id) to (Train_type) renamed Track_stateimport type Train_id = seq of (char) renamed Train_idimport type Train_type = (<autonomous> | <fixedroute>) renamed Train_typeimport type Point_states = map (Track_id) to (Point_state) renamed Point_statesimport type Point_state = (Point_control * Operation) renamed Point_stateimport type Operation = (<interlock> | <manual>) renamed Operationimport type Signal_states = map (Signal_id) to (Signal_state) renamed Signal_statesimport type Signal_state = (<driveaspect> | <stop>) renamed Signal_stateimport function Is_wf_Station_topo renamed Is_wf_Station_topo'(Station_topo +> bool)import function Is_wf_Station_state renamed Is_wf_Station_state'(Station_topo * Station_state +> bool)exportsexport function Impl'((unresolved impl`Station_topo) * (unresolved impl`Station_state) +> bool)definitionsstatic private Areas = map (Train_id) to (Area)static private Area = set of (Track_id)Impl' (Station_topo * Station_state +> bool)	Impl(stationtopo, stationstate) ==let areas'Areas = FindAreas(stationtopo, stationstate) in (NoCollision(areas, (stationtopo.crossings)) and NoDerail(areas, stationtopo, stationstate))	pre (Is_wf_Station_topo(stationtopo) and Is_wf_Station_state(stationtopo, stationstate))NoCollision' (Areas * Crossings +> bool)	NoCollision(areas, crossings) ==(forall train1, train2 in set (dom areas) & ((train1 <> train2) => (((areas(train1) inter areas(train2)) = {}) and (forall t1 in set areas(train1) & (forall t2 in set areas(train2) & (mk_(t1, t2) not in set crossings))))))NoDerail' (Areas * Station_topo * Station_state +> bool)	NoDerail(areas, stationtopo, stationstate) ==(NoDerailUnderTrains(stationtopo, stationstate) and NoDerailPossible(areas, stationtopo, stationstate))NoDerailUnderTrains' (Station_topo * Station_state +> bool)	NoDerailUnderTrains(stationtopo, stationstate) ==let trains'map (Train_id) to (set of (Track_id)) = Trains((stationstate.trackstates), {}) in (forall t in set (dom trains) & (forall t1, t2 in set trains(t) & ((mk_(t1, t2) in set (dom (stationtopo.points))) => Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))NoDerailPossible' (Areas * Station_topo * Station_state +> bool)	NoDerailPossible(areas, stationtopo, stationstate) ==(forall area in set (rng areas) & let traintype'Train_type = TrainType(area, stationstate) in (if (traintype = <fixedroute>)then NoDerailFixed(area, stationtopo, stationstate)else NoDerailAutonomous(area, stationtopo, stationstate)))Trains' (Track_states * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Trains(trackstates, sorted) ==(if (trackstates = {})then sortedelse let t in set (dom trackstates) in (if (trackstates(t) = {})then Trains(({t} <-' trackstates), sorted)else Trains(({t} <-' trackstates), Update(mk_(t, trackstates(t)), sorted))))Update' ((Track_id * Track_state) * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Update(mk_(t, trainids), sorted) ==(if (trainids = {})then sortedelse let tid in set (dom trainids) in (if (tid in set (dom sorted))then Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> ({t} union sorted(tid))}))else Update(mk_(t, ({tid} <-' trainids)), (sorted ++ {tid |-> {t}}))))TrainType' (Area * Station_state +> Train_type)	TrainType(area, stationstate) ==let t in set area be st ((stationstate.trackstates)(t) <> {}) in let tt in set (dom (stationstate.trackstates)(t)) in (stationstate.trackstates)(t)(tt)	pre (forall t in set area & (t in set (dom (stationstate.trackstates))))NoDerailFixed' (Area * Station_topo * Station_state +> bool)	NoDerailFixed(area, stationtopo, stationstate) ==(forall t1, t2 in set area & ((mk_(t1, t2) in set (dom (stationtopo.points))) => (Ok_Point_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)) and InterlockPoints(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates)))))Ok_Point_states' ((Track_id * Track_id) * Points * Point_states +> bool)	Ok_Point_states(mk_(t1, t2), points, pointstates) ==(if ({t1, t2} = (dom points(mk_(t1, t2))))then (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))else (if ({t1} = (dom points(mk_(t1, t2))))then Point_state_ok(mk_(t1, t2), t1, points, pointstates)else Point_state_ok(mk_(t1, t2), t2, points, pointstates)))	pre (mk_(t1, t2) in set (dom points))Point_state_ok' ((Track_id * Track_id) * Track_id * Points * Point_states +> bool)	Point_state_ok(tpair, t, points, pointstates) ==let mk_(pcnt, -)'Point_state = pointstates(t) in (points(tpair)(t) = pcnt)	pre ((t in set (dom pointstates)) and ((tpair in set (dom points)) and (t in set (dom points(tpair)))))InterlockPoints' ((Track_id * Track_id) * Points * Point_states +> bool)	InterlockPoints(mk_(t1, t2), points, pointstates) ==(if (IsPoint(t1, points) and IsPoint(t2, points))then (IsInterlockPoint(t1, points, pointstates) and IsInterlockPoint(t2, points, pointstates))else (if IsPoint(t1, points)then IsInterlockPoint(t1, points, pointstates)else IsInterlockPoint(t2, points, pointstates)))	pre (IsPoint(t1, points) or IsPoint(t2, points))IsPoint' (Track_id * Points +> bool)	IsPoint(t, points) ==(exists [mk_(t1, t2) in set (dom points)] & (t in set (dom points(mk_(t1, t2)))))IsInterlockPoint' (Track_id * Points * Point_states +> bool)	IsInterlockPoint(t, points, pointstates) ==(if IsPoint(t, points)then let mk_(-, operation)'Point_state = pointstates(t) in (operation = <interlock>)else false)NoDerailAutonomous' (Area * Station_topo * Station_state +> bool)	NoDerailAutonomous(area, stationtopo, stationstate) ==(forall t1, t2 in set area & ((mk_(t1, t2) in set (dom (stationtopo.points))) => OkAutonomPoint_states(mk_(t1, t2), (stationtopo.points), (stationstate.pointstates))))OkAutonomPoint_states' ((Track_id * Track_id) * Points * Point_states +> bool)	OkAutonomPoint_states(mk_(t1, t2), points, pointstates) ==(if (IsInterlockPoint(t1, points, pointstates) and IsInterlockPoint(t2, points, pointstates))then (Point_state_ok(mk_(t1, t2), t1, points, pointstates) and Point_state_ok(mk_(t1, t2), t2, points, pointstates))else (if IsInterlockPoint(t1, points, pointstates)then Point_state_ok(mk_(t1, t2), t1, points, pointstates)else (if IsInterlockPoint(t2, points, pointstates)then Point_state_ok(mk_(t1, t2), t2, points, pointstates)else true)))FindAreas' (Station_topo * Station_state +> Areas)	FindAreas(stationtopo, stationstate) ==let occupied'map (Train_id) to (set of (Track_id)) = Occupied((stationstate.trackstates), {}) in DeduceAreas(occupied, stationtopo, stationstate)Occupied' (Track_states * map (Train_id) to (set of (Track_id)) +> map (Train_id) to (set of (Track_id)))	Occupied(trackstates, occupied) ==(if (forall s in set (rng trackstates) & (s = {}))then occupiedelse let trains in set (rng trackstates) be st (trains <> {}) in let train in set (dom trains) in Occupied(RemoveTrain(train, trackstates), (occupied munion {train |-> {tid | [tid in set (dom trackstates)] & (train in set (dom trackstates(tid)))}})))	pre (forall trackstate in set (rng trackstates) & (((dom trackstate) inter (dom occupied)) = {}))RemoveTrain' (Train_id * Track_states +> Track_states)	RemoveTrain(train, trackstates) ==(if (trackstates = {})then {}else let tid in set (dom trackstates) in (if (train in set (dom trackstates(tid)))then RemoveTrain(train, (trackstates ++ {tid |-> ({train} <-' trackstates(tid))}))else ({tid |-> trackstates(tid)} munion RemoveTrain(train, ({tid} <-' trackstates)))))DeduceAreas' (map (Train_id) to (set of (Track_id)) * Station_topo * Station_state +> Areas)	DeduceAreas(occupied, stationtopo, stationstate) ==(if (occupied = {})then {}else let train in set (dom occupied) in let area'Area = FindArea(occupied(train), {}, stationtopo, stationstate) in ({train |-> area} munion DeduceAreas(({train} <-' occupied), stationtopo, stationstate)))FindArea' (set of (Track_id) * Area * Station_topo * Station_state +> Area)	FindArea(tracks, area, stationtopo, stationstate) ==(if (tracks = {})then areaelse let t in set tracks in let neighbours'set of (Track_id) = Neighbours(t, area, stationtopo, stationstate) in FindArea(((tracks \ {t}) union neighbours), (area union {t}), stationtopo, stationstate))Neighbours' (Track_id * set of (Track_id) * Station_topo * Station_state +> set of (Track_id))	Neighbours(t, area, stationtopo, stationstate) ==let neighcand'set of (Track_id) = NeighbourCandidates(t, area, (stationtopo.tracks)) in {t' | [t' in set neighcand] & OkEdge(mk_(t, t'), stationtopo, stationstate)}NeighbourCandidates' (Track_id * set of (Track_id) * Tracks +> set of (Track_id))	NeighbourCandidates(t, area, tracks) =={t' | [mk_(t1, t') in set tracks] & ((t = t1) and (t' not in set area))}OkEdge' ((Track_id * Track_id) * Station_topo * Station_state +> bool)	OkEdge(tpair, stationtopo, stationstate) ==(OkPoints(tpair, (stationtopo.points), (stationstate.pointstates)) and (not StopSignal(tpair, (stationtopo.signals), (stationstate.signalstates))))OkPoints' ((Track_id * Track_id) * Points * Point_states +> bool)	OkPoints(mk_(t, t'), points, pointstates) ==((IsInterlockPoint(t, points, pointstates) and Branch(mk_(t, t'), points)) => Point_state_ok(mk_(t, t'), t, points, pointstates))StopSignal' ((Track_id * Track_id) * Signals * Signal_states +> bool)	StopSignal(tpair, signals, signalstates) ==(if (tpair in set (dom signals))then let sigid'Signal_id = signals(tpair) in (signalstates(sigid) = <stop>)else false)Branch' ((Track_id * Track_id) * Points +> bool)	Branch(mk_(t1, t2), points) ==((mk_(t1, t2) in set (dom points)) and (t1 in set (dom points(mk_(t1, t2)))))end impl, module Testexportsexport alldefinitionsstatic private tracksv'set of ((seq1 of (char) * seq1 of (char))) = {mk_("K12", "26"), mk_("26", "K12"), mk_("25", "26"), mk_("26", "25"), mk_("25", "24"), mk_("25", "17s"), mk_("24", "25"), mk_("24", "23"), mk_("24", "15"), mk_("23", "24"), mk_("23", "22"), mk_("22", "23"), mk_("22", "21"), mk_("21", "22"), mk_("21", "A12"), mk_("A12", "21"), mk_("M12", "18"), mk_("18", "M12"), mk_("18", "17b"), mk_("17b", "18"), mk_("17s", "25"), mk_("17b", "16"), mk_("17s", "27"), mk_("16", "17b"), mk_("16", "19"), mk_("16", "15"), mk_("15", "24"), mk_("15", "16"), mk_("15", "14"), mk_("14", "15"), mk_("14", "13"), mk_("13", "14"), mk_("13", "11"), mk_("11", "13"), mk_("11", "C12"), mk_("C12", "11"), mk_("27", "17s"), mk_("27", "O12"), mk_("O12", "27"), mk_("19", "16"), mk_("19", "Q12"), mk_("Q12", "19")}static private pointsv'map ((seq1 of (char) * seq1 of (char))) to ((map (seq1 of (char)) to (<left>) | map (seq1 of (char)) to (<right>))) = {mk_("25", "26") |-> {"25" |-> <right>}, mk_("26", "25") |-> {"25" |-> <right>}, mk_("25", "17s") |-> {"25" |-> <left>}, mk_("17s", "25") |-> {"25" |-> <left>}, mk_("24", "23") |-> {"24" |-> <left>}, mk_("23", "24") |-> {"24" |-> <left>}, mk_("24", "15") |-> {"24" |-> <right>, "15" |-> <right>}, mk_("15", "24") |-> {"24" |-> <right>, "15" |-> <right>}, mk_("16", "17b") |-> {"16" |-> <right>}, mk_("17b", "16") |-> {"16" |-> <right>}, mk_("16", "19") |-> {"16" |-> <left>}, mk_("19", "16") |-> {"16" |-> <left>}, mk_("16", "15") |-> {"15" |-> <left>}, mk_("15", "16") |-> {"15" |-> <left>}}static private crossingsv'set of ((seq1 of (char) * seq1 of (char))) = {mk_("17s", "17b")}static private signalsv'map ((seq1 of (char) * seq1 of (char))) to (seq1 of (char)) = {mk_("ol", "K12") |-> "N", mk_("26", "K12") |-> "K", mk_("22", "23") |-> "E2", mk_("21", "A12") |-> "D", mk_("ol", "A12") |-> "A", mk_("ol", "M12") |-> "M", mk_("18", "M12") |-> "L", mk_("13", "14") |-> "E1", mk_("11", "C12") |-> "C", mk_("ol", "C12") |-> "B", mk_("27", "O12") |-> "O", mk_("ol", "O12") |-> "R", mk_("ol", "Q12") |-> "Q", mk_("19", "Q12") |-> "P"}static private trackstatev'map (seq1 of (char)) to ((map (?) to (?) | map (seq1 of (char)) to (<fixedroute>))) = {"K12" |-> {}, "26" |-> {}, "25" |-> {}, "24" |-> {}, "23" |-> {}, "22" |-> {}, "21" |-> {}, "A12" |-> {}, "M12" |-> {}, "18" |-> {"t2" |-> <fixedroute>}, "17s" |-> {}, "17b" |-> {}, "16" |-> {}, "15" |-> {}, "14" |-> {}, "13" |-> {}, "11" |-> {}, "C12" |-> {}, "O12" |-> {}, "Q12" |-> {}, "19" |-> {}, "27" |-> {}}static private pointstatev'map (seq1 of (char)) to (((<left> * <interlock>) | (<right> * <interlock>))) = {"25" |-> mk_(<left>, <interlock>), "24" |-> mk_(<right>, <interlock>), "15" |-> mk_(<left>, <interlock>), "16" |-> mk_(<right>, <interlock>)}static private signalstatev'map (seq1 of (char)) to ((<driveaspect> | <stop>)) = {"N" |-> <stop>, "K" |-> <stop>, "E2" |-> <stop>, "D" |-> <stop>, "A" |-> <stop>, "M" |-> <stop>, "L" |-> <stop>, "E1" |-> <stop>, "C" |-> <stop>, "B" |-> <stop>, "O" |-> <stop>, "R" |-> <stop>, "P" |-> <driveaspect>, "Q" |-> <stop>}end Test
