WARNING:metro.vdmsl:5000:214,33:Definition 'int2' not used.
WARNING:metro.vdmsl:5000:101,32:Definition 'bellon' not used.
WARNING:metro.vdmsl:5000:218,24:Definition 'int2' not used.
WARNING:metro.vdmsl:5000:214,28:Definition 'int1' not used.
WARNING:metro.vdmsl:5000:218,19:Definition 'int1' not used.
RESULT:result:-1:-1,-1:module Metro1exportsexport alldefinitionsstate Metroof[doors'(<Closed> | <Open>), train'(<Moving> | <Stopped>)]	inv mk_Metro(doors, train) == (not ((doors = <Open>) and (train = <Moving>)))	init metro == (metro = mk_Metro(<Closed>, <Stopped>))Accelerate (() ==> ())	Accelerate() ==(train '= <Moving>)	pre (doors = <Closed>)Break (() ==> ())	Break() ==(train '= <Stopped>)Open (() ==> ())	Open() ==(doors '= <Open>)	pre (train = <Stopped>)Close (() ==> ())	Close() ==(doors '= <Closed>)end Metro1, module Metro1aexportsexport alldefinitionsstate Metroof[doorsopen'bool, trainmoving'bool]	inv mk_Metro(doorsopen, trainmoving) == (not (doorsopen and trainmoving))	init metro == (metro = mk_Metro(false, false))Accelerate()	ext [wr trainmoving'?, rd doorsopen'?]	pre (not doorsopen)	post trainmovingBreak()	ext [wr trainmoving'?]	post (not trainmoving)Open()	ext [wr doorsopen'?, rd trainmoving'?]	pre (not trainmoving)	post doorsopenClose()	ext [wr doorsopen'?]	post (not doorsopen)end Metro1a, module Metro2exportsexport alldefinitionsstate Metroof[doors'(<Closed> | <Open>), train'(<Moving> | <Stopped>), bellon'[Time]]	inv mk_Metro(doors, train, bellon) == (not ((doors = <Open>) and (train = <Moving>)))	init metro == (metro = mk_Metro(<Closed>, <Stopped>, nil))static private Time = natAccelerate (() ==> ())	Accelerate() ==(train '= <Moving>)	pre (doors = <Open>)Break (() ==> ())	Break() ==(train '= <Stopped>)Open (() ==> ())	Open() ==(doors '= <Open>)	pre (train = <Stopped>)CloseDepressed (Time ==> ())	CloseDepressed(t) ==(bellon '= t)	pre (bellon = nil)CloseReleased (Time ==> ())	CloseReleased(t) ==(if ((t + 3) >= bellon)thendoors '= <Closed>elseskip;bellon '= nil)	pre (bellon <> nil)end Metro2, module Metro3exportsexport alldefinitionsstatic private Time = real	inv t == (t > 0)static private Interval = compose Interval of start'Time, stop'Time end	inv mk_Interval(s, e) == (s < e)static private LifeTime = seq of (Interval)	inv s == (forall i in set {1, ... ,((len s) - 1)} & ((s(i).stop) < (s((i + 1)).start)))static private System = compose System of train'LifeTime, doors'LifeTime, bell'LifeTime, closebut'LifeTime, closeassist'LifeTime end	inv mk_System(train, doors, bell, closebut, closeassist) == (NotMovingAndOpen(train, doors) and (BellOnWhenCloseBut(bell, closebut) and CloseAssistAfter3Secs(closeassist, bell)))NotMovingAndOpen' (LifeTime * LifeTime -> bool)	NotMovingAndOpen(train, doors) ==(forall i in set (inds train), j in set (inds doors) & (not OverlappingIntervals(train(i), doors(j))))CloseAssistAfter3Secs' (LifeTime * LifeTime -> bool)	CloseAssistAfter3Secs(closeassist, bell) ==(forall i in set (inds closeassist) & (exists [j in set (inds bell)] & (((bell(j).stop) >= ((bell(j).start) + 3)) and ((closeassist(i).start) = ((bell(j).start) + 3)))))BellOnWhenCloseBut' (LifeTime * LifeTime -> bool)	BellOnWhenCloseBut(bell, closebut) ==(forall i in set (inds bell) & (exists [j in set (inds closebut)] & SubInterval(bell(i), closebut(j))))OverlappingIntervals' (Interval * Interval -> bool)	OverlappingIntervals(int1, int2) ==(undefined)SubInterval' (Interval * Interval -> bool)	SubInterval(int1, int2) ==(undefined)end Metro3
