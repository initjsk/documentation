RESULT:result:-1:-1,-1:module Metro1exportsexport alldefinitionsstate Metroof[doors'(<Closed> | <Open>), train'(<Moving> | <Stopped>)]	inv mk_(unresolved Metro1`Metro)(doors, train) == (not ((doors = <Open>) and (train = <Moving>)))	init metro == (metro = mk_Metro(<Closed>, <Stopped>))Accelerate (() ==> ())	Accelerate() ==(train '= <Moving>)	pre (doors = <Closed>)Break (() ==> ())	Break() ==(train '= <Stopped>)Open (() ==> ())	Open() ==(doors '= <Open>)	pre (train = <Stopped>)Close (() ==> ())	Close() ==(doors '= <Closed>)end Metro1, module Metro1aexportsexport alldefinitionsstate Metroof[doorsopen'bool, trainmoving'bool]	inv mk_(unresolved Metro1a`Metro)(doorsopen, trainmoving) == (not (doorsopen and trainmoving))	init metro == (metro = mk_Metro(false, false))Accelerate()	ext [wr trainmoving'?, rd doorsopen'?]	pre (not doorsopen)	post trainmovingBreak()	ext [wr trainmoving'?]	post (not trainmoving)Open()	ext [wr doorsopen'?, rd trainmoving'?]	pre (not trainmoving)	post doorsopenClose()	ext [wr doorsopen'?]	post (not doorsopen)end Metro1a, module Metro2exportsexport alldefinitionsstate Metroof[doors'(<Closed> | <Open>), train'(<Moving> | <Stopped>), bellon'[(unresolved Metro2`Time)]]	inv mk_(unresolved Metro2`Metro)(doors, train, bellon) == (not ((doors = <Open>) and (train = <Moving>)))	init metro == (metro = mk_Metro(<Closed>, <Stopped>, nil))static private Time = natAccelerate (() ==> ())	Accelerate() ==(train '= <Moving>)	pre (doors = <Open>)Break (() ==> ())	Break() ==(train '= <Stopped>)Open (() ==> ())	Open() ==(doors '= <Open>)	pre (train = <Stopped>)CloseDepressed ((unresolved Metro2`Time) ==> ())	CloseDepressed(t) ==(bellon '= t)	pre (bellon = nil)CloseReleased ((unresolved Metro2`Time) ==> ())	CloseReleased(t) ==(if ((t + 3) >= bellon)thendoors '= <Closed>elseskip;bellon '= nil)	pre (bellon <> nil)end Metro2, module Metro3exportsexport alldefinitionsstatic private Time = real	inv t == (t > 0)static private Interval = compose Interval of start'(unresolved Metro3`Time), stop'(unresolved Metro3`Time) end	inv mk_(unresolved Metro3`Interval)(s, e) == (s < e)static private LifeTime = seq of ((unresolved Metro3`Interval))	inv s == (forall i in set {1, ... ,((len s) - 1)} & ((s(i).stop) < (s((i + 1)).start)))static private System = compose System of train'(unresolved Metro3`LifeTime), doors'(unresolved Metro3`LifeTime), bell'(unresolved Metro3`LifeTime), closebut'(unresolved Metro3`LifeTime), closeassist'(unresolved Metro3`LifeTime) end	inv mk_(unresolved Metro3`System)(train, doors, bell, closebut, closeassist) == (NotMovingAndOpen(train, doors) and (BellOnWhenCloseBut(bell, closebut) and CloseAssistAfter3Secs(closeassist, bell)))NotMovingAndOpen' ((unresolved Metro3`LifeTime) * (unresolved Metro3`LifeTime) -> bool)	NotMovingAndOpen(train, doors) ==(forall i in set (inds train), j in set (inds doors) & (not OverlappingIntervals(train(i), doors(j))))CloseAssistAfter3Secs' ((unresolved Metro3`LifeTime) * (unresolved Metro3`LifeTime) -> bool)	CloseAssistAfter3Secs(closeassist, bell) ==(forall i in set (inds closeassist) & (exists [j in set (inds bell)] & (((bell(j).stop) >= ((bell(j).start) + 3)) and ((closeassist(i).start) = ((bell(j).start) + 3)))))BellOnWhenCloseBut' ((unresolved Metro3`LifeTime) * (unresolved Metro3`LifeTime) -> bool)	BellOnWhenCloseBut(bell, closebut) ==(forall i in set (inds bell) & (exists [j in set (inds closebut)] & SubInterval(bell(i), closebut(j))))OverlappingIntervals' ((unresolved Metro3`Interval) * (unresolved Metro3`Interval) -> bool)	OverlappingIntervals(int1, int2) ==(undefined)SubInterval' ((unresolved Metro3`Interval) * (unresolved Metro3`Interval) -> bool)	SubInterval(int1, int2) ==(undefined)end Metro3
