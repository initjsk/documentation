RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private BOM = map ((unresolved DEFAULT`Pn)) to (set of ((unresolved DEFAULT`Pn)))	inv bom == ((forall ps in set (rng bom) & (ps subset (dom bom))) and (forall p in set (dom bom) & (p not in set Parts(p, bom))))static private Pn = natstatic private bom = {1 |-> {2, 4}, 2 |-> {3, 4, 5}, 3 |-> {5, 6}, 4 |-> {6}, 5 |-> {4}, 6 |-> {}}static private cycle = {1 |-> {2, 4}, 2 |-> {3, 4, 5}, 3 |-> {5, 6}, 4 |-> {6}, 5 |-> {4}, 6 |-> {1}}Parts' ((unresolved DEFAULT`Pn) * map ((unresolved DEFAULT`Pn)) to (set of ((unresolved DEFAULT`Pn))) -> set of ((unresolved DEFAULT`Pn)))	Parts(p, bom) ==TransClos(bom, bom(p))	pre (p in set (dom bom))TransClos' ((map ((unresolved DEFAULT`Pn)) to (set of ((unresolved DEFAULT`Pn)))) * set of ((unresolved DEFAULT`Pn)) -> set of ((unresolved DEFAULT`Pn)))	TransClos(bom, ps) ==(if (forall p in set ps & (bom(p) subset ps))then pselse let newps = (dunion {bom(p) | [p in set ps]}) in TransClos(bom, (ps union newps)))	pre (ps subset (dom bom))IncrAcc' ((map ((unresolved DEFAULT`Pn)) to (set of ((unresolved DEFAULT`Pn)))) * set of ((unresolved DEFAULT`Pn)) -> nat)	IncrAcc(bom, pns) ==((card (dom bom)) - (card pns))Explode' ((unresolved DEFAULT`Pn) * (unresolved DEFAULT`BOM) -> set of ((unresolved DEFAULT`Pn)))	Explode(p, bom) ==(bom(p) union Exps(bom, bom(p)))	pre (p in set (dom bom))Exps' ((unresolved DEFAULT`BOM) * set of ((unresolved DEFAULT`Pn)) -> set of ((unresolved DEFAULT`Pn)))	Exps(bom, ps) ==(if (ps = {})then {}else let p1 in set ps in (Explode(p1, bom) union Exps(bom, (ps \ {p1}))))	pre (ps subset (dom bom))Enter' ((unresolved DEFAULT`BOM) * (unresolved DEFAULT`Pn) * set of ((unresolved DEFAULT`Pn)) -> (unresolved DEFAULT`BOM))	Enter(bom, p, ps) ==(bom munion {p |-> ps})	pre ((p not in set (dom bom)) and (ps subset (dom bom)))Delete' ((unresolved DEFAULT`Pn) * (unresolved DEFAULT`BOM) -> (unresolved DEFAULT`BOM))	Delete(p, bom) ==({p} <-' bom)	pre ((p in set (dom bom)) and inv_BOM(({p} <-' bom)))Add' ((unresolved DEFAULT`Pn) * (unresolved DEFAULT`Pn) * (unresolved DEFAULT`BOM) -> (unresolved DEFAULT`BOM))	Add(p1, p2, bom) ==(bom ++ {p1 |-> (bom(p1) union {p2})})	pre ((p1 in set (dom bom)) and ((p2 in set (dom bom)) and ((p2 not in set bom(p1)) and (p1 not in set Explode(p2, bom)))))Erase' ((unresolved DEFAULT`Pn) * (unresolved DEFAULT`Pn) * (unresolved DEFAULT`BOM) -> (unresolved DEFAULT`BOM))	Erase(p1, p2, bom) ==(bom ++ {p1 |-> (bom(p1) \ {p2})})	pre ((p1 in set (dom bom)) and ((p2 in set (dom bom)) and (p2 in set bom(p1))))end DEFAULT
