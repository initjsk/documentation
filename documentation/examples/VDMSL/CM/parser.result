RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private MissileInputs = seq of ((unresolved DEFAULT`MissileInput))static private MissileInput = ((unresolved DEFAULT`MissileType) * (unresolved DEFAULT`Angle))static private MissileType = (<MissileA> | <MissileB> | <MissileC> | <None>)static private Angle = nat	inv num == (num <= 360)static private Output = map ((unresolved DEFAULT`MagId)) to (seq of ((unresolved DEFAULT`OutputStep)))static private MagId = tokenstatic private OutputStep = ((unresolved DEFAULT`FlareType) * (unresolved DEFAULT`AbsTime))static private Response = ((unresolved DEFAULT`FlareType) * nat)static private AbsTime = natstatic private FlareType = (<DoNothingA> | <DoNothingB> | <DoNothingC> | <FlareOneA> | <FlareOneB> | <FlareOneC> | <FlareTwoA> | <FlareTwoB> | <FlareTwoC>)static private Plan = seq of ((((unresolved DEFAULT`FlareType) * (unresolved DEFAULT`Delay))))static private Delay = natstatic private responseDB'map ((unresolved DEFAULT`MissileType)) to ((unresolved DEFAULT`Plan)) = {<MissileA> |-> [mk_(<FlareOneA>, 900), mk_(<FlareTwoA>, 500), mk_(<DoNothingA>, 100), mk_(<FlareOneA>, 500)], <MissileB> |-> [mk_(<FlareTwoB>, 500), mk_(<FlareTwoB>, 700)], <MissileC> |-> [mk_(<FlareOneC>, 400), mk_(<DoNothingC>, 100), mk_(<FlareTwoC>, 400), mk_(<FlareOneC>, 500)]}static private missilePriority'map ((unresolved DEFAULT`MissileType)) to (nat) = {<MissileA> |-> 1, <MissileB> |-> 2, <MissileC> |-> 3, <None> |-> 0}static private stepLength'nat = 100static private testval1'(unresolved DEFAULT`MissileInputs) = [mk_(<MissileA>, 88), mk_(<MissileB>, 70), mk_(<MissileA>, 222), mk_(<MissileC>, 44)]static private testval2'(unresolved DEFAULT`MissileInputs) = [mk_(<MissileC>, 188), mk_(<MissileB>, 70), mk_(<MissileA>, 2), mk_(<MissileC>, 44)]static private testval3'(unresolved DEFAULT`MissileInputs) = [mk_(<MissileA>, 288), mk_(<MissileB>, 170), mk_(<MissileA>, 222), mk_(<MissileC>, 44)]CounterMeasures' ((unresolved DEFAULT`MissileInputs) -> (unresolved DEFAULT`Output))	CounterMeasures(missileInputs) ==CM(missileInputs, {}, {}, 0)CM' ((unresolved DEFAULT`MissileInputs) * (unresolved DEFAULT`Output) * map ((unresolved DEFAULT`MagId)) to ([(unresolved DEFAULT`MissileType)]) * nat -> (unresolved DEFAULT`Output))	CM(missileInputs, outputSoFar, lastMissile, curTime) ==(if (missileInputs = [])then outputSoFarelse let mk_(curMis, angle) = (hd missileInputs), magid = Angle2MagId(angle) in (if ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid)))))then let newOutput = InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in CM((tl missileInputs), newOutput, (lastMissile ++ {magid |-> curMis}), (curTime + stepLength))else CM((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))CMLen' ((unresolved DEFAULT`MissileInputs) * (unresolved DEFAULT`Output) * map ((unresolved DEFAULT`MagId)) to ([(unresolved DEFAULT`MissileType)]) * nat -> nat)	CMLen(list, -, -, -) ==(len list)InterruptPlan' (nat * (unresolved DEFAULT`Output) * (unresolved DEFAULT`Plan) * (unresolved DEFAULT`MagId) -> (unresolved DEFAULT`Output))	InterruptPlan(curTime, expOutput, plan, magid) ==({magid |-> ((if (magid in set (dom expOutput))then LeavePrefixUnchanged(expOutput(magid), curTime)else []) ^ MakeOutputFromPlan(curTime, plan))} munion ({magid} <-' expOutput))LeavePrefixUnchanged' (seq of ((unresolved DEFAULT`OutputStep)) * nat -> seq of ((unresolved DEFAULT`OutputStep)))	LeavePrefixUnchanged(output_l, curTime) ==[output_l(i) | i in set (inds output_l) & let mk_(-, t) = output_l(i) in (t <= curTime)]MakeOutputFromPlan' (nat * seq of ((unresolved DEFAULT`Response)) -> seq of ((unresolved DEFAULT`OutputStep)))	MakeOutputFromPlan(curTime, response) ==let output = OutputAtTimeZero(response) in [let mk_(flare, t) = output(i) in mk_(flare, (t + curTime)) | i in set (inds output)]OutputAtTimeZero' (seq of ((unresolved DEFAULT`Response)) -> seq of ((unresolved DEFAULT`OutputStep)))	OutputAtTimeZero(response) ==let absTimes = RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -) = (hd absTimes) in ([mk_(firstFlare, 0)] ^ [let mk_(-, t) = absTimes((i - 1)), mk_(f, -) = absTimes(i) in mk_(f, t) | i in set {2, ... ,(len absTimes)}])RelativeToAbsoluteTimes' (seq of ((unresolved DEFAULT`Response)) -> seq of ((((unresolved DEFAULT`FlareType) * nat))))	RelativeToAbsoluteTimes(ts) ==(if (ts = [])then []else let mk_(f, t) = (hd ts), ns = RelativeToAbsoluteTimes((tl ts)) in ([mk_(f, t)] ^ [let mk_(nf, nt) = ns(i) in mk_(nf, (nt + t)) | i in set (inds ns)]))RespLen' (seq of ((unresolved DEFAULT`Response)) -> nat)	RespLen(l) ==(len l)Angle2MagId' ((unresolved DEFAULT`Angle) -> (unresolved DEFAULT`MagId))	Angle2MagId(angle) ==(if (angle < 90)then mk_token("Magazine 1")elseif (angle < 180)then mk_token("Magazine 2")elseif (angle < 270)then mk_token("Magazine 3")else mk_token("Magazine 4"))end DEFAULT
