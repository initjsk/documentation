RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private MissileInputs = seq of (MissileInput)static private MissileInput = (MissileType * Angle)static private MissileType = (<MissileA> | <MissileB> | <MissileC> | <None>)static private Angle = nat	inv num == (num <= 360)static private Output = map (MagId) to (seq of (OutputStep))static private MagId = tokenstatic private OutputStep = (FlareType * AbsTime)static private Response = (FlareType * nat)static private AbsTime = natstatic private FlareType = (<DoNothingA> | <DoNothingB> | <DoNothingC> | <FlareOneA> | <FlareOneB> | <FlareOneC> | <FlareTwoA> | <FlareTwoB> | <FlareTwoC>)static private Plan = seq of ((FlareType * Delay))static private Delay = natstatic private responseDB'map (MissileType) to (Plan) = {<MissileA> |-> [mk_(<FlareOneA>, 900), mk_(<FlareTwoA>, 500), mk_(<DoNothingA>, 100), mk_(<FlareOneA>, 500)], <MissileB> |-> [mk_(<FlareTwoB>, 500), mk_(<FlareTwoB>, 700)], <MissileC> |-> [mk_(<FlareOneC>, 400), mk_(<DoNothingC>, 100), mk_(<FlareTwoC>, 400), mk_(<FlareOneC>, 500)]}static private missilePriority'map (MissileType) to (nat) = {<MissileA> |-> 1, <MissileB> |-> 2, <MissileC> |-> 3, <None> |-> 0}static private stepLength'nat = 100static private testval1'MissileInputs = [mk_(<MissileA>, 88), mk_(<MissileB>, 70), mk_(<MissileA>, 222), mk_(<MissileC>, 44)]static private testval2'MissileInputs = [mk_(<MissileC>, 188), mk_(<MissileB>, 70), mk_(<MissileA>, 2), mk_(<MissileC>, 44)]static private testval3'MissileInputs = [mk_(<MissileA>, 288), mk_(<MissileB>, 170), mk_(<MissileA>, 222), mk_(<MissileC>, 44)]CounterMeasures' (MissileInputs -> Output)	CounterMeasures(missileInputs) ==CM(missileInputs, {}, {}, 0)CM' (MissileInputs * Output * map (MagId) to ([MissileType]) * nat -> Output)	CM(missileInputs, outputSoFar, lastMissile, curTime) ==(if (missileInputs = [])then outputSoFarelse let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in (if ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid)))))then let newOutput'Output = InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in CM((tl missileInputs), newOutput, (lastMissile ++ {magid |-> curMis}), (curTime + stepLength))else CM((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))CMLen' (MissileInputs * Output * map (MagId) to ([MissileType]) * nat -> nat)	CMLen(list, -, -, -) ==(len list)InterruptPlan' (nat * Output * Plan * MagId -> Output)	InterruptPlan(curTime, expOutput, plan, magid) ==({magid |-> ((if (magid in set (dom expOutput))then LeavePrefixUnchanged(expOutput(magid), curTime)else []) ^ MakeOutputFromPlan(curTime, plan))} munion ({magid} <-' expOutput))LeavePrefixUnchanged' (seq of (OutputStep) * nat -> seq of (OutputStep))	LeavePrefixUnchanged(output_l, curTime) ==[output_l(i) | i in set (inds output_l) & let mk_(-, t)'OutputStep = output_l(i) in (t <= curTime)]MakeOutputFromPlan' (nat * seq of (Response) -> seq of (OutputStep))	MakeOutputFromPlan(curTime, response) ==let output'seq of (OutputStep) = OutputAtTimeZero(response) in [let mk_(flare, t)'OutputStep = output(i) in mk_(flare, (t + curTime)) | i in set (inds output)]OutputAtTimeZero' (seq of (Response) -> seq of (OutputStep))	OutputAtTimeZero(response) ==let absTimes'seq of ((FlareType * nat)) = RelativeToAbsoluteTimes(response) in let mk_(firstFlare, -)'(FlareType * nat) = (hd absTimes) in ([mk_(firstFlare, 0)] ^ [let mk_(-, t)'(FlareType * nat) = absTimes((i - 1)), mk_(f, -)'(FlareType * nat) = absTimes(i) in mk_(f, t) | i in set {2, ... ,(len absTimes)}])RelativeToAbsoluteTimes' (seq of (Response) -> seq of ((FlareType * nat)))	RelativeToAbsoluteTimes(ts) ==(if (ts = [])then []else let mk_(f, t)'Response = (hd ts), ns'seq of ((FlareType * nat)) = RelativeToAbsoluteTimes((tl ts)) in ([mk_(f, t)] ^ [let mk_(nf, nt)'(FlareType * nat) = ns(i) in mk_(nf, (nt + t)) | i in set (inds ns)]))RespLen' (seq of (Response) -> nat)	RespLen(l) ==(len l)Angle2MagId' (Angle -> MagId)	Angle2MagId(angle) ==(if (angle < 90)then mk_token("Magazine 1")elseif (angle < 180)then mk_token("Magazine 2")elseif (angle < 270)then mk_token("Magazine 3")else mk_token("Magazine 4"))end DEFAULT
