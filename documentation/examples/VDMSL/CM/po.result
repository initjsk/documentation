RESULT:result:-1:-1,-1:Proof Obligation 1' (Unproved)responseDB' map sequence compatible obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 34'5forall m1, m2 in set {{<MissileA> |-> [mk_(<FlareOneA>, 900), mk_(<FlareTwoA>, 500), mk_(<DoNothingA>, 100), mk_(<FlareOneA>, 500)]}, {<MissileB> |-> [mk_(<FlareTwoB>, 500), mk_(<FlareTwoB>, 700)]}, {<MissileC> |-> [mk_(<FlareOneC>, 400), mk_(<DoNothingC>, 100), mk_(<FlareTwoC>, 400), mk_(<FlareOneC>, 500)]}} &  forall d3 in set dom m1, d4 in set dom m2 &    d3 = d4 => m1(d3) = m2(d4)Proof Obligation 2' (Unproved)missilePriority' map sequence compatible obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 42'25forall m1, m2 in set {{<MissileA> |-> 1}, {<MissileB> |-> 2}, {<MissileC> |-> 3}, {<None> |-> 0}} &  forall d3 in set dom m1, d4 in set dom m2 &    d3 = d4 => m1(d3) = m2(d4)Proof Obligation 3' (Unproved)testval1' subtype obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 49'30((((inv_Angle(88) and (is_nat(88)))))and (((inv_Angle(70) and (is_nat(70)))))and (((inv_Angle(222) and (is_nat(222)))))and (((inv_Angle(44) and (is_nat(44))))))Proof Obligation 4' (Unproved)testval2' subtype obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 54'30((((inv_Angle(188) and (is_nat(188)))))and (((inv_Angle(70) and (is_nat(70)))))and (((inv_Angle(2) and (is_nat(2)))))and (((inv_Angle(44) and (is_nat(44))))))Proof Obligation 5' (Unproved)testval3' subtype obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 59'30((((inv_Angle(288) and (is_nat(288)))))and (((inv_Angle(170) and (is_nat(170)))))and (((inv_Angle(222) and (is_nat(222)))))and (((inv_Angle(44) and (is_nat(44))))))Proof Obligation 6' (Trivial by <not x = y => x <> y>)CM, curMis, angle' non-empty sequence obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 75'35(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    missileInputs <> []))Proof Obligation 7' (Unproved)CM' map apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 80'14(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (not (magid not in set (dom lastMissile)) =>        ((magid in set (dom lastMissile)) =>          curMis in set dom missilePriority)))))Proof Obligation 8' (Unproved)CM' map apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 81'14(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (not (magid not in set (dom lastMissile)) =>        ((magid in set (dom lastMissile)) =>          lastMissile(magid) in set dom missilePriority)))))Proof Obligation 9' (Unproved)CM' subtype obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 81'30(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (not (magid not in set (dom lastMissile)) =>        ((magid in set (dom lastMissile)) =>          ((is_(lastMissile(magid), <MissileA>)) or          (is_(lastMissile(magid), <MissileB>)) or          (is_(lastMissile(magid), <MissileC>)) or          (is_(lastMissile(magid), <None>))))))))Proof Obligation 10' (Unproved)CM' map apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 81'30(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (not (magid not in set (dom lastMissile)) =>        ((magid in set (dom lastMissile)) =>          magid in set dom lastMissile)))))Proof Obligation 11' (Unproved)CM, newOutput' map apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 84'36(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid))))) =>        curMis in set dom responseDB))))Proof Obligation 12' (Unproved)CM' recursive function obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 70'1(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid))))) =>        (let newOutput'Output = InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in          CMLen(missileInputs, outputSoFar, lastMissile, curTime) > CMLen((tl missileInputs), newOutput, (lastMissile ++ {magid |-> curMis}), (curTime + stepLength)))))))Proof Obligation 13' (Unproved)CM' non-empty sequence obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 86'24(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid))))) =>        (let newOutput'Output = InterruptPlan(curTime, outputSoFar, responseDB(curMis), magid) in          missileInputs <> [])))))Proof Obligation 14' (Unproved)CM' recursive function obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 70'1(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid))))) =>        CMLen(missileInputs, outputSoFar, lastMissile, curTime) > CMLen((tl missileInputs), outputSoFar, lastMissile, (curTime + stepLength))))))Proof Obligation 15' (Unproved)CM' non-empty sequence obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 89'21(forall missileInputs'MissileInputs, outputSoFar'Output, lastMissile'map (MagId) to ([MissileType]), curTime'nat &  (not (missileInputs = []) =>    (let mk_(curMis, angle)'MissileInput = (hd missileInputs), magid'MagId = Angle2MagId(angle) in      (not ((magid not in set (dom lastMissile)) or ((magid in set (dom lastMissile)) and (missilePriority(curMis) > missilePriority(lastMissile(magid))))) =>        missileInputs <> []))))Proof Obligation 16' (Trivial by <x in set s => x in set s>)InterruptPlan' map apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 99'41(forall curTime'nat, expOutput'Output, plan'Plan, magid'MagId &  ((magid in set (dom expOutput)) =>    magid in set dom expOutput))Proof Obligation 17' (Unproved)InterruptPlan' map compatible obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 98'3(forall curTime'nat, expOutput'Output, plan'Plan, magid'MagId &  forall ldom1 in set dom {magid |-> ((if (magid in set (dom expOutput))  then LeavePrefixUnchanged(expOutput(magid), curTime)  else []) ^ MakeOutputFromPlan(curTime, plan))}, rdom2 in set dom ({magid} <-' expOutput) &  ldom1 = rdom2 => {magid |-> ((if (magid in set (dom expOutput))  then LeavePrefixUnchanged(expOutput(magid), curTime)  else []) ^ MakeOutputFromPlan(curTime, plan))}(ldom1) = ({magid} <-' expOutput)(rdom2))Proof Obligation 18' (Trivial by <forall x in set s & x in set s>)LeavePrefixUnchanged' sequence apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 109'4(forall output_l'seq of (OutputStep), curTime'nat &  (forall i in set (inds output_l) & let mk_(-, t)'OutputStep = output_l(i) in (t <= curTime) =>    i in set inds output_l))Proof Obligation 19' (Trivial by <forall x in set s & x in set s>)LeavePrefixUnchanged, t' sequence apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 110'33(forall output_l'seq of (OutputStep), curTime'nat &  (forall i in set (inds output_l) &    i in set inds output_l))Proof Obligation 20' (Trivial by <forall x in set s & x in set s>)MakeOutputFromPlan, flare, t' sequence apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 115'25(forall curTime'nat, response'seq of (Response) &  (let output'seq of (OutputStep) = OutputAtTimeZero(response) in    (forall i in set (inds output) &      i in set inds output)))Proof Obligation 21' (Unproved)OutputAtTimeZero, firstFlare' non-empty sequence obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 123'32(forall response'seq of (Response) &  (let absTimes'seq of ((FlareType * nat)) = RelativeToAbsoluteTimes(response) in    absTimes <> []))Proof Obligation 22' (Unproved)OutputAtTimeZero, t' sequence apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 125'24(forall response'seq of (Response) &  (let absTimes'seq of ((FlareType * nat)) = RelativeToAbsoluteTimes(response) in    (let mk_(firstFlare, -)'(FlareType * nat) = (hd absTimes) in      (forall i in set {2, ... ,(len absTimes)} &        (i - 1) in set inds absTimes))))Proof Obligation 23' (Unproved)OutputAtTimeZero, f' sequence apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 126'24(forall response'seq of (Response) &  (let absTimes'seq of ((FlareType * nat)) = RelativeToAbsoluteTimes(response) in    (let mk_(firstFlare, -)'(FlareType * nat) = (hd absTimes) in      (forall i in set {2, ... ,(len absTimes)} &        i in set inds absTimes))))Proof Obligation 24' (Trivial by <not x = y => x <> y>)RelativeToAbsoluteTimes, f, t' non-empty sequence obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 134'26(forall ts'seq of (Response) &  (not (ts = []) =>    ts <> []))Proof Obligation 25' (Unproved)RelativeToAbsoluteTimes, ns' recursive function obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 129'1(forall ts'seq of (Response) &  (not (ts = []) =>    RespLen(ts) > RespLen((tl ts))))Proof Obligation 26' (Trivial by <not x = y => x <> y>)RelativeToAbsoluteTimes, ns' non-empty sequence obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 135'44(forall ts'seq of (Response) &  (not (ts = []) =>    ts <> []))Proof Obligation 27' (Unproved)RelativeToAbsoluteTimes, nf, nt' sequence apply obligation in 'DEFAULT' (../../documentation/examples/VDMSL/CM/CMflat.vdmsl) at line 136'43(forall ts'seq of (Response) &  (not (ts = []) =>    (let mk_(f, t)'Response = (hd ts), ns'seq of ((FlareType * nat)) = RelativeToAbsoluteTimes((tl ts)) in      (forall i in set (inds ns) &        i in set inds ns))))
