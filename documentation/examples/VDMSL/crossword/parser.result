RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private size'nat = 8static private letters'set of (char) = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'}static private black'char = '*'static private white'char = '_'static private word = seq of (char)	inv w == (((elems w) subset letters) and ((len w) >= 2))static private pos = nat1	inv pos_v == (pos_v <= size)static private position = compose position of h'(unresolved DEFAULT`pos), v'(unresolved DEFAULT`pos) endstatic private grid = map ((unresolved DEFAULT`position)) to (char)	inv gr == (((rng gr) subset (letters union {white, black})) and ((dom gr) = {mk_position(i, j) | [i in set {1, ... ,size}, j in set {1, ... ,size}]}))static private HV = (<H> | <V>)state crosswordsof[cwgrid'(unresolved DEFAULT`grid), valid_words'set of ((unresolved DEFAULT`word)), waiting_words'set of ((unresolved DEFAULT`word))]	inv mk_(unresolved DEFAULT`crosswords)(gr, val, wait) == CW_INVARIANT(gr, val, wait)	init mk_(unresolved DEFAULT`crosswords)(gr, val, wait) == ((val = {}) and ((wait = {}) and (forall i in set {1, ... ,size} & (forall j in set {1, ... ,size} & (gr(mk_position(i, j)) = white)))))CW_INVARIANT' ((unresolved DEFAULT`grid) * set of ((unresolved DEFAULT`word)) * set of ((unresolved DEFAULT`word)) +> bool)	CW_INVARIANT(gr, val, wait) ==(((val inter wait) = {}) and ((WORDS(gr) subset (val union wait)) and (wait subset WORDS(gr))))WORDS' ((unresolved DEFAULT`grid) +> set of ((unresolved DEFAULT`word)))	WORDS(g) ==(HOR_WORDS(g) union VER_WORDS(g))HOR_WORDS' ((unresolved DEFAULT`grid) +> set of ((unresolved DEFAULT`word)))	HOR_WORDS(g) ==(dunion {WORDS_OF_SEQ(LINE(i, g)) | [i in set {1, ... ,size}]})VER_WORDS' ((unresolved DEFAULT`grid) +> set of ((unresolved DEFAULT`word)))	VER_WORDS(g) ==(dunion {WORDS_OF_SEQ(COL(i, g)) | [i in set {1, ... ,size}]})LINE' ((unresolved DEFAULT`pos) * (unresolved DEFAULT`grid) +> seq of (char))	LINE(i, g) ==[g(mk_position(i, c)) | c in set {1, ... ,size}]COL' ((unresolved DEFAULT`pos) * (unresolved DEFAULT`grid) +> seq of (char))	COL(i, g) ==[g(mk_position(l, i)) | l in set {1, ... ,size}]WORDS_OF_SEQ' (seq of (char) +> set of ((unresolved DEFAULT`word)))	WORDS_OF_SEQ(s) =={w | [w'(unresolved DEFAULT`word)] & (exists [s1, s2'seq of (char)] & ((s = ((s1 ^ w) ^ s2)) and (((s1 = []) or ((s1((len s1)) = black) or (s1((len s1)) = white))) and ((s2 = []) or ((s2(1) = black) or (s2(1) = white))))))}COMPATIBLE' ((unresolved DEFAULT`grid) * (unresolved DEFAULT`word) * (unresolved DEFAULT`position) * (unresolved DEFAULT`HV) +> bool)	COMPATIBLE(g, w, p, d) ==(((d = <H>) => (((((p.h) + (len w)) - 1) <= size) and (forall i in set (inds w) & ((g(mk_position((((p.h) + i) - 1), (p.v))) = white) or (g(mk_position((((p.h) + i) - 1), (p.v))) = w(i)))))) and ((d = <V>) => (((((p.v) + (len w)) - 1) <= size) and (forall i in set (inds w) & ((g(mk_position((p.h), (((p.v) + i) - 1))) = white) or (g(mk_position((p.h), (((p.v) + i) - 1))) = w(i)))))))IS_LOCATED' ((unresolved DEFAULT`grid) * (unresolved DEFAULT`word) * (unresolved DEFAULT`position) * (unresolved DEFAULT`HV) +> bool)	IS_LOCATED(g, w, p, d) ==(((d = <H>) => (forall i in set (inds w) & (g(mk_position((((p.h) + i) - 1), (p.v))) = w(i)))) and ((d = <V>) => (forall i in set (inds w) & (g(mk_position((p.h), (((p.v) + i) - 1))) = w(i)))))IN_WORD' ((unresolved DEFAULT`grid) * (unresolved DEFAULT`position) * (unresolved DEFAULT`HV) +> bool)	IN_WORD(g, p, d) ==(((d = <H>) => (exists [i, j'(unresolved DEFAULT`pos)] & ((i <= (p.h)) and ((j >= (p.h)) and ((i < j) and (forall k in set {i, ... ,j} & (g(mk_position(k, (p.v))) in set letters))))))) and ((d = <V>) => (exists [i, j'(unresolved DEFAULT`pos)] & ((i <= (p.v)) and ((j >= (p.v)) and ((i < j) and (forall k in set {i, ... ,j} & (g(mk_position((p.h), k)) in set letters))))))))VALIDATE_WORD((w'(unresolved DEFAULT`word)))	ext [wr valid_words'set of ((unresolved DEFAULT`word)), wr waiting_words'set of ((unresolved DEFAULT`word))]	pre (w in set waiting_words)	post ((valid_words = (valid_words~ union {w})) and (waiting_words = (waiting_words~ \ {w})))ADD_WORD((w'(unresolved DEFAULT`word)), (p'(unresolved DEFAULT`position)), (d'(unresolved DEFAULT`HV)))	ext [wr cwgrid'(unresolved DEFAULT`grid), rd valid_words'set of ((unresolved DEFAULT`word)), wr waiting_words'set of ((unresolved DEFAULT`word))]	pre COMPATIBLE(cwgrid, w, p, d)	post (((d = <H>) => (cwgrid = (cwgrid~ ++ {mk_position((((p.h) + i) - 1), (p.v)) |-> w(i) | i in set (inds w)}))) and (((d = <V>) => (cwgrid = (cwgrid~ ++ {mk_position((p.h), (((p.v) + i) - 1)) |-> w(i) | i in set (inds w)}))) and CW_INVARIANT(cwgrid, valid_words, waiting_words)))ADD_BLACK((p'(unresolved DEFAULT`position)))	ext [wr cwgrid'(unresolved DEFAULT`grid)]	pre (cwgrid(p) = white)	post (cwgrid = (cwgrid~ ++ {p |-> black}))DELETE_BLACK((p'(unresolved DEFAULT`position)))	ext [wr cwgrid'(unresolved DEFAULT`grid)]	pre (cwgrid(p) = black)	post (cwgrid = (cwgrid~ ++ {p |-> white}))STRONG_DELETE((w'(unresolved DEFAULT`word)), (p'(unresolved DEFAULT`position)), (d'(unresolved DEFAULT`HV)))	ext [wr cwgrid'(unresolved DEFAULT`grid), rd valid_words'set of ((unresolved DEFAULT`word)), wr waiting_words'set of ((unresolved DEFAULT`word))]	pre IS_LOCATED(cwgrid, w, p, d)	post (((d = <H>) => (cwgrid = (cwgrid~ ++ {mk_position((((p.h) + i) - 1), (p.v)) |-> white | i in set (inds w)}))) and (((d = <V>) => (cwgrid = (cwgrid~ ++ {mk_position((p.h), (((p.v) + i) - 1)) |-> white | i in set (inds w)}))) and CW_INVARIANT(cwgrid, valid_words, waiting_words)))SOFT_DELETE((w'(unresolved DEFAULT`word)), (p'(unresolved DEFAULT`position)), (d'(unresolved DEFAULT`HV)))	ext [wr cwgrid'(unresolved DEFAULT`grid), rd valid_words'set of ((unresolved DEFAULT`word)), wr waiting_words'set of ((unresolved DEFAULT`word))]	pre IS_LOCATED(cwgrid, w, p, d)	post (((d = <H>) => (cwgrid = (cwgrid~ ++ {mk_position((((p.h) + i) - 1), (p.v)) |-> white | i in set (inds w) & (not IN_WORD(cwgrid~, mk_position((((p.h) + i) - 1), (p.v)), <V>))}))) and (((d = <V>) => (cwgrid = (cwgrid~ ++ {mk_position((p.h), (((p.v) + i) - 1)) |-> white | i in set (inds w) & (not IN_WORD(cwgrid~, mk_position((p.h), (((p.v) + i) - 1)), <H>))}))) and CW_INVARIANT(cwgrid, valid_words, waiting_words)))end DEFAULT
