RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Key = tokenstatic private Room = tokenstatic private Guest = tokenstatic private Card = compose Card of fst'(unresolved DEFAULT`Key), snd'(unresolved DEFAULT`Key) endstatic private Desk = compose Desk of issued'set of ((unresolved DEFAULT`Key)), prev'map ((unresolved DEFAULT`Room)) to ((unresolved DEFAULT`Key)) end	inv d == ((rng (d.prev)) subset (d.issued))state Hotelof[desk'(unresolved DEFAULT`Desk), locks'map ((unresolved DEFAULT`Room)) to ((unresolved DEFAULT`Key)), guests'map ((unresolved DEFAULT`Guest)) to (set of ((unresolved DEFAULT`Card)))]	inv h == (((dom ((h.desk).prev)) subset (dom (h.locks))) and ((dunion {{(c.fst), (c.snd)} | [c in set (dunion (rng (h.guests)))]}) subset ((h.desk).issued)))	init h == ((((h.desk).issued) = {}) and ((((h.desk).prev) = (h.locks)) and ((rng (h.guests)) = {{}})))CheckIn((g'(unresolved DEFAULT`Guest)), (r'(unresolved DEFAULT`Room)))	ext [wr desk'(unresolved DEFAULT`Desk), wr guests'map ((unresolved DEFAULT`Guest)) to (set of ((unresolved DEFAULT`Card)))]	pre (r in set (dom (desk.prev)))	post (exists [new_k'(unresolved DEFAULT`Key)] & ((new_k not in set (desk~.issued)) and let new_c = mk_Card((desk~.prev)(r), new_k) in (((desk.issued) = ((desk~.issued) union {new_k})) and (((desk.prev) = ((desk~.prev) ++ {r |-> new_k})) and (if (g in set (dom guests~))then (guests = (guests~ ++ {g |-> (guests~(g) union {new_c})}))else (guests = (guests~ munion {g |-> {new_c}})))))))Enter((r'(unresolved DEFAULT`Room)), (g'(unresolved DEFAULT`Guest)))	ext [wr locks'map ((unresolved DEFAULT`Room)) to ((unresolved DEFAULT`Key)), rd guests'map ((unresolved DEFAULT`Guest)) to (set of ((unresolved DEFAULT`Card)))]	pre ((r in set (dom locks)) and ((g in set (dom guests)) and (exists [c in set guests(g)] & (((c.fst) = locks(r)) or ((c.snd) = locks(r))))))	post (exists [c in set guests(g)] & ((((c.fst) = locks(r)) and (locks = (locks~ ++ {r |-> (c.snd)}))) or (((c.snd) = locks(r)) and (locks = locks~))))CheckInExpl ((unresolved DEFAULT`Guest) * (unresolved DEFAULT`Room) ==> ())	CheckInExpl(g, r) ==let new_k'(unresolved DEFAULT`Key) be st (new_k not in set (desk.issued)) in let private value new_c'? in (desk.issued '= ((desk.issued) union {new_k});desk.prev '= ((desk.prev) ++ {r |-> new_k});guests '= (if (g in set (dom guests))then (guests ++ {g |-> (guests(g) union {new_c})})else (guests munion {g |-> {new_c}})))	pre (r in set (dom (desk.prev)))EnterExpl ((unresolved DEFAULT`Room) * (unresolved DEFAULT`Guest) ==> ())	EnterExpl(r, g) ==let c in set guests(g) be st (((c.fst) = locks(r)) or ((c.snd) = locks(r))) in if ((c.fst) = locks(r))thenlocks '= (locks ++ {r |-> (c.snd)})	pre ((r in set (dom locks)) and ((g in set (dom guests)) and (exists [c in set guests(g)] & (((c.fst) = locks(r)) or ((c.snd) = locks(r))))))IssueCard (() ==> (unresolved DEFAULT`Key))	IssueCard() ==let k'(unresolved DEFAULT`Key) be st (k not in set (desk.issued)) in (desk.issued '= ((desk.issued) union {k});return (k))AddRoom ((unresolved DEFAULT`Room) * (unresolved DEFAULT`Key) ==> ())	AddRoom(r, k) ==(desk.prev '= ((desk.prev) munion {r |-> k});locks '= (locks munion {r |-> k}))	pre ((k in set (desk.issued)) and (r not in set (dom locks)))AddGuest ((unresolved DEFAULT`Guest) * set of ((unresolved DEFAULT`Card)) ==> ())	AddGuest(g, cs) ==guests '= (guests ++ {g |-> (if (g in set (dom guests))then (guests(g) union cs)else cs)})	pre (forall c in set cs & ({(c.fst), (c.snd)} subset (desk.issued)))end DEFAULT
