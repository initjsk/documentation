WARNING:env.vdmsl:5008:152,24:pat in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 180'2 hidden by pat.
WARNING:auxil.vdmsl:5012:48,11:Recursive function has no measure.
WARNING:expr.vdmsl:5008:47,41:expr in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 183'2 hidden by expr.
WARNING:auxil.vdmsl:5012:79,13:Recursive function has no measure.
WARNING:expr.vdmsl:5008:39,48:expr in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 183'2 hidden by expr.
WARNING:env.vdmsl:5012:276,7:Recursive function has no measure.
WARNING:auxil.vdmsl:5008:80,17:pat in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 180'2 hidden by pat.
WARNING:expr.vdmsl:5008:256,16:pat in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 180'2 hidden by pat.
WARNING:env.vdmsl:5008:152,29:expr in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 183'2 hidden by expr.
WARNING:expr.vdmsl:5008:47,36:pat in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 180'2 hidden by pat.
WARNING:expr.vdmsl:5008:143,29:pat in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 180'2 hidden by pat.
WARNING:pat.vdmsl:5000:19,39:Definition 'm' not used.
WARNING:expr.vdmsl:5008:22,21:expr in 'DEFAULT' (..\..\documentation\examples\VDMSL\loose\as.vdmsl) at line 183'2 hidden by expr.
WARNING:auxil.vdmsl:5012:62,10:Recursive function has no measure.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Definitions = compose Definitions of valuem'seq of (ValueDef), fnm'map (Name) to (ExplFnDef) endstatic private ValueDef = compose ValueDef of pat'Pattern, val'Expr endstatic private ExplFnDef = compose ExplFnDef of nm'Name, pat'Pattern, body'Expr endstatic private Expr = (ApplyExpr | BinaryExpr | BracketedExpr | CasesExpr | IfExpr | LetBeSTExpr | LetExpr | Literal | Name | SetEnumerationExpr | UnaryExpr)static private BracketedExpr = compose BracketedExpr of expr'Expr endstatic private LetExpr = compose LetExpr of lhs'Pattern, rhs'Expr, body'Expr endstatic private LetBeSTExpr = compose LetBeSTExpr of lhs'Bind, St'Expr, In'Expr endstatic private IfExpr = compose IfExpr of test'Expr, cons'Expr, altn'Expr endstatic private CasesExpr = compose CasesExpr of sel'Expr, altns'seq of (CaseAltn), Others'[Expr] endstatic private CaseAltn = compose CaseAltn of match'Pattern, body'Expr endstatic private UnaryExpr = compose UnaryExpr of opr'UnaryOp, arg'Expr endstatic private UnaryOp = <NUMMINUS>static private BinaryExpr = compose BinaryExpr of left'Expr, opr'BinaryOp, right'Expr endstatic private BinaryOp = (<EQ> | <NUMMINUS> | <NUMMULT> | <NUMPLUS> | <SETMINUS>)static private SetEnumerationExpr = compose SetEnumerationExpr of els'seq of (Expr) endstatic private ApplyExpr = compose ApplyExpr of fct'Name, arg'Expr endstatic private Name = compose Name of ids'seq of (Id) endstatic private Id = seq of (char)static private Pattern = (MatchVal | PatternName | SetPattern)static private PatternName = compose PatternName of nm'[(Name * Position)] endstatic private MatchVal = compose MatchVal of val'Expr endstatic private SetPattern = (SetEnumPattern | SetUnionPattern)static private SetEnumPattern = compose SetEnumPattern of Elems'seq of (Pattern) endstatic private SetUnionPattern = compose SetUnionPattern of lp'Pattern, rp'Pattern endstatic private Position = (nat * nat)static private Bind = SetBindstatic private SetBind = compose SetBind of pat'Pattern, Set'Expr endstatic private Literal = (BoolLit | NumLit)static private BoolLit = compose BoolLit of val'bool endstatic private NumLit = compose NumLit of val'int endstatic private pat'Pattern = mk_PatternName(mk_(mk_Name(["x"]), mk_(1, 1)))static private sexpr'Expr = mk_SetEnumerationExpr([mk_NumLit(1), mk_NumLit(2)])static private expr'Expr = mk_LetBeSTExpr(mk_SetBind(pat, sexpr), mk_BoolLit(true), mk_Name(["x"]))static private expr2'Expr = mk_BinaryExpr(expr, <NUMPLUS>, expr)static private ENVL = seq of (ENV)static private ENV = seq of (BlkEnv)static private BlkEnv = seq of (NameVal)static private NameVal = (UniqueId * VAL)static private UniqueId = (Name * Position * [(Name * VAL)])static private LVAL = set of ((VAL * Model))static private Model = map (UniqueId) to (VAL)static private VAL = (BOOL | NUM | SET)static private NUM = compose NUM of v'int endstatic private BOOL = compose BOOL of v'bool endstatic private SET = compose SET of v'set of (VAL) endstate Sigmaof[env_l'ENVL, val_m'map (UniqueId) to (LVAL), fn_m'map (Name) to ((Pattern * Expr)), curfn'seq of ((Name * VAL)), fnparms'set of (UniqueId)]	init s == (s = mk_Sigma([[]], {}, {}, [], {}))CreateContext (Definitions ==> ())	CreateContext(mk_Definitions(valuem, fnm)) ==(InstallValueDefs(valuem);InstallFnDefs(fnm))InstallValueDefs (seq of (ValueDef) ==> ())	InstallValueDefs(val_l) ==for mk_ValueDef(pat, expr) in val_l dolet private value lval'LVAL in for all mk_(val, model) in set lval dolet private value env_s'set of (BlkEnv) in val_m '= Extend(val_m, {id |-> {mk_(Look(env, id), model) | [env in set env_s]} | id in set (dinter {SelDom(env) | [env in set env_s]})})InstallFnDefs (map (Name) to (ExplFnDef) ==> ())	InstallFnDefs(fn_marg) ==fn_m '= {nm |-> mk_((fn_marg(nm).pat), (fn_marg(nm).body)) | nm in set (dom fn_marg)}InstallCurFn (Name * VAL * set of (UniqueId) ==> ())	InstallCurFn(nm, val, patids) ==(curfn '= ([mk_(nm, val)] ^ curfn);fnparms '= (fnparms union patids))LeaveCurFn (() ==> ())	LeaveCurFn() ==curfn '= (tl curfn)	pre (curfn <> [])PopEnvL (() ==> ())	PopEnvL() ==env_l '= (tl env_l)TopEnvL (() ==> ENV)	TopEnvL() ==return ((hd env_l))PushEmptyEnv (() ==> ())	PushEmptyEnv() ==env_l '= ([[]] ^ env_l)PopBlkEnv (() ==> ())	PopBlkEnv() ==env_l '= ([(tl (hd env_l))] ^ (tl env_l))PushBlkEnv (BlkEnv ==> ())	PushBlkEnv(benv) ==env_l '= ([([benv] ^ (hd env_l))] ^ (tl env_l))MkEmptyBlkEnv (() ==> BlkEnv)	MkEmptyBlkEnv() ==return ([])CombineBlkEnv (BlkEnv * BlkEnv ==> BlkEnv)	CombineBlkEnv(env1, env2) ==return ((env1 ^ env2))MkBlkEnv ((Name * Position) * VAL ==> BlkEnv)	MkBlkEnv(mk_(nm, pos), val_v) ==let private value fninfo'[(Name * VAL)] in return ([mk_(mk_(nm, pos, fninfo), val_v)])FnInfo (() ==> [(Name * VAL)])	FnInfo() ==if ((len curfn) = 0)thenreturn (nil)elsereturn ((hd curfn))LooseLookUp (Name ==> LVAL)	LooseLookUp(nm) ==(let private value topenv'ENV in for env in topenv dofor mk_(id, val) in env doif (SelName(id) = nm)thenreturn ({mk_(val, (if (id in set fnparms)then {}else {id |-> val}))})elseskip;LookUpValueDefs(nm))LookUpValueDefs (Name ==> LVAL)	LookUpValueDefs(nm) ==(for all id in set (dom val_m) doif (SelName(id) = nm)thenreturn ({mk_(v, (m munion {id |-> v})) | [mk_(v, m) in set val_m(id)]});error)LookUpFn (Name ==> (Pattern * Expr))	LookUpFn(nm) ==return (fn_m(nm))	pre (nm in set (dom fn_m))SelName' (UniqueId +> Name)	SelName(mk_(nm, -, -)) ==nmSelNameAndPos' (UniqueId +> (Name * Position))	SelNameAndPos(mk_(nm, pos, -)) ==mk_(nm, pos)SelDom' (BlkEnv +> set of (UniqueId))	SelDom(blkenv) =={id | [mk_(id, -) in set (elems blkenv)]}Look' (BlkEnv * UniqueId +> VAL)	Look(env, id) ==(if (env = [])then (undefined)else let mk_(nm, val)'NameVal = (hd env) in (if (nm = id)then valelse Look((tl env), id)))	pre (exists [mk_(nm, -) in set (elems env)] & (nm = id))Extend' (map (UniqueId) to (LVAL) * map (UniqueId) to (LVAL) +> map (UniqueId) to (LVAL))	Extend(val_m, upd_m) ==(val_m ++ {id |-> (if (id in set (dom val_m))then (val_m(id) union upd_m(id))else upd_m(id)) | id in set (dom upd_m)})SeqOfSetOf2SetOfSeqOf (seq of (set of ((BlkEnv | VAL))) ==> set of (seq of ((BlkEnv | VAL))))	SeqOfSetOf2SetOfSeqOf(seq_ls) ==(res_s'set of (seq of ((BlkEnv | VAL))) '= {[]}tmpres_s'set of (seq of ((BlkEnv | VAL))) '= (undefined)for tmp_s in seq_ls do(tmpres_s '= {};for all tmp_l in set res_s dofor all e in set tmp_s dotmpres_s '= (tmpres_s union {(tmp_l ^ [e])});res_s '= tmpres_s);return (res_s))Consistent' (LVAL * Model -> LVAL)	Consistent(lval, bind) =={mk_(val, (b munion bind)) | [mk_(val, b) in set lval] & (forall id in set ((dom b) inter (dom bind)) & (b(id) = bind(id)))}SetToSeq' (set of (VAL) +> seq of (VAL))	SetToSeq(s) ==(if (s = {})then []else let e in set s in ([e] ^ SetToSeq((s \ {e}))))	post (s = (elems RESULT))Permute' (seq of (VAL) -> set of (seq of (VAL)))	Permute(l) ==(cases l 'case [] -> {l},case [-] -> {l}others (dunion {{([l(i)] ^ j) | [j in set Permute(RestSeq(l, i))]} | [i in set (inds l)]})end)RestSeq' (seq of (VAL) * nat1 -> seq of (VAL))	RestSeq(l, i) ==[l(j) | j in set ((inds l) \ {i})]PatternIds' (Pattern +> set of (UniqueId))	PatternIds(pat) ==(cases pat 'case mk_PatternName(mk_(nm, pos)) -> {mk_(nm, pos, FnInfo())},case mk_MatchVal(-) -> {},case mk_SetEnumPattern(els) -> (dunion {PatternIds(elem) | [elem in set (elems els)]}),case mk_SetUnionPattern(lp, rp) -> (PatternIds(lp) union PatternIds(rp))end)PatternMatch (Pattern * VAL ==> set of (BlkEnv))	PatternMatch(pat_p, val_v) ==cases true '  case (is_(pat_p, PatternName)) -> let private value id'Pattern in return ({MkBlkEnv(id, val_v)})  case (is_(pat_p, MatchVal)) -> let private value lval'LVAL in (for all mk_(v, m) in set lval doif (v = val_v)thenreturn ({MkEmptyBlkEnv()});return ({}))  case (is_(pat_p, SetEnumPattern)) -> MatchSetEnumPattern(pat_p, val_v)  case (is_(pat_p, SetUnionPattern)) -> MatchSetUnionPattern(pat_p, val_v)  others -> erroresacMatchSetEnumPattern (SetEnumPattern * VAL ==> set of (BlkEnv))	MatchSetEnumPattern(mk_SetEnumPattern(elems_lp), val_v) ==if is_(val_v, SET)thenlet private value val_sv'VAL in if ((card val_sv) = (card (elems elems_lp)))thenlet private value perm_slv'set of (seq of (VAL)) in return ((dunion {MatchLists(elems_lp, tmp_lv) | [tmp_lv in set perm_slv]}))elsereturn ({})elsereturn ({})MatchSetUnionPattern (SetUnionPattern * VAL ==> set of (BlkEnv))	MatchSetUnionPattern(mk_SetUnionPattern(lp_p, rp_p), val_v) ==(envres_sl'set of (BlkEnv) '= {}if is_(val_v, SET)thenlet private value val_sv'VAL in (for all mk_(setl_sv, setr_sv) in set {mk_(setl_sv, setr_sv) | [setl_sv, setr_sv in set (power val_sv)] & (((setl_sv union setr_sv) = val_sv) and ((setl_sv inter setr_sv) = {}))} dolet private value envl_s'set of (BlkEnv)private value envr_s'set of (BlkEnv) in if ((envl_s <> {}) and (envr_s <> {}))thenlet private value tmpenv'set of (BlkEnv) in envres_sl '= (envres_sl union UnionMatch(tmpenv));return (envres_sl))elsereturn ({}))MatchLists (seq of (Pattern) * seq of (VAL) ==> set of (BlkEnv))	MatchLists(els_lp, val_lv) ==let private value tmp_ls'seq of (set of (BlkEnv)) in if ({} not in set (elems tmp_ls))thenlet private value perm_s'set of (seq of ((BlkEnv | VAL))) in UnionMatch({(conc l) | [l in set perm_s]})elsereturn ({})UnionMatch (set of (BlkEnv) ==> set of (BlkEnv))	UnionMatch(blk_sl) ==return ({StripDoubles(blk_l) | [blk_l in set blk_sl] & (forall mk_(id1, v1_v) in set (elems blk_l), mk_(id2, v2_v) in set (elems blk_l) & ((SelName(id1) = SelName(id2)) => (v1_v = v2_v)))})StripDoubles (BlkEnv ==> BlkEnv)	StripDoubles(blk_l) ==(tmpblk_l'BlkEnv '= blk_lres_l'BlkEnv '= []while (tmpblk_l <> []) do let private value id, val_v'NameVal in (if (not (exists [mk_(id1, -) in set (elems (tl tmpblk_l))] & (id1 = id)))thenres_l '= CombineBlkEnv(res_l, MkBlkEnv(SelNameAndPos(id), val_v));tmpblk_l '= (tl tmpblk_l));return (res_l))EvalBind (Bind ==> set of ((BlkEnv * Model)))	EvalBind(bind) ==EvalSetBind(bind)EvalSetBind (Bind ==> set of ((BlkEnv * Model)))	EvalSetBind(mk_Bind(pat_p, set_e)) ==(env_s'set of ((BlkEnv * Model)) '= {}let private value set_lv'LVAL in (for all mk_(set_v, m) in set set_lv do(if is_(set_v, SET)thenlet private value set_sv'VAL in (for all elm_v in set set_sv do(let private value new_envs'set of (BlkEnv) in env_s '= (env_s union {mk_(env, m) | [env in set new_envs]})))elseerror);return (env_s)))LooseEvalExpr (Expr ==> LVAL)	LooseEvalExpr(expr) ==cases true '  case (is_(expr, LetExpr)) -> LooseEvalLetExpr(expr)  case (is_(expr, LetBeSTExpr)) -> LooseEvalLetBeSTExpr(expr)  case (is_(expr, IfExpr)) -> LooseEvalIfExpr(expr)  case (is_(expr, CasesExpr)) -> LooseEvalCasesExpr(expr)  case (is_(expr, BinaryExpr)) -> LooseEvalBinaryExpr(expr)  case (is_(expr, SetEnumerationExpr)) -> LooseEvalSetEnumerationExpr(expr)  case (is_(expr, ApplyExpr)) -> LooseEvalApplyExpr(expr)  case (is_(expr, NumLit)) -> LooseEvalLiteral(expr)  case (is_(expr, BoolLit)) -> LooseEvalLiteral(expr)  case (is_(expr, Name)) -> LooseLookUp(expr)  case (is_(expr, BracketedExpr)) -> LooseEvalBracketedExpr(expr)  others -> erroresacLooseEvalBracketedExpr (BracketedExpr ==> LVAL)	LooseEvalBracketedExpr(mk_BracketedExpr(expr)) ==LooseEvalExpr(expr)LooseEvalLetExpr (LetExpr ==> LVAL)	LooseEvalLetExpr(mk_LetExpr(pat, expr, in_e)) ==(lval'LVAL '= {}let private value val_lv'LVAL in for all mk_(val_v, m) in set val_lv dolet private value env_s'set of (BlkEnv) in if (env_s <> {})thenfor all env in set env_s do(PushBlkEnv(env);let private value in_lv'LVAL in (PopBlkEnv();lval '= (lval union Consistent(in_lv, m))))elseerror;return (lval))LooseEvalLetBeSTExpr (LetBeSTExpr ==> LVAL)	LooseEvalLetBeSTExpr(mk_LetBeSTExpr(lhs, st_e, in_e)) ==(lval'LVAL '= {}em_s'set of ((BlkEnv * Model)) '= {}for all mk_(env, m) in set EvalBind(lhs) do(PushBlkEnv(env);let private value st_lv'LVAL in for all mk_(val, m2) in set Consistent(st_lv, m) doif (val = mk_BOOL(true))thenem_s '= (em_s union {mk_(env, (m2 munion m))});PopBlkEnv());if (em_s <> {})thenfor all mk_(env, m3) in set em_s do(PushBlkEnv(env);let private value in_lv'LVAL in (PopBlkEnv();lval '= (lval union Consistent(in_lv, m3))))elseerror;return (lval))LooseEvalIfExpr (IfExpr ==> LVAL)	LooseEvalIfExpr(mk_IfExpr(test, cons, altn)) ==(lval'set of ((VAL * Model)) '= {}let private value test_lv'LVAL in for all mk_(test_v, m) in set test_lv doif is_(test_v, BOOL)thenlet private value b'VAL in if bthenlval '= (lval union Consistent(LooseEvalExpr(cons), m))elselval '= (lval union Consistent(LooseEvalExpr(altn), m))elseerror;return (lval))LooseEvalCasesExpr (CasesExpr ==> LVAL)	LooseEvalCasesExpr(mk_CasesExpr(sel, altns, Others)) ==(lval'set of ((VAL * Model)) '= {}alt_l'seq of (CaseAltn) '= altnscont'bool '= truelet private value sel_lv'LVAL in for all mk_(sel_v, m) in set sel_lv do(while ((alt_l <> []) and cont) do (let private value pat, body'CaseAltn in let private value env_s'set of (BlkEnv) in if (env_s <> {})then(cont '= false;for all env in set env_s do(PushBlkEnv(env);lval '= (lval union Consistent(LooseEvalExpr(body), m));PopBlkEnv()));alt_l '= (tl alt_l));if (not cont)thencont '= trueelseif (Others = nil)thenerrorelselval '= (lval union LooseEvalExpr(Others)));return (lval))LooseEvalBinaryExpr (BinaryExpr ==> LVAL)	LooseEvalBinaryExpr(mk_BinaryExpr(left_e, opr, right_e)) ==let private value left_lv'LVALprivate value right_lv'LVAL in if (opr = <SETMINUS>)thenLooseEvalSetBinaryExpr(left_lv, right_lv)elseif (opr = <EQ>)thenLooseEvalEqBinaryExpr(left_lv, right_lv)elseLooseEvalNumBinaryExpr(left_lv, opr, right_lv)LooseEvalSetBinaryExpr (LVAL * LVAL ==> LVAL)	LooseEvalSetBinaryExpr(l_lv, r_lv) ==(lval'LVAL '= {}for all mk_(mk_SET(lv), lm) in set l_lv dofor all mk_(mk_SET(rv), rm) in set Consistent(r_lv, lm) dolval '= (lval union {mk_(mk_SET((lv \ rv)), (rm munion lm))});return (lval))	pre (forall mk_(v, -) in set (l_lv union r_lv) & is_(v, SET))LooseEvalEqBinaryExpr (LVAL * LVAL ==> LVAL)	LooseEvalEqBinaryExpr(l_lv, r_lv) ==(lval'LVAL '= {}for all mk_(lv, lm) in set l_lv dofor all mk_(rv, rm) in set Consistent(r_lv, lm) dolval '= (lval union {mk_(mk_BOOL((lv = rv)), (rm munion lm))});return (lval))LooseEvalNumBinaryExpr (LVAL * BinaryOp * LVAL ==> LVAL)	LooseEvalNumBinaryExpr(l_lv, opr, r_lv) ==(lval'LVAL '= {}for all mk_(mk_NUM(lv), lm) in set l_lv dofor all mk_(mk_NUM(rv), rm) in set Consistent(r_lv, lm) docases opr '  case <NUMMINUS> -> lval '= (lval union {mk_(mk_NUM((lv - rv)), (rm munion lm))})  case <NUMPLUS> -> lval '= (lval union {mk_(mk_NUM((lv + rv)), (rm munion lm))})  case <NUMMULT> -> lval '= (lval union {mk_(mk_NUM((lv * rv)), (rm munion lm))})esac;return (lval))	pre (forall mk_(v, -) in set (l_lv union r_lv) & is_(v, NUM))LooseEvalSetEnumerationExpr (SetEnumerationExpr ==> LVAL)	LooseEvalSetEnumerationExpr(mk_SetEnumerationExpr(els)) ==(sm_s'set of ((set of (VAL) * Model)) '= {}if ((len els) = 0)thenreturn ({mk_(mk_SET({}), {})})else(sm_s '= {mk_({elem}, m) | [mk_(elem, m) in set LooseEvalExpr(els(1))]};for index = 2 to (len els)let private value elm_llv'LVAL in sm_s '= {mk_((s union {e}), (m munion m2)) | [mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv] & (forall id in set ((dom m) inter (dom m2)) & (m(id) = m2(id)))};return ({mk_(mk_SET(s), m) | [mk_(s, m) in set sm_s]})))LooseEvalApplyExpr (ApplyExpr ==> LVAL)	LooseEvalApplyExpr(mk_ApplyExpr(fct_e, arg_e)) ==(lval'LVAL '= {}let private value arg_lv'LVALprivate value pat, body'(Pattern * Expr) in (PushEmptyEnv();for all mk_(arg_v, m) in set arg_lv dolet private value env_s'set of (BlkEnv) in (InstallCurFn(fct_e, arg_v, PatternIds(pat));for all env in set env_s do(PushBlkEnv(env);let private value ap_lv'LVAL in (PopBlkEnv();lval '= (lval union Consistent(ap_lv, m)))));LeaveCurFn());PopEnvL();return (lval))LooseEvalLiteral (Literal ==> LVAL)	LooseEvalLiteral(lit) ==return ((if is_(lit, NumLit)then {mk_(mk_NUM((lit.val)), {})}else {mk_(mk_BOOL((lit.val)), {})}))end DEFAULT
