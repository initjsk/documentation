RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsSeqOfSetOf2SetOfSeqOf (seq of (set of ((((unresolved DEFAULT`BlkEnv) | (unresolved DEFAULT`VAL))))) ==> set of (seq of ((((unresolved DEFAULT`BlkEnv) | (unresolved DEFAULT`VAL))))))	SeqOfSetOf2SetOfSeqOf(seq_ls) ==(res_s'set of (seq of ((((unresolved DEFAULT`BlkEnv) | (unresolved DEFAULT`VAL))))) '= {[]}tmpres_s'set of (seq of ((((unresolved DEFAULT`BlkEnv) | (unresolved DEFAULT`VAL))))) '= (undefined)for tmp_s in seq_ls do(tmpres_s '= {};for all tmp_l in set res_s dofor all e in set tmp_s dotmpres_s '= (tmpres_s union {(tmp_l ^ [e])});res_s '= tmpres_s);return (res_s))Consistent' ((unresolved DEFAULT`LVAL) * (unresolved DEFAULT`Model) -> (unresolved DEFAULT`LVAL))	Consistent(lval, bind) =={mk_(val, (b munion bind)) | [mk_(val, b) in set lval] & (forall id in set ((dom b) inter (dom bind)) & (b(id) = bind(id)))}SetToSeq' (set of ((unresolved DEFAULT`VAL)) +> seq of ((unresolved DEFAULT`VAL)))	SetToSeq(s) ==(if (s = {})then []else let e in set s in ([e] ^ SetToSeq((s \ {e}))))	post (s = (elems RESULT))Permute' (seq of ((unresolved DEFAULT`VAL)) -> set of (seq of ((unresolved DEFAULT`VAL))))	Permute(l) ==(cases l 'case [] -> {l},case [-] -> {l}others (dunion {{([l(i)] ^ j) | [j in set Permute(RestSeq(l, i))]} | [i in set (inds l)]})end)RestSeq' (seq of ((unresolved DEFAULT`VAL)) * nat1 -> seq of ((unresolved DEFAULT`VAL)))	RestSeq(l, i) ==[l(j) | j in set ((inds l) \ {i})]PatternIds' ((unresolved DEFAULT`Pattern) +> set of ((unresolved DEFAULT`UniqueId)))	PatternIds(pat) ==(cases pat 'case mk_(unresolved DEFAULT`PatternName)(mk_(nm, pos)) -> {mk_(nm, pos, FnInfo())},case mk_(unresolved DEFAULT`MatchVal)(-) -> {},case mk_(unresolved DEFAULT`SetEnumPattern)(els) -> (dunion {PatternIds(elem) | [elem in set (elems els)]}),case mk_(unresolved DEFAULT`SetUnionPattern)(lp, rp) -> (PatternIds(lp) union PatternIds(rp))end)end DEFAULT, module DEFAULTexports alldefinitionsPatternMatch ((unresolved DEFAULT`Pattern) * (unresolved DEFAULT`VAL) ==> set of ((unresolved DEFAULT`BlkEnv)))	PatternMatch(pat_p, val_v) ==cases true '  case (is_(pat_p, PatternName)) -> let private value id'? in return ({MkBlkEnv(id, val_v)})  case (is_(pat_p, MatchVal)) -> let private value lval'? in (for all mk_(v, m) in set lval doif (v = val_v)thenreturn ({MkEmptyBlkEnv()});return ({}))  case (is_(pat_p, SetEnumPattern)) -> MatchSetEnumPattern(pat_p, val_v)  case (is_(pat_p, SetUnionPattern)) -> MatchSetUnionPattern(pat_p, val_v)esacMatchSetEnumPattern ((unresolved DEFAULT`SetEnumPattern) * (unresolved DEFAULT`VAL) ==> set of ((unresolved DEFAULT`BlkEnv)))	MatchSetEnumPattern(mk_(unresolved DEFAULT`SetEnumPattern)(elems_lp), val_v) ==if is_(val_v, SET)thenlet private value val_sv'? in if ((card val_sv) = (card (elems elems_lp)))thenlet private value perm_slv'? in return ((dunion {MatchLists(elems_lp, tmp_lv) | [tmp_lv in set perm_slv]}))elsereturn ({})elsereturn ({})MatchSetUnionPattern ((unresolved DEFAULT`SetUnionPattern) * (unresolved DEFAULT`VAL) ==> set of ((unresolved DEFAULT`BlkEnv)))	MatchSetUnionPattern(mk_(unresolved DEFAULT`SetUnionPattern)(lp_p, rp_p), val_v) ==(envres_sl'set of ((unresolved DEFAULT`BlkEnv)) '= {}if is_(val_v, SET)thenlet private value val_sv'? in (for all mk_(setl_sv, setr_sv) in set {mk_(setl_sv, setr_sv) | [setl_sv, setr_sv in set (power val_sv)] & (((setl_sv union setr_sv) = val_sv) and ((setl_sv inter setr_sv) = {}))} dolet private value envl_s'?private value envr_s'? in if ((envl_s <> {}) and (envr_s <> {}))thenlet private value tmpenv'? in envres_sl '= (envres_sl union UnionMatch(tmpenv));return (envres_sl))elsereturn ({}))MatchLists (seq of ((unresolved DEFAULT`Pattern)) * seq of ((unresolved DEFAULT`VAL)) ==> set of ((unresolved DEFAULT`BlkEnv)))	MatchLists(els_lp, val_lv) ==let private value tmp_ls'? in if ({} not in set (elems tmp_ls))thenlet private value perm_s'? in UnionMatch({(conc l) | [l in set perm_s]})elsereturn ({})UnionMatch (set of ((unresolved DEFAULT`BlkEnv)) ==> set of ((unresolved DEFAULT`BlkEnv)))	UnionMatch(blk_sl) ==return ({StripDoubles(blk_l) | [blk_l in set blk_sl] & (forall mk_(id1, v1_v) in set (elems blk_l), mk_(id2, v2_v) in set (elems blk_l) & ((SelName(id1) = SelName(id2)) => (v1_v = v2_v)))})StripDoubles ((unresolved DEFAULT`BlkEnv) ==> (unresolved DEFAULT`BlkEnv))	StripDoubles(blk_l) ==(tmpblk_l'(unresolved DEFAULT`BlkEnv) '= blk_lres_l'(unresolved DEFAULT`BlkEnv) '= []while (tmpblk_l <> []) do let private value id, val_v'? in (if (not (exists [mk_(id1, -) in set (elems (tl tmpblk_l))] & (id1 = id)))thenres_l '= CombineBlkEnv(res_l, MkBlkEnv(SelNameAndPos(id), val_v));tmpblk_l '= (tl tmpblk_l));return (res_l))EvalBind ((unresolved DEFAULT`Bind) ==> set of ((((unresolved DEFAULT`BlkEnv) * (unresolved DEFAULT`Model)))))	EvalBind(bind) ==EvalSetBind(bind)EvalSetBind ((unresolved DEFAULT`SetBind) ==> set of ((((unresolved DEFAULT`BlkEnv) * (unresolved DEFAULT`Model)))))	EvalSetBind(mk_(unresolved DEFAULT`SetBind)(pat_p, set_e)) ==(env_s'set of ((((unresolved DEFAULT`BlkEnv) * (unresolved DEFAULT`Model)))) '= {}let private value set_lv'? in (for all mk_(set_v, m) in set set_lv do(if is_(set_v, SET)thenlet private value set_sv'? in (for all elm_v in set set_sv do(let private value new_envs'? in env_s '= (env_s union {mk_(env, m) | [env in set new_envs]})))elseerror);return (env_s)))end DEFAULT, module DEFAULTexports alldefinitionsLooseEvalExpr ((unresolved DEFAULT`Expr) ==> (unresolved DEFAULT`LVAL))	LooseEvalExpr(expr) ==cases true '  case (is_(expr, LetExpr)) -> LooseEvalLetExpr(expr)  case (is_(expr, LetBeSTExpr)) -> LooseEvalLetBeSTExpr(expr)  case (is_(expr, IfExpr)) -> LooseEvalIfExpr(expr)  case (is_(expr, CasesExpr)) -> LooseEvalCasesExpr(expr)  case (is_(expr, BinaryExpr)) -> LooseEvalBinaryExpr(expr)  case (is_(expr, SetEnumerationExpr)) -> LooseEvalSetEnumerationExpr(expr)  case (is_(expr, ApplyExpr)) -> LooseEvalApplyExpr(expr)  case (is_(expr, NumLit)) -> LooseEvalLiteral(expr)  case (is_(expr, BoolLit)) -> LooseEvalLiteral(expr)  case (is_(expr, Name)) -> LooseLookUp(expr)  case (is_(expr, BracketedExpr)) -> LooseEvalBracketedExpr(expr)  others -> erroresacLooseEvalBracketedExpr ((unresolved DEFAULT`BracketedExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalBracketedExpr(mk_(unresolved DEFAULT`BracketedExpr)(expr)) ==LooseEvalExpr(expr)LooseEvalLetExpr ((unresolved DEFAULT`LetExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalLetExpr(mk_(unresolved DEFAULT`LetExpr)(pat, expr, in_e)) ==(lval'(unresolved DEFAULT`LVAL) '= {}let private value val_lv'? in for all mk_(val_v, m) in set val_lv dolet private value env_s'? in if (env_s <> {})thenfor all env in set env_s do(PushBlkEnv(env);let private value in_lv'? in (PopBlkEnv();lval '= (lval union Consistent(in_lv, m))))elseerror;return (lval))LooseEvalLetBeSTExpr ((unresolved DEFAULT`LetBeSTExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalLetBeSTExpr(mk_(unresolved DEFAULT`LetBeSTExpr)(lhs, st_e, in_e)) ==(lval'(unresolved DEFAULT`LVAL) '= {}em_s'set of ((((unresolved DEFAULT`BlkEnv) * (unresolved DEFAULT`Model)))) '= {}for all mk_(env, m) in set EvalBind(lhs) do(PushBlkEnv(env);let private value st_lv'? in for all mk_(val, m2) in set Consistent(st_lv, m) doif (val = mk_BOOL(true))thenem_s '= (em_s union {mk_(env, (m2 munion m))});PopBlkEnv());if (em_s <> {})thenfor all mk_(env, m3) in set em_s do(PushBlkEnv(env);let private value in_lv'? in (PopBlkEnv();lval '= (lval union Consistent(in_lv, m3))))elseerror;return (lval))LooseEvalIfExpr ((unresolved DEFAULT`IfExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalIfExpr(mk_(unresolved DEFAULT`IfExpr)(test, cons, altn)) ==(lval'set of ((((unresolved DEFAULT`VAL) * (unresolved DEFAULT`Model)))) '= {}let private value test_lv'? in for all mk_(test_v, m) in set test_lv doif is_(test_v, BOOL)thenlet private value b'? in if bthenlval '= (lval union Consistent(LooseEvalExpr(cons), m))elselval '= (lval union Consistent(LooseEvalExpr(altn), m))elseerror;return (lval))LooseEvalCasesExpr ((unresolved DEFAULT`CasesExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalCasesExpr(mk_(unresolved DEFAULT`CasesExpr)(sel, altns, Others)) ==(lval'set of ((((unresolved DEFAULT`VAL) * (unresolved DEFAULT`Model)))) '= {}alt_l'seq of ((unresolved DEFAULT`CaseAltn)) '= altnscont'bool '= truelet private value sel_lv'? in for all mk_(sel_v, m) in set sel_lv do(while ((alt_l <> []) and cont) do (let private value pat, body'? in let private value env_s'? in if (env_s <> {})then(cont '= false;for all env in set env_s do(PushBlkEnv(env);lval '= (lval union Consistent(LooseEvalExpr(body), m));PopBlkEnv()));alt_l '= (tl alt_l));if (not cont)thencont '= trueelseif (Others = nil)thenerrorelselval '= (lval union LooseEvalExpr(Others)));return (lval))LooseEvalBinaryExpr ((unresolved DEFAULT`BinaryExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalBinaryExpr(mk_(unresolved DEFAULT`BinaryExpr)(left_e, opr, right_e)) ==let private value left_lv'?private value right_lv'? in if (opr = <SETMINUS>)thenLooseEvalSetBinaryExpr(left_lv, right_lv)elseif (opr = <EQ>)thenLooseEvalEqBinaryExpr(left_lv, right_lv)elseLooseEvalNumBinaryExpr(left_lv, opr, right_lv)LooseEvalSetBinaryExpr ((unresolved DEFAULT`LVAL) * (unresolved DEFAULT`LVAL) ==> (unresolved DEFAULT`LVAL))	LooseEvalSetBinaryExpr(l_lv, r_lv) ==(lval'(unresolved DEFAULT`LVAL) '= {}for all mk_(mk_(unresolved DEFAULT`SET)(lv), lm) in set l_lv dofor all mk_(mk_(unresolved DEFAULT`SET)(rv), rm) in set Consistent(r_lv, lm) dolval '= (lval union {mk_(mk_SET((lv \ rv)), (rm munion lm))});return (lval))	pre (forall mk_(v, -) in set (l_lv union r_lv) & is_(v, SET))LooseEvalEqBinaryExpr ((unresolved DEFAULT`LVAL) * (unresolved DEFAULT`LVAL) ==> (unresolved DEFAULT`LVAL))	LooseEvalEqBinaryExpr(l_lv, r_lv) ==(lval'(unresolved DEFAULT`LVAL) '= {}for all mk_(lv, lm) in set l_lv dofor all mk_(rv, rm) in set Consistent(r_lv, lm) dolval '= (lval union {mk_(mk_BOOL((lv = rv)), (rm munion lm))});return (lval))LooseEvalNumBinaryExpr ((unresolved DEFAULT`LVAL) * (unresolved DEFAULT`BinaryOp) * (unresolved DEFAULT`LVAL) ==> (unresolved DEFAULT`LVAL))	LooseEvalNumBinaryExpr(l_lv, opr, r_lv) ==(lval'(unresolved DEFAULT`LVAL) '= {}for all mk_(mk_(unresolved DEFAULT`NUM)(lv), lm) in set l_lv dofor all mk_(mk_(unresolved DEFAULT`NUM)(rv), rm) in set Consistent(r_lv, lm) docases opr '  case <NUMMINUS> -> lval '= (lval union {mk_(mk_NUM((lv - rv)), (rm munion lm))})  case <NUMPLUS> -> lval '= (lval union {mk_(mk_NUM((lv + rv)), (rm munion lm))})  case <NUMMULT> -> lval '= (lval union {mk_(mk_NUM((lv * rv)), (rm munion lm))})esac;return (lval))	pre (forall mk_(v, -) in set (l_lv union r_lv) & is_(v, NUM))LooseEvalSetEnumerationExpr ((unresolved DEFAULT`SetEnumerationExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalSetEnumerationExpr(mk_(unresolved DEFAULT`SetEnumerationExpr)(els)) ==(sm_s'set of ((((set of ((unresolved DEFAULT`VAL))) * (unresolved DEFAULT`Model)))) '= {}if ((len els) = 0)thenreturn ({mk_(mk_SET({}), {})})else(sm_s '= {mk_({elem}, m) | [mk_(elem, m) in set LooseEvalExpr(els(1))]};for index = 2 to (len els)let private value elm_llv'? in sm_s '= {mk_((s union {e}), (m munion m2)) | [mk_(s, m) in set sm_s, mk_(e, m2) in set elm_llv] & (forall id in set ((dom m) inter (dom m2)) & (m(id) = m2(id)))};return ({mk_(mk_SET(s), m) | [mk_(s, m) in set sm_s]})))LooseEvalApplyExpr ((unresolved DEFAULT`ApplyExpr) ==> (unresolved DEFAULT`LVAL))	LooseEvalApplyExpr(mk_(unresolved DEFAULT`ApplyExpr)(fct_e, arg_e)) ==(lval'(unresolved DEFAULT`LVAL) '= {}let private value arg_lv'?private value pat, body'? in (PushEmptyEnv();for all mk_(arg_v, m) in set arg_lv dolet private value env_s'? in (InstallCurFn(fct_e, arg_v, PatternIds(pat));for all env in set env_s do(PushBlkEnv(env);let private value ap_lv'? in (PopBlkEnv();lval '= (lval union Consistent(ap_lv, m)))));LeaveCurFn());PopEnvL();return (lval))LooseEvalLiteral ((unresolved DEFAULT`Literal) ==> (unresolved DEFAULT`LVAL))	LooseEvalLiteral(lit) ==return ((if is_(lit, NumLit)then {mk_(mk_NUM((lit.val)), {})}else {mk_(mk_BOOL((lit.val)), {})}))end DEFAULT, module DEFAULTexports alldefinitionsstatic private Definitions = compose Definitions of valuem'seq of ((unresolved DEFAULT`ValueDef)), fnm'map ((unresolved DEFAULT`Name)) to ((unresolved DEFAULT`ExplFnDef)) endstatic private ValueDef = compose ValueDef of pat'(unresolved DEFAULT`Pattern), val'(unresolved DEFAULT`Expr) endstatic private ExplFnDef = compose ExplFnDef of nm'(unresolved DEFAULT`Name), pat'(unresolved DEFAULT`Pattern), body'(unresolved DEFAULT`Expr) endstatic private Expr = ((unresolved DEFAULT`ApplyExpr) | (unresolved DEFAULT`BinaryExpr) | (unresolved DEFAULT`BracketedExpr) | (unresolved DEFAULT`CasesExpr) | (unresolved DEFAULT`IfExpr) | (unresolved DEFAULT`LetBeSTExpr) | (unresolved DEFAULT`LetExpr) | (unresolved DEFAULT`Literal) | (unresolved DEFAULT`Name) | (unresolved DEFAULT`SetEnumerationExpr) | (unresolved DEFAULT`UnaryExpr))static private BracketedExpr = compose BracketedExpr of expr'(unresolved DEFAULT`Expr) endstatic private LetExpr = compose LetExpr of lhs'(unresolved DEFAULT`Pattern), rhs'(unresolved DEFAULT`Expr), body'(unresolved DEFAULT`Expr) endstatic private LetBeSTExpr = compose LetBeSTExpr of lhs'(unresolved DEFAULT`Bind), St'(unresolved DEFAULT`Expr), In'(unresolved DEFAULT`Expr) endstatic private IfExpr = compose IfExpr of test'(unresolved DEFAULT`Expr), cons'(unresolved DEFAULT`Expr), altn'(unresolved DEFAULT`Expr) endstatic private CasesExpr = compose CasesExpr of sel'(unresolved DEFAULT`Expr), altns'seq of ((unresolved DEFAULT`CaseAltn)), Others'[(unresolved DEFAULT`Expr)] endstatic private CaseAltn = compose CaseAltn of match'(unresolved DEFAULT`Pattern), body'(unresolved DEFAULT`Expr) endstatic private UnaryExpr = compose UnaryExpr of opr'(unresolved DEFAULT`UnaryOp), arg'(unresolved DEFAULT`Expr) endstatic private UnaryOp = <NUMMINUS>static private BinaryExpr = compose BinaryExpr of left'(unresolved DEFAULT`Expr), opr'(unresolved DEFAULT`BinaryOp), right'(unresolved DEFAULT`Expr) endstatic private BinaryOp = (<EQ> | <NUMMINUS> | <NUMMULT> | <NUMPLUS> | <SETMINUS>)static private SetEnumerationExpr = compose SetEnumerationExpr of els'seq of ((unresolved DEFAULT`Expr)) endstatic private ApplyExpr = compose ApplyExpr of fct'(unresolved DEFAULT`Name), arg'(unresolved DEFAULT`Expr) endstatic private Name = compose Name of ids'seq of ((unresolved DEFAULT`Id)) endstatic private Id = seq of (char)static private Pattern = ((unresolved DEFAULT`MatchVal) | (unresolved DEFAULT`PatternName) | (unresolved DEFAULT`SetPattern))static private PatternName = compose PatternName of nm'[(((unresolved DEFAULT`Name) * (unresolved DEFAULT`Position)))] endstatic private MatchVal = compose MatchVal of val'(unresolved DEFAULT`Expr) endstatic private SetPattern = ((unresolved DEFAULT`SetEnumPattern) | (unresolved DEFAULT`SetUnionPattern))static private SetEnumPattern = compose SetEnumPattern of Elems'seq of ((unresolved DEFAULT`Pattern)) endstatic private SetUnionPattern = compose SetUnionPattern of lp'(unresolved DEFAULT`Pattern), rp'(unresolved DEFAULT`Pattern) endstatic private Position = (nat * nat)static private Bind = (unresolved DEFAULT`SetBind)static private SetBind = compose SetBind of pat'(unresolved DEFAULT`Pattern), Set'(unresolved DEFAULT`Expr) endstatic private Literal = ((unresolved DEFAULT`BoolLit) | (unresolved DEFAULT`NumLit))static private BoolLit = compose BoolLit of val'bool endstatic private NumLit = compose NumLit of val'int endstatic private pat'(unresolved DEFAULT`Pattern) = mk_PatternName(mk_(mk_Name(["x"]), mk_(1, 1)))static private sexpr'(unresolved DEFAULT`Expr) = mk_SetEnumerationExpr([mk_NumLit(1), mk_NumLit(2)])static private expr'(unresolved DEFAULT`Expr) = mk_LetBeSTExpr(mk_SetBind(pat, sexpr), mk_BoolLit(true), mk_Name(["x"]))static private expr2'(unresolved DEFAULT`Expr) = mk_BinaryExpr(expr, <NUMPLUS>, expr)end DEFAULT, module DEFAULTexports alldefinitionsstatic private ENVL = seq of ((unresolved DEFAULT`ENV))static private ENV = seq of ((unresolved DEFAULT`BlkEnv))static private BlkEnv = seq of ((unresolved DEFAULT`NameVal))static private NameVal = ((unresolved DEFAULT`UniqueId) * (unresolved DEFAULT`VAL))static private UniqueId = (((unresolved DEFAULT`Name) * (unresolved DEFAULT`Position) * ([((unresolved DEFAULT`Name) * (unresolved DEFAULT`VAL))])))static private LVAL = set of ((((unresolved DEFAULT`VAL) * (unresolved DEFAULT`Model))))static private Model = map ((unresolved DEFAULT`UniqueId)) to ((unresolved DEFAULT`VAL))static private VAL = ((unresolved DEFAULT`BOOL) | (unresolved DEFAULT`NUM) | (unresolved DEFAULT`SET))static private NUM = compose NUM of v'int endstatic private BOOL = compose BOOL of v'bool endstatic private SET = compose SET of v'set of ((unresolved DEFAULT`VAL)) endstate Sigmaof[env_l'(unresolved DEFAULT`ENVL), val_m'map ((unresolved DEFAULT`UniqueId)) to ((unresolved DEFAULT`LVAL)), fn_m'map ((unresolved DEFAULT`Name)) to ((((unresolved DEFAULT`Pattern) * (unresolved DEFAULT`Expr)))), curfn'seq of ((((unresolved DEFAULT`Name) * (unresolved DEFAULT`VAL)))), fnparms'set of ((unresolved DEFAULT`UniqueId))]	init s == (s = mk_Sigma([[]], {}, {}, [], {}))CreateContext ((unresolved DEFAULT`Definitions) ==> ())	CreateContext(mk_(unresolved DEFAULT`Definitions)(valuem, fnm)) ==(InstallValueDefs(valuem);InstallFnDefs(fnm))InstallValueDefs (seq of ((unresolved DEFAULT`ValueDef)) ==> ())	InstallValueDefs(val_l) ==for mk_(unresolved DEFAULT`ValueDef)(pat, expr) in val_l dolet private value lval'? in for all mk_(val, model) in set lval dolet private value env_s'? in val_m '= Extend(val_m, {id |-> {mk_(Look(env, id), model) | [env in set env_s]} | id in set (dinter {SelDom(env) | [env in set env_s]})})InstallFnDefs (map ((unresolved DEFAULT`Name)) to ((unresolved DEFAULT`ExplFnDef)) ==> ())	InstallFnDefs(fn_marg) ==fn_m '= {nm |-> mk_((fn_marg(nm).pat), (fn_marg(nm).body)) | nm in set (dom fn_marg)}InstallCurFn ((unresolved DEFAULT`Name) * (unresolved DEFAULT`VAL) * set of ((unresolved DEFAULT`UniqueId)) ==> ())	InstallCurFn(nm, val, patids) ==(curfn '= ([mk_(nm, val)] ^ curfn);fnparms '= (fnparms union patids))LeaveCurFn (() ==> ())	LeaveCurFn() ==curfn '= (tl curfn)	pre (curfn <> [])PopEnvL (() ==> ())	PopEnvL() ==env_l '= (tl env_l)TopEnvL (() ==> (unresolved DEFAULT`ENV))	TopEnvL() ==return ((hd env_l))PushEmptyEnv (() ==> ())	PushEmptyEnv() ==env_l '= ([[]] ^ env_l)PopBlkEnv (() ==> ())	PopBlkEnv() ==env_l '= ([(tl (hd env_l))] ^ (tl env_l))PushBlkEnv ((unresolved DEFAULT`BlkEnv) ==> ())	PushBlkEnv(benv) ==env_l '= ([([benv] ^ (hd env_l))] ^ (tl env_l))MkEmptyBlkEnv (() ==> (unresolved DEFAULT`BlkEnv))	MkEmptyBlkEnv() ==return ([])CombineBlkEnv ((unresolved DEFAULT`BlkEnv) * (unresolved DEFAULT`BlkEnv) ==> (unresolved DEFAULT`BlkEnv))	CombineBlkEnv(env1, env2) ==return ((env1 ^ env2))MkBlkEnv ((((unresolved DEFAULT`Name) * (unresolved DEFAULT`Position))) * (unresolved DEFAULT`VAL) ==> (unresolved DEFAULT`BlkEnv))	MkBlkEnv(mk_(nm, pos), val_v) ==let private value fninfo'? in return ([mk_(mk_(nm, pos, fninfo), val_v)])FnInfo (() ==> [((unresolved DEFAULT`Name) * (unresolved DEFAULT`VAL))])	FnInfo() ==if ((len curfn) = 0)thenreturn (nil)elsereturn ((hd curfn))LooseLookUp ((unresolved DEFAULT`Name) ==> (unresolved DEFAULT`LVAL))	LooseLookUp(nm) ==(let private value topenv'? in for env in topenv dofor mk_(id, val) in env doif (SelName(id) = nm)thenreturn ({mk_(val, (if (id in set fnparms)then {}else {id |-> val}))})elseskip;LookUpValueDefs(nm))LookUpValueDefs ((unresolved DEFAULT`Name) ==> (unresolved DEFAULT`LVAL))	LookUpValueDefs(nm) ==(for all id in set (dom val_m) doif (SelName(id) = nm)thenreturn ({mk_(v, (m munion {id |-> v})) | [mk_(v, m) in set val_m(id)]});error)LookUpFn ((unresolved DEFAULT`Name) ==> ((unresolved DEFAULT`Pattern) * (unresolved DEFAULT`Expr)))	LookUpFn(nm) ==return (fn_m(nm))	pre (nm in set (dom fn_m))SelName' ((unresolved DEFAULT`UniqueId) +> (unresolved DEFAULT`Name))	SelName(mk_(nm, -, -)) ==nmSelNameAndPos' ((unresolved DEFAULT`UniqueId) +> ((unresolved DEFAULT`Name) * (unresolved DEFAULT`Position)))	SelNameAndPos(mk_(nm, pos, -)) ==mk_(nm, pos)SelDom' ((unresolved DEFAULT`BlkEnv) +> set of ((unresolved DEFAULT`UniqueId)))	SelDom(blkenv) =={id | [mk_(id, -) in set (elems blkenv)]}Look' ((unresolved DEFAULT`BlkEnv) * (unresolved DEFAULT`UniqueId) +> (unresolved DEFAULT`VAL))	Look(env, id) ==(if (env = [])then (undefined)else let mk_(nm, val) = (hd env) in (if (nm = id)then valelse Look((tl env), id)))	pre (exists [mk_(nm, -) in set (elems env)] & (nm = id))Extend' ((map ((unresolved DEFAULT`UniqueId)) to ((unresolved DEFAULT`LVAL))) * (map ((unresolved DEFAULT`UniqueId)) to ((unresolved DEFAULT`LVAL))) +> (map ((unresolved DEFAULT`UniqueId)) to ((unresolved DEFAULT`LVAL))))	Extend(val_m, upd_m) ==(val_m ++ {id |-> (if (id in set (dom val_m))then (val_m(id) union upd_m(id))else upd_m(id)) | id in set (dom upd_m)})end DEFAULT
