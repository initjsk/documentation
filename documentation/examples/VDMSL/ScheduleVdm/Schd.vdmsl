module Schd
exports all
definitions

types

Name 			= seq of char;
CpuId 			= AS`Identifier;
BusId 			= AS`Identifier;
ClassId			= AS`Identifier;
OpId			= AS`Identifier;
ThreadId 		= token;
MessageId 		= token;

ThreadInfo ::
	status 	: <RUN> | <BREAK> | <BLOCKED>
	cpu 	: [CpuId]
	obj 	: AS`ObjRef
	prioity : nat
	ast		: AS`Statement;
	
CpuInfo ::
	threads : map ThreadId to ThreadInfo
	deployed: set of AS`ObjRef
	policy  : <FC> | <FCFS>;
	
MessageInfo ::
	time 	: nat
	src 	: CpuId
	dest	: CpuId;
	
BusInfo ::
	cpus	: set of CpuId
	msgInfo	: map MessageId to MessageInfo
	policy	: <FCFS> | <OTHER>;
	
ClassInfo ::
	thread	: [ThreadInfo]
	ops		: set of OpId
	sync	: PermInfo;

PermInfo ::
	syncMap	: map AS`OperationDefinition to AS`SynchronizationDefinitions; -- or: set of AS`PermissionPredicate; ???

BreakInfo::;

Val::;
	
	

state Sigma of

busInfo 	: map BusId to BusInfo
cpuInfo 	: map CpuId to CpuInfo
classInfo	: map ClassId to ClassInfo
permInfo 	: map Name  to PermInfo
time 		: nat
end

operations

expandSpec : AS`Spec ==> ()
expandSpec(mk_AS`Spec(sys,classm)) == 
 (expandSys(sys);
  for all id in set dom classm do
    expandClass(id, classm(id))
 );
  
expandSys: AS`System ==> ()
expandSys(mk_AS`System(cpus,buses,deployed)) ==
  (busInfo := {id |-> mk_BusInfo(buses(id),{|->},<FCFS>) 
              | id in set dom buses};
   cpuInfo := {id |->
               let deplid = if id in set dom deployed
                            then deployed(id)
                            else {}
               in
                 mk_CpuInfo({|->},deplid,pol)
              | mk_(id,pol) in set cpus}
  );   
   
expandClass: AS`Identifier * AS`Class ==> ()
expandClass(id,mk_AS`Class(td,opdefs,sync)) ==
   is not yet specified;

end Schd