module Schd
imports from Eval all
exports all
definitions

types

--Name 			= seq of char;
CpuId 			= AS`Identifier;
BusId 			= AS`Identifier;
ClassId			= AS`Identifier;
OpId			= AS`Identifier;
ThreadId 		= token;
MessageId 		= token;

ThreadStatus = <RUN> | <BREAK> | BLOCKED | DURATION;

ThreadInfo ::
	status 	: ThreadStatus
	cpu 	: [CpuId]
	obj 	: AS`ObjRef
	debug	: bool
	prioity : nat
	ast		: AS`Statement;
	
-- Both <RUN> and DURATION will be shown as suspended in the debugger
	
BLOCKED ::
	nm		: AS`Name;
	
DURATION ::
	t		: nat;
	
CpuInfo ::
	threads : map ThreadId to ThreadInfo
	deployed: set of AS`ObjRef
	policy  : <FC> | <FCFS>;
	
MessageInfo ::
	time 	: nat
	src 	: CpuId
	dest	: CpuId;
	
BusInfo ::
	cpus	: set of CpuId
	msgInfo	: map MessageId to MessageInfo
	policy	: <FCFS> | <OTHER>;
	
ClassInfo ::
	thread	: [ThreadInfo]
	ops		: set of OpId
	sync	: PermInfo;

PermInfo ::
	hisCount	: set of AS`Name 	-- Operation name used in history counters
	instVars	: set of AS`Name;	-- Names of instance variables used inside perm predicate

BreakInfo::;

Val::;
	
	

state Sigma of

busInfo 	: map BusId to BusInfo
cpuInfo 	: map CpuId to CpuInfo
classInfo	: map ClassId to ClassInfo
permInfo 	: map AS`Name to PermInfo
threadInfo	: map nat to ThreadInfo
time 		: nat
finished    : bool
inv s == s.threadInfo <> {|->} => exists1 t in set rng s.threadInfo & t.debug
end

operations

--StartScheduler : AS`Expression * AS`Spec * nat ==> Val
--StartScheduler (expr, spec, delta) ==
--  (dcl res : ThreadStatus := Eval`evalExpr(expr,delta);
--   expandSpec(spec);
--   while(not finished) 
--   do 
--     (
--     );
--  ); 

expandSpec : AS`Spec ==> ()
expandSpec(mk_AS`Spec(sys,classm)) == 
 (expandSys(sys);
  for all id in set dom classm do
    expandClass(id, classm(id))
 );
  
expandSys: AS`System ==> ()
expandSys(mk_AS`System(cpus,buses,deployed)) ==
  (busInfo := {id |-> mk_BusInfo(buses(id),{|->},<FCFS>) 
              | id in set dom buses};
   cpuInfo := {id |->
               let deplid = if id in set dom deployed
                            then deployed(id)
                            else {}
               in
                 mk_CpuInfo({|->},deplid,pol)
              | mk_(id,pol) in set cpus}
  );   
   
expandClass: AS`Identifier * AS`Class ==> ()
expandClass(id,mk_AS`Class(td,opdefs,mk_AS`SynchronizationDefinitions(sync))) ==
   permInfo := {sync(i).name |-> mk_PermInfo(extractHistCounts(sync(i).expression), 
   											 extractInstVar(sync(i).expression))
   				| i in set inds sync};
    
functions

extractHistCounts: AS`Expression -> set of AS`Name
extractHistCounts(expr) ==
	is not yet specified;

extractInstVar: AS`Expression -> set of AS`Name
extractInstVar(expr) ==
	is not yet specified;

end Schd
