WARNING:test.vdmsl:3264:39,59:Empty set used in bind.
WARNING:test.vdmsl:3264:43,41:Empty set used in bind.
WARNING:test.vdmsl:5012:88,14:Recursive function has no measure.
WARNING:test.vdmsl:3264:48,59:Empty set used in bind.
RESULT:result:-1:-1,-1:module AAHimportsfrom AUXimport allfrom HCMimport allexportsexport alldefinitionsstate AAHof[active_axes'set of (RotAxis), ignore_hcm'set of (RotAxis), toggle'EngageState, timeout'nat]	init s == (s = mk_AAH({}, {}, <AAH_off>, 0))static private EngageState = (<AAH_closing> | <AAH_off> | <AAH_on> | <AAH_started> | <pressed_once> | <pressed_twice>)static private click_timeout'nat = 10Transition (ControlButton * SixDofCommand * nat ==> ())	Transition(button_pos, hcm_cmd, clock) ==let private value engage'EngageStateprivate value starting'bool in (active_axes '= {a | [a in set AUX`rot_axis_set] & (starting or ((engage <> <AAH_off>) and ((a in set active_axes) and (((hcm_cmd.rot)(a) = <Zero>) or (a in set ignore_hcm)))))};ignore_hcm '= {a | [a in set AUX`rot_axis_set] & ((starting and ((hcm_cmd.rot)(a) <> <Zero>)) or ((not starting) and (a in set ignore_hcm)))};timeout '= (if ((toggle = <AAH_on>) and (engage = <pressed_once>))then (clock + click_timeout)else timeout);toggle '= engage)ActiveAxes (() ==> set of (RotAxis))	ActiveAxes() ==return (active_axes)IgnoreHcm (() ==> set of (RotAxis))	IgnoreHcm() ==return (ignore_hcm)Toggle (() ==> EngageState)	Toggle() ==return (toggle)AllAxesOff' (set of (RotAxis) +> bool)	AllAxesOff(active) ==(active = {})ButtonTransition' (EngageState * ControlButton * set of (RotAxis) * nat * nat +> EngageState)	ButtonTransition(estate, button, active, clock, timeout) ==(cases mk_(estate, button) 'case mk_(<AAH_off>, <Up>) -> <AAH_off>,case mk_(<AAH_off>, <Down>) -> <AAH_started>,case mk_(<AAH_started>, <Up>) -> <AAH_on>,case mk_(<AAH_started>, <Down>) -> <AAH_started>,case mk_(<AAH_on>, <Up>) -> (if AllAxesOff(active)then <AAH_off>else <AAH_on>),case mk_(<AAH_on>, <Down>) -> <pressed_once>,case mk_(<pressed_once>, <Up>) -> <AAH_closing>,case mk_(<pressed_once>, <Down>) -> <pressed_once>,case mk_(<AAH_closing>, <Up>) -> (if AllAxesOff(active)then <AAH_off>elseif (clock > timeout)then <AAH_on>else <AAH_closing>),case mk_(<AAH_closing>, <Down>) -> <pressed_twice>,case mk_(<pressed_twice>, <Up>) -> <AAH_off>,case mk_(<pressed_twice>, <Down>) -> <pressed_twice>end)end AAH, dlmodule GUIexportsexport operation GetCommand'(() ==> seq of (seq of (char)))export operation GUI_Init_Tcl'(() ==> ())uselib "my_gui.so"end GUI, module SAFERimportsfrom AUXimport allfrom HCMimport allfrom TSimport allfrom AAHimport allexportsexport alldefinitionsstate SAFERof[clock'nat]	init s == (s = mk_SAFER(0))ControlCycle (SwitchPositions * HandGripPosition * RotCommand ==> ThrusterSet)	ControlCycle(mk_SwitchPositions(mode, aah), raw_grip, aah_cmd) ==let private value grip_cmd'SixDofCommandprivate value thrusters'ThrusterSet in (Transition(aah, grip_cmd, clock);clock '= (clock + 1);return (thrusters))	post (((card RESULT) <= 4) and ThrusterConsistency(RESULT))ThrusterConsistency' (set of (ThrusterName) +> bool)	ThrusterConsistency(thrusters) ==((not ({<B1>, <F1>} subset thrusters)) and ((not ({<B2>, <F2>} subset thrusters)) and ((not ({<B3>, <F3>} subset thrusters)) and ((not ({<B4>, <F4>} subset thrusters)) and ((not (((thrusters inter {<L1R>, <L1F>}) <> {}) and ((thrusters inter {<R2R>, <R2F>}) <> {}))) and ((not (((thrusters inter {<L3R>, <L3F>}) <> {}) and ((thrusters inter {<R4R>, <R4F>}) <> {}))) and ((not (((thrusters inter {<D1R>, <D1F>}) <> {}) and ((thrusters inter {<U3R>, <U3F>}) <> {}))) and (not (((thrusters inter {<D2R>, <D2F>}) <> {}) and ((thrusters inter {<U4R>, <U4F>}) <> {}))))))))))end SAFER, module WorkSpaceimportsfrom SAFERimport allfrom HCMimport allfrom TSimport allfrom AUXimport allexportsexport alldefinitionsstatic private Input = seq of (nat)	inv inp == ((len inp) = 9)static private ThrusterMatrix = seq of (seq of (bool))	inv tm == (((len tm) = 4) and (forall i in set (inds tm) & ((len tm(i)) = 6)))RunControlCycle' (Input -> ThrusterMatrix)	RunControlCycle(input) ==let mk_(swpos, hgpos, rcom)'(SwitchPositions * HandGripPosition * RotCommand) = TransformInput(input) in let ts'ThrusterSet = SAFER`ControlCycle(swpos, hgpos, rcom) in GenerateThrusterMatrix(ts)TransformInput' (Input -> (SwitchPositions * HandGripPosition * RotCommand))	TransformInput(input) ==let [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw]'Input = input in let swpos'HCM`SwitchPositions = mk_HCM`SwitchPositions((if (mode = 1)then <Tran>else <Rot>), (if (aah = 0)then <Up>else <Down>)), hgpos'HCM`HandGripPosition = mk_HCM`HandGripPosition(ConvertAxisCmd(vert), ConvertAxisCmd(horiz), ConvertAxisCmd(trans), ConvertAxisCmd(twist)), rcom'map ((<Pitch> | <Roll> | <Yaw>)) to (AxisCommand) = {<Roll> |-> ConvertAxisCmd(roll), <Pitch> |-> ConvertAxisCmd(pitch), <Yaw> |-> ConvertAxisCmd(yaw)} in mk_(swpos, hgpos, rcom)ConvertAxisCmd' (nat -> AxisCommand)	ConvertAxisCmd(n) ==(cases n 'case 0 -> <Neg>,case 1 -> <Pos>,case 2 -> <Zero>others (undefined)end)GenerateThrusterMatrix' (ThrusterSet +> ThrusterMatrix)	GenerateThrusterMatrix(ts) ==let tson'set of ((nat * nat)) = {GenerateThrusterLabel(t) | [t in set ts]} in [[(mk_(j, i) in set tson) | i in set {1, ... ,6}] | j in set {1, ... ,4}]GenerateThrusterLabel' (ThrusterName +> (nat * nat))	GenerateThrusterLabel(tnm) ==(cases tnm 'case <B1> -> mk_(1, 4),case <B2> -> mk_(2, 4),case <B3> -> mk_(4, 4),case <B4> -> mk_(3, 4),case <F1> -> mk_(1, 1),case <F2> -> mk_(2, 1),case <F3> -> mk_(4, 1),case <F4> -> mk_(3, 1),case <L1R> -> mk_(1, 2),case <L1F> -> mk_(1, 3),case <R2R> -> mk_(2, 2),case <R2F> -> mk_(2, 3),case <L3R> -> mk_(4, 2),case <L3F> -> mk_(4, 3),case <R4R> -> mk_(3, 2),case <R4F> -> mk_(3, 3),case <D1R> -> mk_(1, 6),case <D1F> -> mk_(1, 5),case <D2R> -> mk_(2, 6),case <D2F> -> mk_(2, 5),case <U3R> -> mk_(4, 6),case <U3F> -> mk_(4, 5),case <U4R> -> mk_(3, 6),case <U4F> -> mk_(3, 5)end)static private switchpos'HCM`SwitchPositions = mk_HCM`SwitchPositions(<Tran>, <Down>)static private handgrippos'HCM`HandGripPosition = mk_HCM`HandGripPosition(<Zero>, <Pos>, <Zero>, <Zero>)static private rotcomm'map ((<Pitch> | <Roll> | <Yaw>)) to (<Zero>) = {<Roll> |-> <Zero>, <Pitch> |-> <Zero>, <Yaw> |-> <Zero>}end WorkSpace, module TESTimportsfrom SAFERimport allfrom HCMimport allfrom TSimport allfrom AUXimport allfrom GEOMimport operation InitGeom'(() ==> ())import operation ShowThrust'(seq of (seq of (char)) ==> ())from GUIimport operation GetCommand'(() ==> seq of (seq of (char)))import operation GUI_Init_Tcl'(() ==> ())exportsexport alldefinitionsstatic private switches_tran_up'HCM`SwitchPositions = mk_HCM`SwitchPositions(<Tran>, <Up>)static private switch_positions'set of (SwitchPositions) = {mk_HCM`SwitchPositions(mode, aah) | [mode in set {<Tran>, <Rot>}, aah in set {<Up>, <Down>}]}static private zero_grip'HandGripPosition = mk_HCM`HandGripPosition(<Zero>, <Zero>, <Zero>, <Zero>)static private all_grip_positions'set of (HandGripPosition) = {mk_HCM`HandGripPosition(vert, horiz, trans, twist) | [vert, horiz, trans, twist in set AUX`axis_command_set]}static private all_rot_commands'set of (RotCommand) = {{<Roll> |-> a, <Pitch> |-> b, <Yaw> |-> c} | [a, b, c in set AUX`axis_command_set]}static private grip_positions'set of (HandGripPosition) = {mk_HCM`HandGripPosition(vert, horiz, trans, twist) | [vert, horiz, trans, twist in set AUX`axis_command_set] & (((vert = <Zero>) and ((horiz = <Zero>) and (trans = <Zero>))) or (((vert = <Zero>) and ((horiz = <Zero>) and (twist = <Zero>))) or (((vert = <Zero>) and ((trans = <Zero>) and (twist = <Zero>))) or ((horiz = <Zero>) and ((trans = <Zero>) and (twist = <Zero>))))))}static private possibilities'set of ((SwitchPositions * HandGripPosition * RotCommand)) = {mk_(switch, grip, aah_law) | [switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands]}BigTest' (() -> map ((SwitchPositions * HandGripPosition * RotCommand)) to (ThrusterSet))	BigTest() =={mk_(switch, grip, aah_law) |-> SAFER`ControlCycle(switch, grip, aah_law) | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands}HugeTest' (() -> map ((SwitchPositions * HandGripPosition * RotCommand)) to (ThrusterSet))	HugeTest() =={mk_(switch, grip, aah_law) |-> SAFER`ControlCycle(switch, grip, aah_law) | switch in set switch_positions, grip in set all_grip_positions, aah_law in set all_rot_commands}ConvertAxisCmd' (seq of (char) -> AxisCommand)	ConvertAxisCmd(str) ==(cases str 'case "neg" -> <Neg>,case "pos" -> <Pos>,case "zero" -> <Zero>others (undefined)end)ConvertTIds' (ThrusterSet +> seq of (seq of (char)))	ConvertTIds(ts) ==(if (ts = {})then []else let t in set ts in ([ConvertTId(t)] ^ ConvertTIds((ts \ {t}))))ConvertTId' (ThrusterName +> seq of (char))	ConvertTId(tnm) ==(cases tnm 'case <B1> -> "B1",case <B2> -> "B2",case <B3> -> "B3",case <B4> -> "B4",case <F1> -> "F1",case <F2> -> "F2",case <F3> -> "F3",case <F4> -> "F4",case <L1R> -> "L1R",case <L1F> -> "L1F",case <R2R> -> "R2R",case <R2F> -> "R2F",case <L3R> -> "L3R",case <L3F> -> "L3F",case <R4R> -> "R4R",case <R4F> -> "R4F",case <D1R> -> "D1R",case <D1F> -> "D1F",case <D2R> -> "D2R",case <D2F> -> "D2F",case <U3R> -> "U3R",case <U3F> -> "U3F",case <U4R> -> "U4R",case <U4F> -> "U4F"end)StartTest (() ==> ())	StartTest() ==(GUI_Init_Tcl();InitGeom())RunTest (() ==> bool)	RunTest() ==let private value cl'seq of (seq of (char)) in if (cl = [])thenreturn (false)elselet private value mode, aah, horiz, trans, vert, twist, roll, pitch, yaw'seq of (seq of (char))private value ts'ThrusterSet in (ShowThrust(ConvertTIds(ts));return (true))Loop (() ==> ())	Loop() ==(StartTest();while RunTest() do skip;ShowThrust(["stop"]))Move (() ==> ())	Move() ==ShowThrust(["move"])NoMove (() ==> ())	NoMove() ==ShowThrust(["nomove"])end TEST, module HCMimportsfrom AUXimport allexportsexport alldefinitionsstatic private SwitchPositions = compose SwitchPositions of mode'ControlModeSwitch, aah'ControlButton endstatic private ControlModeSwitch = (<Rot> | <Tran>)static private ControlButton = (<Down> | <Up>)static private HandGripPosition = compose HandGripPosition of vert'AxisCommand, horiz'AxisCommand, trans'AxisCommand, twist'AxisCommand endGripCommand' (HandGripPosition * ControlModeSwitch +> SixDofCommand)	GripCommand(mk_HandGripPosition(vert, horiz, trans, twist), mode) ==let tran'map ((<X> | <Y> | <Z>)) to ((<Zero> | AxisCommand)) = {<X> |-> horiz, <Y> |-> (if (mode = <Tran>)then transelse <Zero>), <Z> |-> (if (mode = <Tran>)then vertelse <Zero>)}, rot'map ((<Pitch> | <Roll> | <Yaw>)) to ((<Zero> | AxisCommand)) = {<Roll> |-> (if (mode = <Rot>)then vertelse <Zero>), <Pitch> |-> twist, <Yaw> |-> (if (mode = <Rot>)then transelse <Zero>)} in mk_AUX`SixDofCommand(tran, rot)end HCM, module TSimportsfrom AUXimport allfrom AAHimport allexportsexport alldefinitionsstatic private ThrusterName = (<B1> | <B2> | <B3> | <B4> | <D1F> | <D1R> | <D2F> | <D2R> | <F1> | <F2> | <F3> | <F4> | <L1F> | <L1R> | <L3F> | <L3R> | <R2F> | <R2R> | <R4F> | <R4R> | <U3F> | <U3R> | <U4F> | <U4R>)static private ThrusterSet = set of (ThrusterName)RotCmdsPresent' (RotCommand +> bool)	RotCmdsPresent(cmd) ==(exists [a in set (dom cmd)] & (cmd(a) <> <Zero>))PrioritizedTranCmd' (TranCommand +> TranCommand)	PrioritizedTranCmd(tran) ==(if (tran(<X>) <> <Zero>)then (AUX`null_tran_command ++ {<X> |-> tran(<X>)})elseif (tran(<Y>) <> <Zero>)then (AUX`null_tran_command ++ {<Y> |-> tran(<Y>)})elseif (tran(<Z>) <> <Zero>)then (AUX`null_tran_command ++ {<Z> |-> tran(<Z>)})else AUX`null_tran_command)CombinedRotCmds' (RotCommand * RotCommand * set of (RotAxis) +> RotCommand)	CombinedRotCmds(hcm_rot, aah, ignore_hcm) ==let aah_axes'set of (RotAxis) = (ignore_hcm union {a | [a in set AUX`rot_axis_set] & (hcm_rot(a) = <Zero>)}) in ({a |-> aah(a) | a in set aah_axes} munion {a |-> hcm_rot(a) | a in set (AUX`rot_axis_set \ aah_axes)})IntegratedCommands' (SixDofCommand * RotCommand * set of (RotAxis) * set of (RotAxis) +> SixDofCommand)	IntegratedCommands(mk_SixDofCommand(tran, rot), aah, active_axes, ignore_hcm) ==(if AAH`AllAxesOff(active_axes)then (if RotCmdsPresent(rot)then mk_AUX`SixDofCommand(AUX`null_tran_command, rot)else mk_AUX`SixDofCommand(PrioritizedTranCmd(tran), AUX`null_rot_command))else (if RotCmdsPresent(rot)then mk_AUX`SixDofCommand(AUX`null_tran_command, CombinedRotCmds(rot, aah, ignore_hcm))else mk_AUX`SixDofCommand(PrioritizedTranCmd(tran), aah)))BFThrusters' (AxisCommand * AxisCommand * AxisCommand +> (ThrusterSet * ThrusterSet))	BFThrusters(A, B, C) ==(cases mk_(A, B, C) 'case mk_(<Neg>, <Neg>, <Neg>) -> mk_({<B4>}, {<B2>, <B3>}),case mk_(<Neg>, <Neg>, <Zero>) -> mk_({<B3>, <B4>}, {}),case mk_(<Neg>, <Neg>, <Pos>) -> mk_({<B3>}, {<B1>, <B4>}),case mk_(<Neg>, <Zero>, <Neg>) -> mk_({<B2>, <B4>}, {}),case mk_(<Neg>, <Zero>, <Zero>) -> mk_({<B1>, <B4>}, {<B2>, <B3>}),case mk_(<Neg>, <Zero>, <Pos>) -> mk_({<B1>, <B3>}, {}),case mk_(<Neg>, <Pos>, <Neg>) -> mk_({<B2>}, {<B1>, <B4>}),case mk_(<Neg>, <Pos>, <Zero>) -> mk_({<B1>, <B2>}, {}),case mk_(<Neg>, <Pos>, <Pos>) -> mk_({<B1>}, {<B2>, <B3>}),case mk_(<Zero>, <Neg>, <Neg>) -> mk_({<B4>, <F1>}, {}),case mk_(<Zero>, <Neg>, <Zero>) -> mk_({<B4>, <F2>}, {}),case mk_(<Zero>, <Neg>, <Pos>) -> mk_({<B3>, <F2>}, {}),case mk_(<Zero>, <Zero>, <Neg>) -> mk_({<B2>, <F1>}, {}),case mk_(<Zero>, <Zero>, <Zero>) -> mk_({}, {}),case mk_(<Zero>, <Zero>, <Pos>) -> mk_({<B3>, <F4>}, {}),case mk_(<Zero>, <Pos>, <Neg>) -> mk_({<B2>, <F3>}, {}),case mk_(<Zero>, <Pos>, <Zero>) -> mk_({<B1>, <F3>}, {}),case mk_(<Zero>, <Pos>, <Pos>) -> mk_({<B1>, <F4>}, {}),case mk_(<Pos>, <Neg>, <Neg>) -> mk_({<F1>}, {<F2>, <F3>}),case mk_(<Pos>, <Neg>, <Zero>) -> mk_({<F1>, <F2>}, {}),case mk_(<Pos>, <Neg>, <Pos>) -> mk_({<F2>}, {<F1>, <F4>}),case mk_(<Pos>, <Zero>, <Neg>) -> mk_({<F1>, <F3>}, {}),case mk_(<Pos>, <Zero>, <Zero>) -> mk_({<F2>, <F3>}, {<F1>, <F4>}),case mk_(<Pos>, <Zero>, <Pos>) -> mk_({<F2>, <F4>}, {}),case mk_(<Pos>, <Pos>, <Neg>) -> mk_({<F3>}, {<F1>, <F4>}),case mk_(<Pos>, <Pos>, <Zero>) -> mk_({<F3>, <F4>}, {}),case mk_(<Pos>, <Pos>, <Pos>) -> mk_({<F4>}, {<F2>, <F3>})end)LRUDThrusters' (AxisCommand * AxisCommand * AxisCommand +> (ThrusterSet * ThrusterSet))	LRUDThrusters(A, B, C) ==(cases mk_(A, B, C) 'case mk_(<Neg>, <Neg>, <Neg>) -> mk_({}, {}),case mk_(<Neg>, <Neg>, <Zero>) -> mk_({}, {}),case mk_(<Neg>, <Neg>, <Pos>) -> mk_({}, {}),case mk_(<Neg>, <Zero>, <Neg>) -> mk_({<L1R>}, {<L1F>, <L3F>}),case mk_(<Neg>, <Zero>, <Zero>) -> mk_({<L1R>, <L3R>}, {<L1F>, <L3F>}),case mk_(<Neg>, <Zero>, <Pos>) -> mk_({<L3R>}, {<L1F>, <L3F>}),case mk_(<Neg>, <Pos>, <Neg>) -> mk_({}, {}),case mk_(<Neg>, <Pos>, <Zero>) -> mk_({}, {}),case mk_(<Neg>, <Pos>, <Pos>) -> mk_({}, {}),case mk_(<Zero>, <Neg>, <Neg>) -> mk_({<U3R>}, {<U3F>, <U4F>}),case mk_(<Zero>, <Neg>, <Zero>) -> mk_({<U3R>, <U4R>}, {<U3F>, <U4F>}),case mk_(<Zero>, <Neg>, <Pos>) -> mk_({<U4R>}, {<U3F>, <U4F>}),case mk_(<Zero>, <Zero>, <Neg>) -> mk_({<L1R>, <R4R>}, {}),case mk_(<Zero>, <Zero>, <Zero>) -> mk_({}, {}),case mk_(<Zero>, <Zero>, <Pos>) -> mk_({<R2R>, <L3R>}, {}),case mk_(<Zero>, <Pos>, <Neg>) -> mk_({<D2R>}, {<D1F>, <D2F>}),case mk_(<Zero>, <Pos>, <Zero>) -> mk_({<D1R>, <D2R>}, {<D1F>, <D2F>}),case mk_(<Zero>, <Pos>, <Pos>) -> mk_({<D1R>}, {<D1F>, <D2F>}),case mk_(<Pos>, <Neg>, <Neg>) -> mk_({}, {}),case mk_(<Pos>, <Neg>, <Zero>) -> mk_({}, {}),case mk_(<Pos>, <Neg>, <Pos>) -> mk_({}, {}),case mk_(<Pos>, <Zero>, <Neg>) -> mk_({<R4R>}, {<R2F>, <R4F>}),case mk_(<Pos>, <Zero>, <Zero>) -> mk_({<R2R>, <R4R>}, {<R2F>, <R4F>}),case mk_(<Pos>, <Zero>, <Pos>) -> mk_({<R2R>}, {<R2F>, <R4F>}),case mk_(<Pos>, <Pos>, <Neg>) -> mk_({}, {}),case mk_(<Pos>, <Pos>, <Zero>) -> mk_({}, {}),case mk_(<Pos>, <Pos>, <Pos>) -> mk_({}, {})end)SelectedThrusters' (SixDofCommand * RotCommand * set of (RotAxis) * set of (RotAxis) +> ThrusterSet)	SelectedThrusters(hcm, aah, active_axes, ignore_hcm) ==let mk_SixDofCommand(tran, rot)'SixDofCommand = IntegratedCommands(hcm, aah, active_axes, ignore_hcm), mk_(bf_mandatory, bf_optional)'(ThrusterSet * ThrusterSet) = BFThrusters(tran(<X>), rot(<Pitch>), rot(<Yaw>)), mk_(lrud_mandatory, lrud_optional)'(ThrusterSet * ThrusterSet) = LRUDThrusters(tran(<Y>), tran(<Z>), rot(<Roll>)), bf_thr'ThrusterSet = (if (rot(<Roll>) = <Zero>)then (bf_optional union bf_mandatory)else bf_mandatory), lrud_thr'ThrusterSet = (if ((rot(<Pitch>) = <Zero>) and (rot(<Yaw>) = <Zero>))then (lrud_optional union lrud_mandatory)else lrud_mandatory) in (bf_thr union lrud_thr)end TS, module AUXexportsexport alldefinitionsstatic private arbitrary_value'token = mk_token(1001)static private axis_command_set'set of (AxisCommand) = {<Neg>, <Zero>, <Pos>}static private tran_axis_set'set of (TranAxis) = {<X>, <Y>, <Z>}static private rot_axis_set'set of (RotAxis) = {<Roll>, <Pitch>, <Yaw>}static private null_tran_command'TranCommand = {a |-> <Zero> | a in set tran_axis_set}static private null_rot_command'RotCommand = {a |-> <Zero> | a in set rot_axis_set}static private null_six_dof'SixDofCommand = mk_SixDofCommand(null_tran_command, null_rot_command)static private AxisCommand = (<Neg> | <Pos> | <Zero>)static private TranAxis = (<X> | <Y> | <Z>)static private RotAxis = (<Pitch> | <Roll> | <Yaw>)static private TranCommand = map (TranAxis) to (AxisCommand)	inv cmd == ((dom cmd) = tran_axis_set)static private RotCommand = map (RotAxis) to (AxisCommand)	inv cmd == ((dom cmd) = rot_axis_set)static private SixDofCommand = compose SixDofCommand of tran'TranCommand, rot'RotCommand endend AUX, dlmodule GEOMexportsexport operation InitGeom'(() ==> ())export operation ShowThrust'(seq of (seq of (char)) ==> ())uselib "geom_lib.so"end GEOM
