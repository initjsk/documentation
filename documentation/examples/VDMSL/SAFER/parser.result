WARNING:gui.vdmsl:5015:2,9:LaTeX source should start with %comment, \document, \section or \subsection
WARNING:geom.vdmsl:5015:1,9:LaTeX source should start with %comment, \document, \section or \subsection
RESULT:result:-1:-1,-1:module AAHimportsfrom AUXimport allfrom HCMimport allexportsexport alldefinitionsstate AAHof[active_axes'set of ((unresolved AUX`RotAxis)), ignore_hcm'set of ((unresolved AUX`RotAxis)), toggle'(unresolved AAH`EngageState), timeout'nat]	init s == (s = mk_AAH({}, {}, <AAH_off>, 0))static private EngageState = (<AAH_closing> | <AAH_off> | <AAH_on> | <AAH_started> | <pressed_once> | <pressed_twice>)static private click_timeout'nat = 10Transition ((unresolved HCM`ControlButton) * (unresolved AUX`SixDofCommand) * nat ==> ())	Transition(button_pos, hcm_cmd, clock) ==let private value engage'?private value starting'? in (active_axes '= {a | [a in set AUX`rot_axis_set] & (starting or ((engage <> <AAH_off>) and ((a in set active_axes) and (((hcm_cmd.rot)(a) = <Zero>) or (a in set ignore_hcm)))))};ignore_hcm '= {a | [a in set AUX`rot_axis_set] & ((starting and ((hcm_cmd.rot)(a) <> <Zero>)) or ((not starting) and (a in set ignore_hcm)))};timeout '= (if ((toggle = <AAH_on>) and (engage = <pressed_once>))then (clock + click_timeout)else timeout);toggle '= engage)ActiveAxes (() ==> set of ((unresolved AUX`RotAxis)))	ActiveAxes() ==return (active_axes)IgnoreHcm (() ==> set of ((unresolved AUX`RotAxis)))	IgnoreHcm() ==return (ignore_hcm)Toggle (() ==> (unresolved AAH`EngageState))	Toggle() ==return (toggle)AllAxesOff' (set of ((unresolved AUX`RotAxis)) +> bool)	AllAxesOff(active) ==(active = {})ButtonTransition' ((unresolved AAH`EngageState) * (unresolved HCM`ControlButton) * set of ((unresolved AUX`RotAxis)) * nat * nat +> (unresolved AAH`EngageState))	ButtonTransition(estate, button, active, clock, timeout) ==(cases mk_(estate, button) 'case mk_(<AAH_off>, <Up>) -> <AAH_off>,case mk_(<AAH_off>, <Down>) -> <AAH_started>,case mk_(<AAH_started>, <Up>) -> <AAH_on>,case mk_(<AAH_started>, <Down>) -> <AAH_started>,case mk_(<AAH_on>, <Up>) -> (if AllAxesOff(active)then <AAH_off>else <AAH_on>),case mk_(<AAH_on>, <Down>) -> <pressed_once>,case mk_(<pressed_once>, <Up>) -> <AAH_closing>,case mk_(<pressed_once>, <Down>) -> <pressed_once>,case mk_(<AAH_closing>, <Up>) -> (if AllAxesOff(active)then <AAH_off>elseif (clock > timeout)then <AAH_on>else <AAH_closing>),case mk_(<AAH_closing>, <Down>) -> <pressed_twice>,case mk_(<pressed_twice>, <Up>) -> <AAH_off>,case mk_(<pressed_twice>, <Down>) -> <pressed_twice>end)end AAH, module TSimportsfrom AUXimport allfrom AAHimport allexportsexport alldefinitionsstatic private ThrusterName = (<B1> | <B2> | <B3> | <B4> | <D1F> | <D1R> | <D2F> | <D2R> | <F1> | <F2> | <F3> | <F4> | <L1F> | <L1R> | <L3F> | <L3R> | <R2F> | <R2R> | <R4F> | <R4R> | <U3F> | <U3R> | <U4F> | <U4R>)static private ThrusterSet = set of ((unresolved TS`ThrusterName))RotCmdsPresent' ((unresolved AUX`RotCommand) +> bool)	RotCmdsPresent(cmd) ==(exists [a in set (dom cmd)] & (cmd(a) <> <Zero>))PrioritizedTranCmd' ((unresolved AUX`TranCommand) +> (unresolved AUX`TranCommand))	PrioritizedTranCmd(tran) ==(if (tran(<X>) <> <Zero>)then (AUX`null_tran_command ++ {<X> |-> tran(<X>)})elseif (tran(<Y>) <> <Zero>)then (AUX`null_tran_command ++ {<Y> |-> tran(<Y>)})elseif (tran(<Z>) <> <Zero>)then (AUX`null_tran_command ++ {<Z> |-> tran(<Z>)})else AUX`null_tran_command)CombinedRotCmds' ((unresolved AUX`RotCommand) * (unresolved AUX`RotCommand) * set of ((unresolved AUX`RotAxis)) +> (unresolved AUX`RotCommand))	CombinedRotCmds(hcm_rot, aah, ignore_hcm) ==let aah_axes = (ignore_hcm union {a | [a in set AUX`rot_axis_set] & (hcm_rot(a) = <Zero>)}) in ({a |-> aah(a) | a in set aah_axes} munion {a |-> hcm_rot(a) | a in set (AUX`rot_axis_set \ aah_axes)})IntegratedCommands' ((unresolved AUX`SixDofCommand) * (unresolved AUX`RotCommand) * set of ((unresolved AUX`RotAxis)) * set of ((unresolved AUX`RotAxis)) +> (unresolved AUX`SixDofCommand))	IntegratedCommands(mk_(unresolved AUX`SixDofCommand)(tran, rot), aah, active_axes, ignore_hcm) ==(if AAH`AllAxesOff(active_axes)then (if RotCmdsPresent(rot)then mk_AUX`SixDofCommand(AUX`null_tran_command, rot)else mk_AUX`SixDofCommand(PrioritizedTranCmd(tran), AUX`null_rot_command))else (if RotCmdsPresent(rot)then mk_AUX`SixDofCommand(AUX`null_tran_command, CombinedRotCmds(rot, aah, ignore_hcm))else mk_AUX`SixDofCommand(PrioritizedTranCmd(tran), aah)))BFThrusters' ((unresolved AUX`AxisCommand) * (unresolved AUX`AxisCommand) * (unresolved AUX`AxisCommand) +> ((unresolved TS`ThrusterSet) * (unresolved TS`ThrusterSet)))	BFThrusters(A, B, C) ==(cases mk_(A, B, C) 'case mk_(<Neg>, <Neg>, <Neg>) -> mk_({<B4>}, {<B2>, <B3>}),case mk_(<Neg>, <Neg>, <Zero>) -> mk_({<B3>, <B4>}, {}),case mk_(<Neg>, <Neg>, <Pos>) -> mk_({<B3>}, {<B1>, <B4>}),case mk_(<Neg>, <Zero>, <Neg>) -> mk_({<B2>, <B4>}, {}),case mk_(<Neg>, <Zero>, <Zero>) -> mk_({<B1>, <B4>}, {<B2>, <B3>}),case mk_(<Neg>, <Zero>, <Pos>) -> mk_({<B1>, <B3>}, {}),case mk_(<Neg>, <Pos>, <Neg>) -> mk_({<B2>}, {<B1>, <B4>}),case mk_(<Neg>, <Pos>, <Zero>) -> mk_({<B1>, <B2>}, {}),case mk_(<Neg>, <Pos>, <Pos>) -> mk_({<B1>}, {<B2>, <B3>}),case mk_(<Zero>, <Neg>, <Neg>) -> mk_({<B4>, <F1>}, {}),case mk_(<Zero>, <Neg>, <Zero>) -> mk_({<B4>, <F2>}, {}),case mk_(<Zero>, <Neg>, <Pos>) -> mk_({<B3>, <F2>}, {}),case mk_(<Zero>, <Zero>, <Neg>) -> mk_({<B2>, <F1>}, {}),case mk_(<Zero>, <Zero>, <Zero>) -> mk_({}, {}),case mk_(<Zero>, <Zero>, <Pos>) -> mk_({<B3>, <F4>}, {}),case mk_(<Zero>, <Pos>, <Neg>) -> mk_({<B2>, <F3>}, {}),case mk_(<Zero>, <Pos>, <Zero>) -> mk_({<B1>, <F3>}, {}),case mk_(<Zero>, <Pos>, <Pos>) -> mk_({<B1>, <F4>}, {}),case mk_(<Pos>, <Neg>, <Neg>) -> mk_({<F1>}, {<F2>, <F3>}),case mk_(<Pos>, <Neg>, <Zero>) -> mk_({<F1>, <F2>}, {}),case mk_(<Pos>, <Neg>, <Pos>) -> mk_({<F2>}, {<F1>, <F4>}),case mk_(<Pos>, <Zero>, <Neg>) -> mk_({<F1>, <F3>}, {}),case mk_(<Pos>, <Zero>, <Zero>) -> mk_({<F2>, <F3>}, {<F1>, <F4>}),case mk_(<Pos>, <Zero>, <Pos>) -> mk_({<F2>, <F4>}, {}),case mk_(<Pos>, <Pos>, <Neg>) -> mk_({<F3>}, {<F1>, <F4>}),case mk_(<Pos>, <Pos>, <Zero>) -> mk_({<F3>, <F4>}, {}),case mk_(<Pos>, <Pos>, <Pos>) -> mk_({<F4>}, {<F2>, <F3>})end)LRUDThrusters' ((unresolved AUX`AxisCommand) * (unresolved AUX`AxisCommand) * (unresolved AUX`AxisCommand) +> ((unresolved TS`ThrusterSet) * (unresolved TS`ThrusterSet)))	LRUDThrusters(A, B, C) ==(cases mk_(A, B, C) 'case mk_(<Neg>, <Neg>, <Neg>) -> mk_({}, {}),case mk_(<Neg>, <Neg>, <Zero>) -> mk_({}, {}),case mk_(<Neg>, <Neg>, <Pos>) -> mk_({}, {}),case mk_(<Neg>, <Zero>, <Neg>) -> mk_({<L1R>}, {<L1F>, <L3F>}),case mk_(<Neg>, <Zero>, <Zero>) -> mk_({<L1R>, <L3R>}, {<L1F>, <L3F>}),case mk_(<Neg>, <Zero>, <Pos>) -> mk_({<L3R>}, {<L1F>, <L3F>}),case mk_(<Neg>, <Pos>, <Neg>) -> mk_({}, {}),case mk_(<Neg>, <Pos>, <Zero>) -> mk_({}, {}),case mk_(<Neg>, <Pos>, <Pos>) -> mk_({}, {}),case mk_(<Zero>, <Neg>, <Neg>) -> mk_({<U3R>}, {<U3F>, <U4F>}),case mk_(<Zero>, <Neg>, <Zero>) -> mk_({<U3R>, <U4R>}, {<U3F>, <U4F>}),case mk_(<Zero>, <Neg>, <Pos>) -> mk_({<U4R>}, {<U3F>, <U4F>}),case mk_(<Zero>, <Zero>, <Neg>) -> mk_({<L1R>, <R4R>}, {}),case mk_(<Zero>, <Zero>, <Zero>) -> mk_({}, {}),case mk_(<Zero>, <Zero>, <Pos>) -> mk_({<R2R>, <L3R>}, {}),case mk_(<Zero>, <Pos>, <Neg>) -> mk_({<D2R>}, {<D1F>, <D2F>}),case mk_(<Zero>, <Pos>, <Zero>) -> mk_({<D1R>, <D2R>}, {<D1F>, <D2F>}),case mk_(<Zero>, <Pos>, <Pos>) -> mk_({<D1R>}, {<D1F>, <D2F>}),case mk_(<Pos>, <Neg>, <Neg>) -> mk_({}, {}),case mk_(<Pos>, <Neg>, <Zero>) -> mk_({}, {}),case mk_(<Pos>, <Neg>, <Pos>) -> mk_({}, {}),case mk_(<Pos>, <Zero>, <Neg>) -> mk_({<R4R>}, {<R2F>, <R4F>}),case mk_(<Pos>, <Zero>, <Zero>) -> mk_({<R2R>, <R4R>}, {<R2F>, <R4F>}),case mk_(<Pos>, <Zero>, <Pos>) -> mk_({<R2R>}, {<R2F>, <R4F>}),case mk_(<Pos>, <Pos>, <Neg>) -> mk_({}, {}),case mk_(<Pos>, <Pos>, <Zero>) -> mk_({}, {}),case mk_(<Pos>, <Pos>, <Pos>) -> mk_({}, {})end)SelectedThrusters' ((unresolved AUX`SixDofCommand) * (unresolved AUX`RotCommand) * set of ((unresolved AUX`RotAxis)) * set of ((unresolved AUX`RotAxis)) +> (unresolved TS`ThrusterSet))	SelectedThrusters(hcm, aah, active_axes, ignore_hcm) ==let mk_(unresolved AUX`SixDofCommand)(tran, rot) = IntegratedCommands(hcm, aah, active_axes, ignore_hcm), mk_(bf_mandatory, bf_optional) = BFThrusters(tran(<X>), rot(<Pitch>), rot(<Yaw>)), mk_(lrud_mandatory, lrud_optional) = LRUDThrusters(tran(<Y>), tran(<Z>), rot(<Roll>)), bf_thr = (if (rot(<Roll>) = <Zero>)then (bf_optional union bf_mandatory)else bf_mandatory), lrud_thr = (if ((rot(<Pitch>) = <Zero>) and (rot(<Yaw>) = <Zero>))then (lrud_optional union lrud_mandatory)else lrud_mandatory) in (bf_thr union lrud_thr)end TS, module SAFERimportsfrom AUXimport allfrom HCMimport allfrom TSimport allfrom AAHimport allexportsexport alldefinitionsstate SAFERof[clock'nat]	init s == (s = mk_SAFER(0))ControlCycle ((unresolved HCM`SwitchPositions) * (unresolved HCM`HandGripPosition) * (unresolved AUX`RotCommand) ==> (unresolved TS`ThrusterSet))	ControlCycle(mk_(unresolved HCM`SwitchPositions)(mode, aah), raw_grip, aah_cmd) ==let private value grip_cmd'?private value thrusters'? in (Transition(aah, grip_cmd, clock);clock '= (clock + 1);return (thrusters))	post (((card RESULT) <= 4) and ThrusterConsistency(RESULT))ThrusterConsistency' (set of ((unresolved TS`ThrusterName)) +> bool)	ThrusterConsistency(thrusters) ==((not ({<B1>, <F1>} subset thrusters)) and ((not ({<B2>, <F2>} subset thrusters)) and ((not ({<B3>, <F3>} subset thrusters)) and ((not ({<B4>, <F4>} subset thrusters)) and ((not (((thrusters inter {<L1R>, <L1F>}) <> {}) and ((thrusters inter {<R2R>, <R2F>}) <> {}))) and ((not (((thrusters inter {<L3R>, <L3F>}) <> {}) and ((thrusters inter {<R4R>, <R4F>}) <> {}))) and ((not (((thrusters inter {<D1R>, <D1F>}) <> {}) and ((thrusters inter {<U3R>, <U3F>}) <> {}))) and (not (((thrusters inter {<D2R>, <D2F>}) <> {}) and ((thrusters inter {<U4R>, <U4F>}) <> {}))))))))))end SAFER, module AUXexportsexport alldefinitionsstatic private arbitrary_value = mk_token(1001)static private axis_command_set'set of ((unresolved AUX`AxisCommand)) = {<Neg>, <Zero>, <Pos>}static private tran_axis_set'set of ((unresolved AUX`TranAxis)) = {<X>, <Y>, <Z>}static private rot_axis_set'set of ((unresolved AUX`RotAxis)) = {<Roll>, <Pitch>, <Yaw>}static private null_tran_command'(unresolved AUX`TranCommand) = {a |-> <Zero> | a in set tran_axis_set}static private null_rot_command'(unresolved AUX`RotCommand) = {a |-> <Zero> | a in set rot_axis_set}static private null_six_dof'(unresolved AUX`SixDofCommand) = mk_SixDofCommand(null_tran_command, null_rot_command)static private AxisCommand = (<Neg> | <Pos> | <Zero>)static private TranAxis = (<X> | <Y> | <Z>)static private RotAxis = (<Pitch> | <Roll> | <Yaw>)static private TranCommand = map ((unresolved AUX`TranAxis)) to ((unresolved AUX`AxisCommand))	inv cmd == ((dom cmd) = tran_axis_set)static private RotCommand = map ((unresolved AUX`RotAxis)) to ((unresolved AUX`AxisCommand))	inv cmd == ((dom cmd) = rot_axis_set)static private SixDofCommand = compose SixDofCommand of tran'(unresolved AUX`TranCommand), rot'(unresolved AUX`RotCommand) endend AUX, dlmodule GUIexportsexport operation GetCommand'(() ==> seq of (seq of (char)))export operation GUI_Init_Tcl'(() ==> ())uselib "my_gui.so"end GUI, dlmodule GEOMexportsexport operation InitGeom'(() ==> ())export operation ShowThrust'(seq of (seq of (char)) ==> ())uselib "geom_lib.so"end GEOM, module TESTimportsfrom SAFERimport allfrom HCMimport allfrom TSimport allfrom AUXimport allfrom GEOMimport operation InitGeom'(() ==> ())import operation ShowThrust'(seq of (seq of (char)) ==> ())from GUIimport operation GetCommand'(() ==> seq of (seq of (char)))import operation GUI_Init_Tcl'(() ==> ())exportsexport alldefinitionsstatic private switches_tran_up = mk_HCM`SwitchPositions(<Tran>, <Up>)static private switch_positions'set of ((unresolved HCM`SwitchPositions)) = {mk_HCM`SwitchPositions(mode, aah) | [mode in set {<Tran>, <Rot>}, aah in set {<Up>, <Down>}]}static private zero_grip'(unresolved HCM`HandGripPosition) = mk_HCM`HandGripPosition(<Zero>, <Zero>, <Zero>, <Zero>)static private all_grip_positions'set of ((unresolved HCM`HandGripPosition)) = {mk_HCM`HandGripPosition(vert, horiz, trans, twist) | [vert, horiz, trans, twist in set AUX`axis_command_set]}static private all_rot_commands'set of ((unresolved AUX`RotCommand)) = {{<Roll> |-> a, <Pitch> |-> b, <Yaw> |-> c} | [a, b, c in set AUX`axis_command_set]}static private grip_positions'set of ((unresolved HCM`HandGripPosition)) = {mk_HCM`HandGripPosition(vert, horiz, trans, twist) | [vert, horiz, trans, twist in set AUX`axis_command_set] & (((vert = <Zero>) and ((horiz = <Zero>) and (trans = <Zero>))) or (((vert = <Zero>) and ((horiz = <Zero>) and (twist = <Zero>))) or (((vert = <Zero>) and ((trans = <Zero>) and (twist = <Zero>))) or ((horiz = <Zero>) and ((trans = <Zero>) and (twist = <Zero>))))))}static private possibilities'set of ((((unresolved HCM`SwitchPositions) * (unresolved HCM`HandGripPosition) * (unresolved AUX`RotCommand)))) = {mk_(switch, grip, aah_law) | [switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands]}BigTest' (() -> map ((((unresolved HCM`SwitchPositions) * (unresolved HCM`HandGripPosition) * (unresolved AUX`RotCommand)))) to ((unresolved TS`ThrusterSet)))	BigTest() =={mk_(switch, grip, aah_law) |-> SAFER`ControlCycle(switch, grip, aah_law) | switch in set switch_positions, grip in set grip_positions, aah_law in set all_rot_commands}HugeTest' (() -> map ((((unresolved HCM`SwitchPositions) * (unresolved HCM`HandGripPosition) * (unresolved AUX`RotCommand)))) to ((unresolved TS`ThrusterSet)))	HugeTest() =={mk_(switch, grip, aah_law) |-> SAFER`ControlCycle(switch, grip, aah_law) | switch in set switch_positions, grip in set all_grip_positions, aah_law in set all_rot_commands}ConvertAxisCmd' (seq of (char) -> (unresolved AUX`AxisCommand))	ConvertAxisCmd(str) ==(cases str 'case "neg" -> <Neg>,case "pos" -> <Pos>,case "zero" -> <Zero>others (undefined)end)ConvertTIds' ((unresolved TS`ThrusterSet) +> seq of (seq of (char)))	ConvertTIds(ts) ==(if (ts = {})then []else let t in set ts in ([ConvertTId(t)] ^ ConvertTIds((ts \ {t}))))ConvertTId' ((unresolved TS`ThrusterName) +> seq of (char))	ConvertTId(tnm) ==(cases tnm 'case <B1> -> "B1",case <B2> -> "B2",case <B3> -> "B3",case <B4> -> "B4",case <F1> -> "F1",case <F2> -> "F2",case <F3> -> "F3",case <F4> -> "F4",case <L1R> -> "L1R",case <L1F> -> "L1F",case <R2R> -> "R2R",case <R2F> -> "R2F",case <L3R> -> "L3R",case <L3F> -> "L3F",case <R4R> -> "R4R",case <R4F> -> "R4F",case <D1R> -> "D1R",case <D1F> -> "D1F",case <D2R> -> "D2R",case <D2F> -> "D2F",case <U3R> -> "U3R",case <U3F> -> "U3F",case <U4R> -> "U4R",case <U4F> -> "U4F"end)StartTest (() ==> ())	StartTest() ==(GUI_Init_Tcl();InitGeom())RunTest (() ==> bool)	RunTest() ==let private value cl'? in if (cl = [])thenreturn (false)elselet private value mode, aah, horiz, trans, vert, twist, roll, pitch, yaw'?private value ts'? in (ShowThrust(ConvertTIds(ts));return (true))Loop (() ==> ())	Loop() ==(StartTest();while RunTest() do skip;ShowThrust(["stop"]))Move (() ==> ())	Move() ==ShowThrust(["move"])NoMove (() ==> ())	NoMove() ==ShowThrust(["nomove"])end TEST, module HCMimportsfrom AUXimport allexportsexport alldefinitionsstatic private SwitchPositions = compose SwitchPositions of mode'(unresolved HCM`ControlModeSwitch), aah'(unresolved HCM`ControlButton) endstatic private ControlModeSwitch = (<Rot> | <Tran>)static private ControlButton = (<Down> | <Up>)static private HandGripPosition = compose HandGripPosition of vert'(unresolved AUX`AxisCommand), horiz'(unresolved AUX`AxisCommand), trans'(unresolved AUX`AxisCommand), twist'(unresolved AUX`AxisCommand) endGripCommand' ((unresolved HCM`HandGripPosition) * (unresolved HCM`ControlModeSwitch) +> (unresolved AUX`SixDofCommand))	GripCommand(mk_(unresolved HCM`HandGripPosition)(vert, horiz, trans, twist), mode) ==let tran = {<X> |-> horiz, <Y> |-> (if (mode = <Tran>)then transelse <Zero>), <Z> |-> (if (mode = <Tran>)then vertelse <Zero>)}, rot = {<Roll> |-> (if (mode = <Rot>)then vertelse <Zero>), <Pitch> |-> twist, <Yaw> |-> (if (mode = <Rot>)then transelse <Zero>)} in mk_AUX`SixDofCommand(tran, rot)end HCM, module WorkSpaceimportsfrom SAFERimport allfrom HCMimport allfrom TSimport allfrom AUXimport allexportsexport alldefinitionsstatic private Input = seq of (nat)	inv inp == ((len inp) = 9)static private ThrusterMatrix = seq of (seq of (bool))	inv tm == (((len tm) = 4) and (forall i in set (inds tm) & ((len tm(i)) = 6)))RunControlCycle' ((unresolved WorkSpace`Input) -> (unresolved WorkSpace`ThrusterMatrix))	RunControlCycle(input) ==let mk_(swpos, hgpos, rcom) = TransformInput(input) in let ts = SAFER`ControlCycle(swpos, hgpos, rcom) in GenerateThrusterMatrix(ts)TransformInput' ((unresolved WorkSpace`Input) -> ((unresolved HCM`SwitchPositions) * (unresolved HCM`HandGripPosition) * (unresolved AUX`RotCommand)))	TransformInput(input) ==let [mode, aah, horiz, trans, vert, twist, roll, pitch, yaw] = input in let swpos = mk_HCM`SwitchPositions((if (mode = 1)then <Tran>else <Rot>), (if (aah = 0)then <Up>else <Down>)), hgpos = mk_HCM`HandGripPosition(ConvertAxisCmd(vert), ConvertAxisCmd(horiz), ConvertAxisCmd(trans), ConvertAxisCmd(twist)), rcom = {<Roll> |-> ConvertAxisCmd(roll), <Pitch> |-> ConvertAxisCmd(pitch), <Yaw> |-> ConvertAxisCmd(yaw)} in mk_(swpos, hgpos, rcom)ConvertAxisCmd' (nat -> (unresolved AUX`AxisCommand))	ConvertAxisCmd(n) ==(cases n 'case 0 -> <Neg>,case 1 -> <Pos>,case 2 -> <Zero>others (undefined)end)GenerateThrusterMatrix' ((unresolved TS`ThrusterSet) +> (unresolved WorkSpace`ThrusterMatrix))	GenerateThrusterMatrix(ts) ==let tson = {GenerateThrusterLabel(t) | [t in set ts]} in [[(mk_(j, i) in set tson) | i in set {1, ... ,6}] | j in set {1, ... ,4}]GenerateThrusterLabel' ((unresolved TS`ThrusterName) +> (nat * nat))	GenerateThrusterLabel(tnm) ==(cases tnm 'case <B1> -> mk_(1, 4),case <B2> -> mk_(2, 4),case <B3> -> mk_(4, 4),case <B4> -> mk_(3, 4),case <F1> -> mk_(1, 1),case <F2> -> mk_(2, 1),case <F3> -> mk_(4, 1),case <F4> -> mk_(3, 1),case <L1R> -> mk_(1, 2),case <L1F> -> mk_(1, 3),case <R2R> -> mk_(2, 2),case <R2F> -> mk_(2, 3),case <L3R> -> mk_(4, 2),case <L3F> -> mk_(4, 3),case <R4R> -> mk_(3, 2),case <R4F> -> mk_(3, 3),case <D1R> -> mk_(1, 6),case <D1F> -> mk_(1, 5),case <D2R> -> mk_(2, 6),case <D2F> -> mk_(2, 5),case <U3R> -> mk_(4, 6),case <U3F> -> mk_(4, 5),case <U4R> -> mk_(3, 6),case <U4F> -> mk_(3, 5)end)static private switchpos = mk_HCM`SwitchPositions(<Tran>, <Down>)static private handgrippos = mk_HCM`HandGripPosition(<Zero>, <Pos>, <Zero>, <Zero>)static private rotcomm = {<Roll> |-> <Zero>, <Pitch> |-> <Zero>, <Yaw> |-> <Zero>}end WorkSpace
