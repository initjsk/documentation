RESULT:result:-1:-1,-1:module Mexportsexport alldefinitionsstatic private Quadrant = seq of ((unresolved M`M))static private M = compose M of type'(<FREE> | <USED>), start'nat, stop'nat end	inv mk_(unresolved M`M)(-, a, b) == (b >= a)state Memoryof[rseed'nat, Q3'(unresolved M`Quadrant), Q4'(unresolved M`Quadrant)]	inv mk_(unresolved M`Memory)(-, q3, q4) == (((len q3) > 0) and ((len q4) > 0))	init q == (q = mk_Memory(87654321, [mk_M(<FREE>, 0, (MAXMEM - 1))], [mk_M(<FREE>, 0, (MAXMEM - 1))]))static private MAXMEM = 10000static private CHUNK = 100sizeof' ((unresolved M`M) -> nat1)	sizeof(m) ==(((m.stop) - (m.start)) + 1)least' (nat1 * nat1 -> nat1)	least(a, b) ==(if (a < b)then aelse b)spacefor' (nat1 * (unresolved M`Quadrant) -> nat1)	spacefor(size, Q) ==(cases Q 'case [] -> (MAXMEM + 1),case [h] ^ tail -> (if (((h.type) = <FREE>) and (sizeof(h) >= size))then sizeof(h)else spacefor(size, tail))end)QuadrantLen' (nat1 * (unresolved M`Quadrant) -> nat)	QuadrantLen(-, list) ==(len list)bestfit' (nat1 * (unresolved M`Quadrant) -> nat1)	bestfit(size, Q) ==(cases Q 'case [] -> (MAXMEM + 1),case [h] ^ tail -> (if (((h.type) = <FREE>) and (sizeof(h) >= size))then least(sizeof(h), bestfit(size, tail))else bestfit(size, tail))end)add' (nat1 * nat1 * (unresolved M`Quadrant) -> (unresolved M`Quadrant))	add(size, hole, Q) ==(cases Q 'case [h] ^ tail -> (if (((h.type) = <FREE>) and (sizeof(h) = hole))then (if (hole = size)then ([mk_M(<USED>, (h.start), (h.stop))] ^ tail)else ([mk_M(<USED>, (h.start), (((h.start) + size) - 1)), mk_M(<FREE>, ((h.start) + size), (h.stop))] ^ tail))else ([h] ^ add(size, hole, tail)))others Qend)	pre (hole >= size)QuadrantLen2' (nat1 * nat1 * (unresolved M`Quadrant) -> nat)	QuadrantLen2(-, -, list) ==(len list)combine' ((unresolved M`Quadrant) -> (unresolved M`Quadrant))	combine(Q) ==(cases Q 'case [h1, h2] ^ tail -> (if (((h1.type) = <FREE>) and ((h2.type) = <FREE>))then combine(([mk_M(<FREE>, (h1.start), (h2.stop))] ^ tail))else ([h1] ^ combine((tl Q))))others Qend)QuadrantLen0' ((unresolved M`Quadrant) -> nat)	QuadrantLen0(list) ==(len list)delete' ((unresolved M`M) * (unresolved M`Quadrant) -> (unresolved M`Quadrant))	delete(item, Q) ==(if ((hd Q) = item)then combine(([mk_M(<FREE>, (item.start), (item.stop))] ^ (tl Q)))else ([(hd Q)] ^ delete(item, (tl Q))))MQuadrantLen' ((unresolved M`M) * (unresolved M`Quadrant) -> nat)	MQuadrantLen(-, list) ==(len list)fragments' ((unresolved M`Quadrant) -> nat)	fragments(Q) ==((card {x | [x in set (elems Q)] & ((x.type) = <FREE>)}) - 1)seed (nat1 ==> ())	seed(n) ==rseed '= ninc (() ==> ())	inc() ==for i = 1 to ((rseed mod 7) + 3)rseed '= (((rseed * 69069) + 5) mod 4294967296)rand (nat1 ==> nat1)	rand(n) ==(inc();return (((rseed mod n) + 1)))FirstFit (nat1 ==> bool)	FirstFit(size) ==(let private value q4'? in if (q4 <= MAXMEM)thenQ4 '= add(size, q4, Q4)elselet private value q3'? in if (q3 <= MAXMEM)thenQ3 '= add(size, q3, Q3)elsereturn (false);return (true))BestFit (nat1 ==> bool)	BestFit(size) ==(let private value q4'? in if (q4 <= MAXMEM)thenQ4 '= add(size, q4, Q4)elselet private value q3'? in if (q3 <= MAXMEM)thenQ3 '= add(size, q3, Q3)elsereturn (false);return (true))Reset (() ==> ())	Reset() ==(Q3 '= [mk_M(<FREE>, 0, (MAXMEM - 1))];Q4 '= [mk_M(<FREE>, 0, (MAXMEM - 1))])DeleteOne (() ==> ())	DeleteOne() ==(if (rand(2) = 1)thenlet private value i'? in if ((Q3(i).type) = <USED>)thenQ3 '= delete(Q3(i), Q3)elseDeleteOne()elselet private value i'? in if ((Q4(i).type) = <USED>)thenQ4 '= delete(Q4(i), Q4)elseDeleteOne())	pre ((exists [m in set (elems Q3)] & ((m.type) = <USED>)) or (exists [m in set (elems Q4)] & ((m.type) = <USED>)))TryFirst (nat ==> nat)	TryFirst(loops) ==(count'int '= 0while ((count < loops) and FirstFit(rand(CHUNK))) do (if (count > 50)thenDeleteOne();count '= (count + 1));return ((fragments(Q3) + fragments(Q4))))TryBest (nat ==> nat)	TryBest(loops) ==(count'int '= 0while ((count < loops) and BestFit(rand(CHUNK))) do (if (count > 50)thenDeleteOne();count '= (count + 1));return ((fragments(Q3) + fragments(Q4))))main (nat1 * nat1 ==> seq of (((<BEST> | <FIRST> | <SAME>))))	main(tries, loops) ==(result'seq of (((<BEST> | <FIRST> | <SAME>))) '= []for i = 1 to tries(best'int '= (undefined)first'int '= (undefined)Reset();seed(i);best '= TryBest(loops);Reset();seed(i);first '= TryFirst(loops);if (best = first)thenresult '= (result ^ [<SAME>])elseif (best > first)thenresult '= (result ^ [<BEST>])elseresult '= (result ^ [<FIRST>]));return (result))end M
