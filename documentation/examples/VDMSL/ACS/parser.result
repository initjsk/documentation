RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Cg = (<A> | <B> | <C> | <D> | <E> | <F> | <G> | <H> | <J> | <K> | <L> | <S>)static private Hzd = (<ONEPFOUR> | <ONEPONE> | <ONEPTHREE> | <ONEPTWO>)static private Inf = <INFINITY>static private Kg = ((unresolved DEFAULT`Inf) | real)	inv k == ((k <> <INFINITY>) => (k >= 0))static private Realp = real	inv r == (r >= 0)static private Metre = (unresolved DEFAULT`Realp)static private Object = compose Object of neq'(unresolved DEFAULT`Kg), hzd'(unresolved DEFAULT`Hzd), cg'(unresolved DEFAULT`Cg), xlen'(unresolved DEFAULT`Metre), ylen'(unresolved DEFAULT`Metre), zlen'(unresolved DEFAULT`Metre) endstatic private Element_label = tokenstatic private Element = compose Element of object'(unresolved DEFAULT`Object), x'(unresolved DEFAULT`Realp), y'(unresolved DEFAULT`Realp) endstatic private Point = compose Point of x'(unresolved DEFAULT`Realp), y'(unresolved DEFAULT`Realp) endstatic private Pes_types = (<EARTHCOVEREDBUILDING> | <HEAVYWALLEDBUILDING> | <TRAVERSEDSITE> | <UNTRAVERSEDSITE>)static private Magazine = compose Magazine of type'(unresolved DEFAULT`Pes_types), max_neq'(unresolved DEFAULT`Kg), hzd'(unresolved DEFAULT`Hzd), length'(unresolved DEFAULT`Metre), breadth'(unresolved DEFAULT`Metre), height'(unresolved DEFAULT`Metre), elements'inmap of ((unresolved DEFAULT`Element_label)) to ((unresolved DEFAULT`Element)) endstatic private Storage_building = compose Storage_building of kind'(<EARTHCOVEREDBUILDING> | <EARTHCOVEREDWITHDOORBARRICADE> | <EARTHCOVEREDWITHFIREHEADWALL> | <HEAVYWALLEDWITHOUTPROTECTIVEROOF> | <HEAVYWALLEDWITHPROTECTIVEROOF> | <IGLOOSEVENBAR> | <IGLOOTHREEBAR> | <TRAVERSEDSITE> | <UNTRAVERSEDSITE>) endstatic private Process_building = compose Process_building of kind'(<WITHORWITHOUTPROTECTIVEROOFUNTRAVERSED> | <WITHOUTPROTECTIVEROOFTRAVERSED> | <WITHPROTECTIVEROOFTRAVERSED>) endstatic private Other_building = compose Other_building of kind'(<INHABITEDBUILDING> | <TRAFFICROUTE>) endstatic private Exs_types = ((unresolved DEFAULT`Other_building) | (unresolved DEFAULT`Process_building) | (unresolved DEFAULT`Storage_building))static private Building = compose Building of type'(unresolved DEFAULT`Exs_types), length'(unresolved DEFAULT`Metre), breadth'(unresolved DEFAULT`Metre), height'(unresolved DEFAULT`Metre) endstatic private Quad = seq of ((unresolved DEFAULT`Point))	inv q == (((len q) = 4) and rectangular(q))static private Site_label = tokenstatic private Exposed_site = compose Exposed_site of building'(unresolved DEFAULT`Building), vertices'(unresolved DEFAULT`Quad), door'nat end	inv exs == ((forall p in set (elems ((exs.vertices)(2, ... ,4))) & (((distance(mk_Point(0, 0), (exs.vertices)(1)) <= distance(mk_Point(0, 0), p)) and (distance(mk_Point(0, 0), (exs.vertices)(1)) = distance(mk_Point(0, 0), p))) => (((exs.vertices)(1).y) < (p.y)))) and (((exs.door) in set {0, ... ,3}) and (exists [i in set (inds (exs.vertices)), j in set (inds (exs.vertices))] & (((abs (j - i)) = 2) and ((distance((exs.vertices)(1), (exs.vertices)(i)) = ((exs.building).length)) and (distance((exs.vertices)(1), (exs.vertices)(j)) = ((exs.building).breadth)))))))static private Pot_explosion_site = compose Pot_explosion_site of mgzn'(unresolved DEFAULT`Magazine), vertices'seq of ((unresolved DEFAULT`Point)), door'nat end	inv pes == ((forall p in set (elems ((pes.vertices)(2, ... ,4))) & (((distance(mk_Point(0, 0), (pes.vertices)(1)) <= distance(mk_Point(0, 0), p)) and (distance(mk_Point(0, 0), (pes.vertices)(1)) = distance(mk_Point(0, 0), p))) => (((pes.vertices)(1).y) < (p.y)))) and (((pes.door) in set {0, ... ,3}) and (exists [i in set (inds (pes.vertices)), j in set (inds (pes.vertices))] & ((distance((pes.vertices)(1), (pes.vertices)(i)) = ((pes.mgzn).length)) and (distance((pes.vertices)(1), (pes.vertices)(j)) = ((pes.mgzn).breadth))))))static private Line = compose Line of m'real, c'real endstatic private RelOrientation = (<AWAY> | <FACING> | <PERP>)static private OrientedExs = ((unresolved DEFAULT`Exs_types) * (((unresolved DEFAULT`RelOrientation) | <NONE>)))	inv mk_(exs, ro) == ((not is_(exs, Storage_building)) <=> (ro = <NONE>))static private OrientedPes = ((unresolved DEFAULT`Pes_types) * (((unresolved DEFAULT`RelOrientation) | <NONE>)))	inv mk_(pes, ro) == ((pes <> <EARTHCOVEREDBUILDING>) <=> (ro = <NONE>))static private Table_Co_ordinate = ((unresolved DEFAULT`OrientedExs) * (unresolved DEFAULT`OrientedPes))static private asharp'map ((unresolved DEFAULT`Hzd)) to ((map ((unresolved DEFAULT`Table_Co_ordinate)) to (real))) = {h |-> let m'map ((unresolved DEFAULT`Table_Co_ordinate)) to (real) in m | h'(unresolved DEFAULT`Hzd)}static private bsharp'map ((unresolved DEFAULT`Hzd)) to ((map ((unresolved DEFAULT`Table_Co_ordinate)) to (real))) = {h |-> let m'map ((unresolved DEFAULT`Table_Co_ordinate)) to (real) in m | h'(unresolved DEFAULT`Hzd)}static private exceptions_hd1_1'set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s'set of ((unresolved DEFAULT`Table_Co_ordinate)) in sstatic private exceptions_hd1_2'set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s'set of ((unresolved DEFAULT`Table_Co_ordinate)) in sstatic private exceptions_hd1_3a'set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s'set of ((unresolved DEFAULT`Table_Co_ordinate)) in sstatic private exceptions_hd1_3b'set of ((unresolved DEFAULT`Table_Co_ordinate)) = let s'set of ((unresolved DEFAULT`Table_Co_ordinate)) in sstatic private Xmax = 5static private Ymax = 5static private next_point'map (nat) to (nat) = {1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1}static private Compatible_pairs'set of ((((unresolved DEFAULT`Cg) * (unresolved DEFAULT`Cg)))) = {mk_(<A>, <A>), mk_(<A>, <S>), mk_(<B>, <B>), mk_(<B>, <S>), mk_(<C>, <C>), mk_(<C>, <D>), mk_(<C>, <E>), mk_(<C>, <G>), mk_(<C>, <S>), mk_(<D>, <D>), mk_(<D>, <E>), mk_(<D>, <G>), mk_(<D>, <S>), mk_(<E>, <E>), mk_(<E>, <G>), mk_(<E>, <G>), mk_(<E>, <S>), mk_(<F>, <F>), mk_(<F>, <S>), mk_(<G>, <G>), mk_(<G>, <S>), mk_(<H>, <H>), mk_(<H>, <S>), mk_(<J>, <J>), mk_(<J>, <S>)}static private hzdnum'map ((unresolved DEFAULT`Hzd)) to (nat) = {<ONEPONE> |-> 1, <ONEPTWO> |-> 2, <ONEPTHREE> |-> 3, <ONEPFOUR> |-> 4}static private orientation'map (nat) to ((unresolved DEFAULT`RelOrientation)) = {0 |-> <PERP>, 1 |-> <FACING>, 2 |-> <PERP>, 3 |-> <AWAY>}static private esharp'nat = let x'nat in xstate Storeof[pes'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site)), exs'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Exposed_site)), xmax'(unresolved DEFAULT`Metre), ymax'(unresolved DEFAULT`Metre)]	inv mk_(unresolved DEFAULT`Store)(pes, exs, xmax, ymax) == ((xmax > 0) and ((ymax > 0) and (((dom pes) subset (dom exs)) and (forall p in set (dom pes) & is_(((exs(p).building).type), Storage_building)))))	init store == (store = mk_Store({}, {}, Xmax, Ymax))rectangular' (seq of ((unresolved DEFAULT`Point)) -> bool)	rectangular(v) ==((distance(v(1), v(2)) = distance(v(3), v(4))) and ((distance(v(1), v(4)) = distance(v(2), v(3))) and ((distance(v(1), v(3)) = distance(v(2), v(4))) and ((card (elems v)) = (len v)))))	pre ((len v) = 4)distance' ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> (unresolved DEFAULT`Metre))	distance(p1, p2) ==sqrt(((((p2.x) - (p1.x)) ** 2) + (((p2.y) - (p1.y)) ** 2)))private sqrt((x'real))s'(unresolved DEFAULT`Realp)	pre (x >= 0)	post ((s >= 0) and ((s ** 2) = x))suff_space_at' ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) * (unresolved DEFAULT`Point) -> bool)	suff_space_at(o, m, p) ==((0 < ((p.x) + (o.xlen))) and ((((p.x) + (o.xlen)) <= (m.length)) and ((0 < ((p.y) + (o.ylen))) and ((((p.y) + (o.ylen)) <= (m.breadth)) and ((0 < (o.zlen)) and (((o.zlen) <= (m.height)) and (forall a in set (rng (m.elements)) & ((((a.x) > ((p.x) + (o.xlen))) or (((a.x) + ((a.object).xlen)) < (p.x))) and (((a.y) > ((p.y) + (o.ylen))) or (((a.y) + ((a.object).ylen)) < (p.y)))))))))))private find_point((o'(unresolved DEFAULT`Object)), (m'(unresolved DEFAULT`Magazine)))pt'(unresolved DEFAULT`Point)	pre (exists [x'(unresolved DEFAULT`Realp), y'(unresolved DEFAULT`Realp)] & suff_space_at(o, m, mk_Point(x, y)))	post suff_space_at(o, m, pt)within_hazard' ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) -> bool)	within_hazard(o, m) ==(hzdnum((o.hzd)) >= hzdnum((m.hzd)))compatible' ((unresolved DEFAULT`Cg) * (unresolved DEFAULT`Cg) -> bool)	compatible(m, n) ==((mk_(m, n) in set Compatible_pairs) or (mk_(n, m) in set Compatible_pairs))all_compatible' ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) -> bool)	all_compatible(o, m) ==(forall elt in set (rng (m.elements)) & compatible((o.cg), ((elt.object).cg)))sum' (set of (real) -> real)	sum(s) ==(if (s = {})then 0else let x'real be st (x in set s) in (x + sum((s \ {x}))))Card' (set of (real) -> nat)	Card(s) ==(card s)suff_capacity' ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) -> bool)	suff_capacity(o, m) ==(if ((m.max_neq) <> <INFINITY>)then ((sum({((elt.object).neq) | [elt in set (rng (m.elements))]}) + (o.neq)) <= (m.max_neq))else true)safe_addition' ((unresolved DEFAULT`Object) * (unresolved DEFAULT`Magazine) * (unresolved DEFAULT`Point) -> bool)	safe_addition(o, m, p) ==(suff_space_at(o, m, p) and (within_hazard(o, m) and (all_compatible(o, m) and suff_capacity(o, m))))rel_pos' ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> nat)	rel_pos(pes, exs) ==((floor ang_sep(pes, exs)) div 90)table_entry' ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> (unresolved DEFAULT`Table_Co_ordinate))	table_entry(pes, exs) ==let inc = rel_pos(pes, exs) in let exs_ro = (if is_(((exs.building).type), Storage_building)then orientation(((inc + (exs.door)) mod 4))else <NONE>), pes_ro = (if (((pes.mgzn).type) = <EARTHCOVEREDBUILDING>)then orientation(((inc + (pes.door)) mod 4))else <NONE>) in let o_exs = mk_(((exs.building).type), exs_ro), o_pes = mk_(((pes.mgzn).type), pes_ro) in mk_(o_exs, o_pes)private min((s'set of ((unresolved DEFAULT`Realp))))m'(unresolved DEFAULT`Realp)	pre (s <> {})	post ((m in set s) and (forall x in set s & (m <= x)))private max((s'set of ((unresolved DEFAULT`Realp))))m'(unresolved DEFAULT`Realp)	pre (s <> {})	post ((m in set s) and (forall x in set s & (m >= x)))truncated' ((unresolved DEFAULT`Realp) -> bool)	truncated(r) ==is_((r * (10 ** esharp)), nat)side' ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> set of ((unresolved DEFAULT`Point)))	side(p1, p2) ==(if ((p2.x) = (p1.x))then {mk_Point((p1.x), y) | [y'(unresolved DEFAULT`Realp)] & (truncated(y) and ((min({(p1.y), (p2.y)}) <= y) and (y <= max({(p1.y), (p2.y)}))))}else {mk_Point(x, y) | [x'(unresolved DEFAULT`Realp), y'(unresolved DEFAULT`Realp)] & (truncated(x) and (truncated(y) and ((min({(p1.x), (p2.x)}) <= x) and ((x <= max({(p1.x), (p2.x)})) and ((min({(p1.y), (p2.y)}) <= y) and ((y <= max({(p1.y), (p2.y)})) and (if (x <> (p1.x))then (((y - (p1.y)) / (x - (p1.x))) = (((p2.y) - (p1.y)) / ((p2.x) - (p1.x))))else (y = (p1.y)))))))))})perimeter' ((((unresolved DEFAULT`Exposed_site) | (unresolved DEFAULT`Pot_explosion_site))) -> (set of ((unresolved DEFAULT`Point))))	perimeter(site) ==(dunion {side((site.vertices)(i), (site.vertices)(next_point(i))) | [i in set {1, ... ,4}]})shortest_dist' ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> (unresolved DEFAULT`Metre))	shortest_dist(pes, exs) ==min({distance(p1, p2) | [p1'(unresolved DEFAULT`Point), p2'(unresolved DEFAULT`Point)] & ((p1 in set perimeter(pes)) and (p2 in set perimeter(exs)))})min_separation' ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> bool)	min_separation(pes, exs) ==(shortest_dist(pes, exs) >= bsharp(((pes.mgzn).hzd))(table_entry(pes, exs)))qd' ((unresolved DEFAULT`Pot_explosion_site) * (unresolved DEFAULT`Exposed_site) -> (unresolved DEFAULT`Kg))	qd(pes, exs) ==let d = shortest_dist(pes, exs), tbe = table_entry(pes, exs) in (cases ((pes.mgzn).hzd) 'case (<ONEPONE>) -> (if (tbe in set exceptions_hd1_1)then (if (d < 180)then (0.54 * (d ** (3 / 2)))elseif ((180 <= d) and (d < 240))then (0.03 * (d ** 2))else ((9.1 * (10 ** -5)) * (d ** 3)))else (asharp(<ONEPONE>)(tbe) * (d ** 3))),case (<ONEPTWO>) -> (if (tbe in set exceptions_hd1_2)then <INFINITY>else (asharp(<ONEPTWO>)(tbe) * (d ** 5.5))),case (<ONEPTHREE>) -> (if (tbe in set exceptions_hd1_3a)then <INFINITY>elseif (tbe in set exceptions_hd1_3b)then (asharp(<ONEPTHREE>)(tbe) * (d ** 2))else (asharp(<ONEPTHREE>)(tbe) * (d ** 3))),case (<ONEPFOUR>) -> <INFINITY>end)private nearest_storage_building((pes'(unresolved DEFAULT`Pot_explosion_site)), (exs'set of ((unresolved DEFAULT`Exposed_site))))e'(unresolved DEFAULT`Exposed_site)	pre (exists [ex in set exs] & is_(((ex.building).type), Storage_building))	post ((e in set exs) and (is_(((e.building).type), Storage_building) and (forall ex in set exs & (is_(((ex.building).type), Storage_building) => (shortest_dist(pes, e) <= shortest_dist(pes, ex))))))private nearest_inhabited_building((pes'(unresolved DEFAULT`Pot_explosion_site)), (exs'set of ((unresolved DEFAULT`Exposed_site))))e'(unresolved DEFAULT`Exposed_site)	pre (exists [ex in set exs] & ((((ex.building).type).kind) = <INHABITEDBUILDING>))	post ((e in set exs) and (((((e.building).type).kind) = <INHABITEDBUILDING>) and (forall ex in set exs & (((((ex.building).type).kind) = <INHABITEDBUILDING>) => (shortest_dist(pes, e) <= shortest_dist(pes, ex))))))private nearest_traffic_route((pes'(unresolved DEFAULT`Pot_explosion_site)), (exs'set of ((unresolved DEFAULT`Exposed_site))))e'(unresolved DEFAULT`Exposed_site)	pre (exists [ex in set exs] & ((((ex.building).type).kind) = <TRAFFICROUTE>))	post ((e in set exs) and (((((e.building).type).kind) = <TRAFFICROUTE>) and (forall ex in set exs & (((((ex.building).type).kind) = <TRAFFICROUTE>) => (shortest_dist(pes, e) <= shortest_dist(pes, ex))))))private nearest_process_building((pes'(unresolved DEFAULT`Pot_explosion_site)), (exs'set of ((unresolved DEFAULT`Exposed_site))))e'(unresolved DEFAULT`Exposed_site)	pre (exists [ex in set exs] & is_(((ex.building).type), Process_building))	post ((e in set exs) and (is_(((e.building).type), Process_building) and (forall ex in set exs & (is_(((ex.building).type), Process_building) => (shortest_dist(pes, e) <= shortest_dist(pes, ex))))))private nearest_buildings((pes'(unresolved DEFAULT`Pot_explosion_site)), (exs'set of ((unresolved DEFAULT`Exposed_site))))exset'(set of ((unresolved DEFAULT`Exposed_site)))	post ((exists [e in set exs] & is_(((e.building).type), Storage_building)) => (((nearest_storage_building(pes, exs) in set exset) and (exists [e in set exs] & is_(((e.building).type), Process_building))) => (((nearest_process_building(pes, exs) in set exset) and (exists [e in set exs] & ((((e.building).type).kind) = <INHABITEDBUILDING>))) => (((nearest_inhabited_building(pes, exs) in set exset) and (exists [e in set exs] & ((((e.building).type).kind) = <TRAFFICROUTE>))) => (nearest_traffic_route(pes, exs) in set exset)))))find_max_neq' ((unresolved DEFAULT`Pot_explosion_site) * set of ((unresolved DEFAULT`Exposed_site)) -> (unresolved DEFAULT`Kg))	find_max_neq(pes, exs) ==min({qd(pes, e) | [e in set nearest_buildings(pes, exs)]})	pre (exs <> {})private centre((v'(unresolved DEFAULT`Quad)))p'(unresolved DEFAULT`Point)	post (forall i in set {1, ... ,3} & (distance(p, v(i)) = distance(p, v(1))))line_eqn' ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> (unresolved DEFAULT`Line))	line_eqn(p1, p2, p3) ==mk_Line(((((p1.y) + (p2.y)) - (2 * (p3.y))) / (((p1.x) + (p2.x)) - (2 * (p3.x)))), ((p3.y) - ((p3.x) * ((((p1.y) + (p2.y)) - (2 * (p3.y))) / (((p1.x) + (p2.x)) - (2 * (p3.x)))))))	pre (distance(p1, p3) = distance(p2, p3))incline' ((unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) * (unresolved DEFAULT`Point) -> real)	incline(p1, p2, p3, p4, p5, p6) ==let mk_(unresolved DEFAULT`Line)(m1, c1) = line_eqn(p5, p6, p2) in let mk_(unresolved DEFAULT`Line)(m2, c2) = line_eqn(p3, p4, p1) in let x3 = ((c1 - c2) / (m2 - m1)) in let y3 = (((m2 * c1) - (m1 * c2)) / (m2 - m1)) in sqrt(((((x3 - (p2.x)) ** 2) + ((y3 - (p2.y)) ** 2)) / (((x3 - (p1.x)) ** 2) + ((y3 - (p1.y)) ** 2))))	pre ((distance(p1, p2) = distance(p1, p4)) and ((distance(p2, p5) = distance(p2, p6)) and (((line_eqn(p5, p6, p2).m) * (line_eqn(p3, p4, p1).m)) = -1)))private ang_sep((pes'(unresolved DEFAULT`Pot_explosion_site)), (exs'(unresolved DEFAULT`Exposed_site)))qsharp'real	post let fsharp = arctan(incline(centre((pes.vertices)), centre((exs.vertices)), (pes.vertices)(1), (pes.vertices)(4), (exs.vertices)(1), (exs.vertices)(2))) in (if ((centre((pes.vertices)).x) = (centre((exs.vertices)).x))then (if ((centre((pes.vertices)).y) < (centre((exs.vertices)).y))then (qsharp = fsharp)else (qsharp = (fsharp + 180)))else let m1 = (line_eqn((pes.vertices)(1), (pes.vertices)(4), centre((pes.vertices))).m), m2 = (((centre((exs.vertices)).y) - (centre((pes.vertices)).y)) / ((centre((exs.vertices)).x) - (centre((pes.vertices)).x))) in (if (m2 > m1)then (qsharp = fsharp)else (qsharp = (fsharp + 180))))arctan' (real -> real)	arctan(r) ==let res'real in resADD_OBJECT((o'(unresolved DEFAULT`Object)), (elt'(unresolved DEFAULT`Element_label)), (site'(unresolved DEFAULT`Site_label)))	ext [wr pes'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site))]	pre ((site in set (dom pes)) and (exists [pt'(unresolved DEFAULT`Point)] & (safe_addition(o, (pes(site).mgzn), pt) and (elt not in set (dom ((pes(site).mgzn).elements))))))	post let p = pes~(site) in let mk_(unresolved DEFAULT`Point)(x, y) = find_point(o, (p.mgzn)) in let new_elems = (((p.mgzn).elements) ++ {elt |-> mk_Element(o, x, y)}) in let new_mag = mu((p.mgzn), elements |-> new_elems) in let new_site = mu(p, mgzn |-> new_mag) in (pes = (pes~ ++ {site |-> new_site}))REMOVE_OBJECT((elt'(unresolved DEFAULT`Element_label)), (site'(unresolved DEFAULT`Site_label)))	ext [wr pes'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site))]	pre ((site in set (dom pes)) and (elt in set (dom ((pes(site).mgzn).elements))))	post let p = pes~(site) in let new_elems = ({elt} <-' ((p.mgzn).elements)) in let new_mag = mu((p.mgzn), elements |-> new_elems) in let new_site = mu(p, mgzn |-> new_mag) in (pes = (pes~ ++ {site |-> new_site}))ADD_PES((pex'(unresolved DEFAULT`Pot_explosion_site)), (label'(unresolved DEFAULT`Site_label)), (type'(unresolved DEFAULT`Storage_building)))	ext [wr pes'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site)), wr exs'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Exposed_site)), rd xmax, ymax'(unresolved DEFAULT`Metre)]	pre (forall exp in set (rng exs) & (min_separation(pex, exp) and (forall v in set (elems (pex.vertices)) & (((0 <= (v.x)) and (((v.x) <= xmax) and ((0 <= (v.y)) and ((v.y) <= ymax)))) and (label not in set (dom pes))))))	post let new_neq = find_max_neq(pex, (rng exs~)) in let new_mgzn = mu((pex.mgzn), max_neq |-> new_neq) in let new_pex = mu(pex, mgzn |-> new_mgzn) in let new_building = mk_Building(type, ((pex.mgzn).length), ((pex.mgzn).breadth), ((pex.mgzn).height)) in let new_exp = mk_Exposed_site(new_building, (pex.vertices), (pex.door)) in ((pes = (pes~ ++ {label |-> new_pex})) and (exs = (exs~ ++ {label |-> new_exp})))ADD_EXP((ex'(unresolved DEFAULT`Exposed_site)), (label'(unresolved DEFAULT`Site_label)))	ext [wr exs'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Exposed_site)), rd pes'inmap of ((unresolved DEFAULT`Site_label)) to ((unresolved DEFAULT`Pot_explosion_site)), rd xmax, ymax'(unresolved DEFAULT`Metre)]	pre ((not is_(((ex.building).type), Storage_building)) and (forall v in set (elems (ex.vertices)) & (((0 <= (v.x)) and (((v.x) <= xmax) and ((0 <= (v.y)) and ((v.y) <= ymax)))) and ((label not in set (dom exs)) and (forall pex in set (rng pes) & let proposed_neq = find_max_neq(pex, (rng (exs ++ {label |-> ex}))) in (if (proposed_neq <> <INFINITY>)then (find_max_neq(pex, (rng exs)) <= proposed_neq)else true))))))	post (exs = (exs~ ++ {label |-> ex}))end DEFAULT
