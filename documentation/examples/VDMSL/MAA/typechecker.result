WARNING:maa.vdmsl:5012:382,20:Recursive function has no measure.
WARNING:maa.vdmsl:5012:99,28:Recursive function has no measure.
WARNING:maa.vdmsl:5008:239,13:B at 19'4 hidden by B.
WARNING:maa.vdmsl:5008:253,9:D at 21'4 hidden by D.
WARNING:maa.vdmsl:5008:193,5:C at 20'4 hidden by C.
WARNING:maa.vdmsl:5012:107,15:Recursive function has no measure.
WARNING:maa.vdmsl:5008:179,5:C at 20'4 hidden by C.
WARNING:maa.vdmsl:5000:94,34:Definition 'M' not used.
WARNING:maa.vdmsl:5012:396,22:Recursive function has no measure.
WARNING:maa.vdmsl:5012:124,7:Recursive function has no measure.
WARNING:maa.vdmsl:5012:262,18:Recursive function has no measure.
WARNING:maa.vdmsl:5008:191,9:D at 21'4 hidden by D.
WARNING:maa.vdmsl:5012:222,22:Recursive function has no measure.
WARNING:maa.vdmsl:5012:368,12:Recursive function has no measure.
WARNING:maa.vdmsl:5012:142,7:Recursive function has no measure.
WARNING:maa.vdmsl:5012:130,6:Recursive function has no measure.
WARNING:maa.vdmsl:5008:230,21:B at 19'4 hidden by B.
WARNING:maa.vdmsl:5008:177,53:D at 21'4 hidden by D.
WARNING:maa.vdmsl:5012:403,22:Recursive function has no measure.
WARNING:maa.vdmsl:5008:216,12:B at 19'4 hidden by B.
WARNING:maa.vdmsl:5012:246,27:Recursive function has no measure.
WARNING:maa.vdmsl:5012:215,8:Recursive function has no measure.
WARNING:maa.vdmsl:5008:167,5:C at 20'4 hidden by C.
WARNING:maa.vdmsl:5012:389,20:Recursive function has no measure.
WARNING:maa.vdmsl:5012:318,13:Recursive function has no measure.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Word_Length'nat1 = 32static private Maximum_Number_Size'int = ((2 ** Word_Length) - 1)static private Maximum_Number_Size_plus_1'int = (Maximum_Number_Size + 1)static private Maximum_Number_Size_plus_1_div_2'int = (Maximum_Number_Size_plus_1 div 2)static private Maximum_No_of_Message_blocks'nat1 = 1000000static private A'nat1 = ((((2 * (2 ** 24)) + (4 * (2 ** 16))) + (8 * (2 ** 8))) + 1)static private B'nat1 = ((((0 * (2 ** 24)) + (128 * (2 ** 16))) + (64 * (2 ** 8))) + 33)static private C'nat1 = ((((191 * (2 ** 24)) + (239 * (2 ** 16))) + (127 * (2 ** 8))) + 223)static private D'nat1 = ((((125 * (2 ** 24)) + (254 * (2 ** 16))) + (251 * (2 ** 8))) + 255)static private Maximum_No_of_blocks_for_MAC'int = (1024 div 4)static private Maximum_No_of_blocks_for_MAC_plus_1'int = (Maximum_No_of_blocks_for_MAC + 1)static private Number = nat	inv N == (N < Maximum_Number_Size_plus_1)static private Bit = nat	inv b == (b in set {0, 1})static private Message_in_bits = seq of (Bit)	inv M == (if (((len M) mod Word_Length) = 0)then ((((len M) div Word_Length) <= Maximum_No_of_Message_blocks) and ((len M) > 0))else ((((len M) div Word_Length) + 1) <= Maximum_No_of_Message_blocks))static private Message_in_blocks_plus_empty_Message = seq of (Number)	inv M == ((len M) <= Maximum_No_of_Message_blocks)static private Message_in_blocks = Message_in_blocks_plus_empty_Message	inv M == (1 <= (len M))static private Double_Number = seq of (Number)	inv d == ((len d) = 2)static private Key = Double_Numberstatic private Key_Constant = compose Key_Constant of X0'Number, Y0'Number, V0'Number, W'Number, S'Number, T'Number endPad_out_Message' (Message_in_bits -> Message_in_bits)	Pad_out_Message(M) ==let No_Extra_bits'int = (Word_Length - ((len M) mod Word_Length)) in (if (No_Extra_bits = Word_Length)then Melse (M ^ Get_Application_defined_bits(M, No_Extra_bits)))private Get_Application_defined_bits((M'Message_in_bits), (No_bits'nat))Extra'Message_in_bits	pre (No_bits < Word_Length)	post ((len Extra) = No_bits)Form_Message_into_blocks' (Message_in_bits -> Message_in_blocks)	Form_Message_into_blocks(M) ==(if ((len M) = Word_Length)then [Form_Number(M)]else ([Form_Number(Get_head_in_bits(M, Word_Length))] ^ Form_Message_into_blocks(Get_tail_in_bits(M, Word_Length))))	pre (((len M) >= Word_Length) and (((len M) mod Word_Length) = 0))Form_Number' (Message_in_bits -> Number)	Form_Number(M) ==(if ((len M) = 1)then (hd M)else ((hd M) + (2 * Form_Number((tl M)))))	pre ((len M) <= Word_Length)CYC' (Number -> Number)	CYC(X) ==(ADD(X, X) + CAR(X, X))AND' (Number * Number -> Number)	AND(X, Y) ==(if ((X = 0) or (Y = 0))then 0else ((((X mod 2) * Y) mod 2) + (2 * AND((X div 2), (Y div 2)))))OR' (Number * Number -> Number)	OR(X, Y) ==(if ((X = 0) or (Y = 0))then (X + Y)else (max((X mod 2), (Y mod 2)) + (2 * OR((X div 2), (Y div 2)))))max' (int * int -> int)	max(X, Y) ==(if (X >= Y)then Xelse Y)XOR' (Number * Number -> Number)	XOR(X, Y) ==(if ((X = 0) or (Y = 0))then (X + Y)else (((X + Y) mod 2) + (2 * XOR((X div 2), (Y div 2)))))ADD' (Number * Number -> Number)	ADD(X, Y) ==((X + Y) mod Maximum_Number_Size_plus_1)CAR' (Number * Number -> Number)	CAR(X, Y) ==((X + Y) div Maximum_Number_Size_plus_1)MUL1' (Number * Number -> Number)	MUL1(X, Y) ==let L'nat = ((X * Y) mod Maximum_Number_Size_plus_1), U'int = ((X * Y) div Maximum_Number_Size_plus_1) in let S'Number = ADD(U, L), C'Number = CAR(U, L) in ADD(S, C)MUL2' (Number * Number -> Number)	MUL2(X, Y) ==let L'nat = ((X * Y) mod Maximum_Number_Size_plus_1), U'int = ((X * Y) div Maximum_Number_Size_plus_1) in let D'Number = ADD(U, U), E'Number = CAR(U, U) in let F'Number = ADD(D, (2 * E)) in let S'Number = ADD(F, L), C'Number = CAR(F, L) in ADD(S, (2 * C))MUL2A' (Number * Number -> Number)	MUL2A(X, Y) ==let L'nat = ((X * Y) mod Maximum_Number_Size_plus_1), U'int = ((X * Y) div Maximum_Number_Size_plus_1) in let D'Number = ADD(U, U) in let S'Number = ADD(D, L), C'Number = CAR(D, L) in ADD(S, (2 * C))	pre (((X div Maximum_Number_Size_plus_1_div_2) = 0) or ((Y div Maximum_Number_Size_plus_1_div_2) = 0))BYT' (Double_Number -> Double_Number)	BYT(K) ==let X'Number = (hd K), Y'Number = (hd (tl K)) in let X''seq1 of (Number) = [Byte(X, 3), Byte(X, 2), Byte(X, 1), Byte(X, 0)], Y''seq1 of (Number) = [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(X, 0)] in let XY'seq1 of (Number) = (X' ^ Y'), P'nat = 0 in let XY''Message_in_blocks = Condition_Sequence(XY, P) in let X'''Message_in_blocks = Get_head_in_blocks(XY', 4), Y'''Message_in_blocks = Get_tail_in_blocks(XY', 4) in ([Convert_Bytes_to_Number(X'')] ^ [Convert_Bytes_to_Number(Y'')])Byte' (Number * nat -> Number)	Byte(N, B) ==(if (B = 0)then (N mod (2 ** 8))else Byte((N div (2 ** 8)), (B - 1)))	pre ((B >= 0) and (B <= 3))Condition_Sequence' (Message_in_blocks * Number -> Message_in_blocks)	Condition_Sequence(M, P) ==(if ((len M) = 1)then [Condition_value((hd M), P)]else ([Condition_value((hd M), P)] ^ Condition_Sequence((tl M), Changes((hd M), P))))Condition_value' (Number * Number -> Number)	Condition_value(B, P) ==let P''nat1 = (2 * P) in let P'''nat1 = (P' + 1) in (if (B = 0)then P''else (if (B = ((2 ** 8) - 1))then (((2 ** 8) - 1) - P'')else B))Changes' (Number * Number -> Number)	Changes(B, P) ==let P''nat1 = (2 * P) in let P'''nat1 = (P' + 1) in (if ((B = 0) or (B = ((2 ** 8) - 1)))then P''else P')Convert_Bytes_to_Number' (Message_in_blocks -> Number)	Convert_Bytes_to_Number(M) ==(if ((len M) = 1)then (hd M)else (Convert_Bytes_to_Number((tl M)) + ((hd M) * (2 ** (8 * ((len M) - 1))))))PAT' (Double_Number -> Number)	PAT(D) ==let X'Number = (hd D), Y'Number = (hd (tl D)) in let X''seq1 of (Number) = [Byte(X, 3), Byte(X, 2), Byte(Y, 1), Byte(Y, 0)], Y''seq1 of (Number) = [Byte(Y, 3), Byte(Y, 2), Byte(Y, 1), Byte(Y, 0)] in let XY'seq1 of (Number) = (X' ^ Y'), P'nat = 0 in Record_Changes(XY, P)Record_Changes' (Message_in_blocks * Number -> Number)	Record_Changes(M, P) ==(if ((len M) = 1)then Changes((hd M), P)else Record_Changes((tl M), Changes((hd M), P)))Prelude' (Key -> Key_Constant)	Prelude(K) ==let J1K1'Double_Number = BYT(K) in let J1'Number = (hd J1K1), K1'Number = (hd (tl J1K1)), P'Number = PAT(K), Q'nat1 = ((1 + P) * (1 + P)) in let J12'Number = MUL1(J1, J1), J22'Number = MUL2(J1, J1) in let J14'Number = MUL1(J12, J12), J24'Number = MUL2(J22, J22) in let J16'Number = MUL1(J12, J14), J26'Number = MUL2(J22, J24) in let J18'Number = MUL1(J12, J16), J28'Number = MUL2(J22, J26) in let H4'Number = XOR(J14, J28), H6'Number = XOR(J16, J26), H8'Number = XOR(J18, J28) in let K12'Number = MUL1(K1, K1), K22'Number = MUL2(K1, K1) in let K14'Number = MUL1(K12, K12), K24'Number = MUL2(K22, K22) in let K15'Number = MUL1(K1, K14), K25'Number = MUL2(K1, K24) in let K17'Number = MUL1(K12, K15), K27'Number = MUL2(K22, K25) in let K19'Number = MUL1(K12, K17), K29'Number = MUL2(K22, K27) in let H''Number = XOR(K15, K25) in let H5'Number = MUL2(H', Q), H7'Number = XOR(K17, K27), H9'Number = XOR(K19, K29) in let X0Y0'Double_Number = BYT([H4, H5]), V0W'Double_Number = BYT([H6, H7]), ST'Double_Number = BYT([H8, H9]) in mk_Key_Constant((hd X0Y0), (hd (tl X0Y0)), (hd V0W), (hd (tl V0W)), (hd ST), (hd (tl ST)))Main_loop' (Message_in_blocks_plus_empty_Message * Key_Constant -> Number)	Main_loop(M, KC) ==let mk_Key_Constant(X, Y, V, W, S, T)'Key_Constant = KC in (if ((len M) = 0)then XOR(X, Y)else let Mi'Number = (hd M) in let V''Number = CYC(V) in let E'Number = XOR(V', W), X''Number = XOR(X, Mi), Y''Number = XOR(Y, Mi) in let F'Number = ADD(E, Y'), G'Number = ADD(E, X') in let F''Number = OR(F, A), G''Number = OR(G, B) in let F'''Number = AND(F', C), G'''Number = AND(G', D) in let X'''Number = MUL1(X', F''), Y'''Number = MUL2A(Y', G'') in Main_loop((tl M), mk_Key_Constant(X'', Y'', V', W, S, T)))Z' (Message_in_blocks * Key -> Number)	Z(M, K) ==let KC'Key_Constant = Prelude(K) in let S'Number = (KC.S), T'Number = (KC.T) in let M''seq1 of (Number) = ((M ^ [S]) ^ [T]) in Main_loop(M', KC)MAC' (Message_in_bits * Key -> Number)	MAC(M, K) ==let M''Message_in_bits = Pad_out_Message(M) in let M'''Message_in_blocks = Form_Message_into_blocks(M') in (if ((len M'') <= Maximum_No_of_blocks_for_MAC)then Z(M'', K)else let M''''seq1 of (Number) = ([Z(Get_head_in_blocks(M'', Maximum_No_of_blocks_for_MAC), K)] ^ Get_tail_in_blocks(M'', Maximum_No_of_blocks_for_MAC)) in Z_of_SEG(M''', K, Maximum_No_of_blocks_for_MAC_plus_1))Z_of_SEG' (Message_in_blocks * Key * nat -> Number)	Z_of_SEG(M, K, No_blocks) ==(if ((len M) <= No_blocks)then Z(M, K)else let M''seq1 of (Number) = ([Z(Get_head_in_blocks(M, No_blocks), K)] ^ Get_tail_in_blocks(M, No_blocks)) in Z_of_SEG(M', K, No_blocks))Get_tail_in_bits' (Message_in_bits * nat -> Message_in_bits)	Get_tail_in_bits(M, No_bits) ==(if (No_bits = 0)then Melse Get_tail_in_bits((tl M), (No_bits - 1)))	pre ((len M) >= No_bits)Get_head_in_bits' (Message_in_bits * nat -> Message_in_bits)	Get_head_in_bits(M, No_bits) ==(if (No_bits = 0)then [(hd M)]else ([(hd M)] ^ Get_head_in_bits((tl M), (No_bits - 1))))	pre (((len M) >= No_bits) and (No_bits >= 1))Get_tail_in_blocks' (Message_in_blocks * nat -> Message_in_blocks)	Get_tail_in_blocks(M, No_blocks) ==(if (No_blocks = 0)then Melse Get_tail_in_blocks((tl M), (No_blocks - 1)))	pre ((len M) >= No_blocks)Get_head_in_blocks' (Message_in_blocks * nat -> Message_in_blocks)	Get_head_in_blocks(M, No_blocks) ==(if (No_blocks = 0)then [(hd M)]else ([(hd M)] ^ Get_head_in_blocks((tl M), (No_blocks - 1))))	pre (((len M) >= No_blocks) and (No_blocks >= 1))end DEFAULT
