RESULT:result:-1:-1,-1:module PacemakerDDDexports alldefinitionsstatic private LRL'nat = 60static private ARP'nat = 250static private VRP'nat = 320static private PVARP'nat = 250static private AVD'nat = 150static private VAD'nat = 850static private SenseTimeline = set of ((((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Chamber))))static private Chamber = (<ATRIUM> | <VENTRICLE>)static private Time = intstatic private Alarm = natstatic private ReactionTimeline = set of ((((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Chamber))))Pacemaker' ((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`SenseTimeline) -> (unresolved PacemakerDDD`ReactionTimeline))	Pacemaker(t, s) ==(PM(mk_(1, t, s, {}, 1000, 0, -ARP, -VRP)).1)PM' ((((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`SenseTimeline) * (unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time))) -> ((unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time)))	PM(mk_(i, t, s, r, AA, VA, LastA, LastV)) ==(if (i = t)then mk_(r, AA, VA, LastA, LastV)else (if (mk_(i, <ATRIUM>) in set s)then PM(c((i + 1), t, s, SensedAtrium(i, r, AA, VA, LastA, LastV)))elseif (mk_(i, <VENTRICLE>) in set s)then PM(c((i + 1), t, s, SensedVentricle(i, r, AA, VA, LastA, LastV)))else PM(c((i + 1), t, s, SensedNothing(i, r, AA, VA, LastA, LastV)))))SensedAtrium' ((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time) -> ((unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time)))	SensedAtrium(t, r, AA, VA, LastA, LastV) ==(if (((t - LastA) < ARP) or ((VA > 0) or ((t - LastA) < PVARP)))then SensedNothing(t, r, AA, VA, LastA, LastV)else mk_(r, 0, (t + AVD), t, LastV))SensedVentricle' ((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time) -> ((unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time)))	SensedVentricle(t, r, AA, VA, LastA, LastV) ==(if ((t - LastV) < VRP)then SensedNothing(t, r, AA, VA, LastA, LastV)else mk_(r, (t + VAD), 0, LastA, t))SensedNothing' ((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time) -> ((unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time)))	SensedNothing(t, r, AA, VA, LastA, LastV) ==(if ((AA > 0) and (t >= AA))then mk_((r union {mk_(t, <ATRIUM>)}), 0, (t + AVD), t, LastV)elseif ((VA > 0) and (t >= VA))then mk_((r union {mk_(t, <VENTRICLE>)}), (t + VAD), 0, LastA, t)else mk_(r, AA, VA, LastA, LastV))c' ((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`SenseTimeline) * (((unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time))) -> ((unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`SenseTimeline) * (unresolved PacemakerDDD`ReactionTimeline) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Alarm) * (unresolved PacemakerDDD`Time) * (unresolved PacemakerDDD`Time)))	c(i, t, s, mk_(r, a, v, la, lv)) ==mk_(i, t, s, r, a, v, la, lv)end PacemakerDDD, module PacemakerAATexports alldefinitionsstatic private LRL'nat = 60static private ARP'nat = 250static private SenseTimeline = seq of ((unresolved PacemakerAAT`Sense))static private Sense = (<NONE> | <PULSE>)static private Time = nat1static private ReactionTimeline = seq of ((unresolved PacemakerAAT`Reaction))static private Reaction = (<NONE> | <PULSE>)private Pacemaker((inp'(unresolved PacemakerAAT`SenseTimeline)))r'(unresolved PacemakerAAT`ReactionTimeline)	post let m = {i | [i in set (inds r)] & (r(i) = <PULSE>)} in (((len r) = (len inp)) and (forall x in set m & ((exists [y in set m] & (y > x)) => (exists [z in set m] & ((z >= x) and ((z - x) <= (60000 / LRL)))))))end PacemakerAAT, module PacemakerAAIexports alldefinitionsstatic private LRL'nat = 60static private ARP'nat = 250static private SenseTimeline = seq of ((unresolved PacemakerAAI`Sense))static private Sense = (<NONE> | <PULSE>)static private ReactionTimeline = seq of ((unresolved PacemakerAAI`Reaction))static private Reaction = (<NONE> | <PULSE>)private Pacemaker((inp'(unresolved PacemakerAAI`SenseTimeline)))r'(unresolved PacemakerAAI`ReactionTimeline)	post let m = {i | [i in set (inds r)] & (r(i) = <PULSE>)} in (((len r) = (len inp)) and ((r(1) = <PULSE>) and (forall x in set m & ((exists [y in set m] & (y > x)) => ((exists [z in set m] & ((z >= x) and ((z - x) <= (60000 / LRL)))) or (exists [z in set (inds inp)] & ((z >= x) and (((z - x) > ARP) and (inp(z) = <PULSE>)))))))))end PacemakerAAI, module PacemakerDOOexports alldefinitionsstatic private Time = natstatic private SensedTimeline = set of ((((unresolved PacemakerDOO`Chamber) * (unresolved PacemakerDOO`Time))))static private Chamber = (<ATRIA> | <VENTRICLE>)static private ReactionTimeline = set of ((((unresolved PacemakerDOO`Chamber) * (unresolved PacemakerDOO`Time))))static private LRL'nat = 60static private URL'nat = 120static private FixedAV'nat = 150private Pacemaker((mk_(inp, n)'((unresolved PacemakerDOO`SensedTimeline) * nat1)))r'(unresolved PacemakerDOO`ReactionTimeline)	post let nPulsesAtria = (card {i | [i in set r] & ((i.1) = <ATRIA>)}), nPulsesVentricle = (card {i | [i in set r] & ((i.1) = <VENTRICLE>)}) in (((nPulsesAtria / n) >= ((LRL / 60) / 1000)) and (((nPulsesVentricle / n) <= ((URL / 60) / 1000)) and (forall mk_(<ATRIA>, ta) in set r & (exists [mk_(<VENTRICLE>, tv) in set r] & (tv = (ta + FixedAV))))))end PacemakerDOO, module PacemakerAOOexports alldefinitionsstatic private LRL'nat = 60static private SenseTimeline = map ((unresolved PacemakerAOO`Time)) to ((unresolved PacemakerAOO`Sense))static private Sense = (<NONE> | <PULSE>)static private Time = nat1static private ReactionTimeline = map ((unresolved PacemakerAOO`Time)) to ((unresolved PacemakerAOO`Reaction))static private Reaction = (<NONE> | <PULSE>)private Pacemaker((inp'(unresolved PacemakerAOO`SenseTimeline)))r'(unresolved PacemakerAOO`ReactionTimeline)	post let m = {i | [i in set (dom r)] & (r(i) = <PULSE>)} in ((((card (dom r)) = (card (dom inp))) and ((card (dom inp)) > 1)) => ((r(1) = <PULSE>) and (forall x in set m & ((exists [y in set m] & (y > x)) => (exists [y in set m] & (((abs (x - y)) <= (60000 / LRL)) and (x <> y)))))))end PacemakerAOO, module PacemakerAOORexports alldefinitionsstatic private Time = natstatic private SenseTimeline = seq of ((((unresolved PacemakerAOOR`Sense) * [(unresolved PacemakerAOOR`AccelerometerData)] * (unresolved PacemakerAOOR`Time))))	inv stl == let l = [(stl(i).2) | i in set (inds stl) & ((stl(i).2) <> nil)] in ((l(1) = HIGH) and (forall i in set (inds l) & ((l(i) < MED) => (l((i - 1)) > MED))))static private AccelerometerData = nat	inv n == (n < 3)static private Sense = (<NONE> | <PULSE>)static private ReactionTimeline = seq of ((((unresolved PacemakerAOOR`Reaction) * (unresolved PacemakerAOOR`Time))))static private Reaction = (<NONE> | <PULSE>)state Sigmaof[LRL'nat, LRLs'nat, LRLf'nat, MSR'nat, ActivityThreshold'(unresolved PacemakerAOOR`AccelerometerData), ReactionTime'nat, RecoveryTime'nat, rateChangePlan'map (nat) to (((<DEC> | <INC>)))]	init s == (s = mk_Sigma(60, 0, 2, 120, MED, 10, 2, {}))Pacemaker ((unresolved PacemakerAOOR`SenseTimeline) ==> (unresolved PacemakerAOOR`ReactionTimeline))	Pacemaker(inp) ==return ((if (inp = [])then []else ([HeartController((hd inp))] ^ Pacemaker((tl inp)))))HeartController ((((unresolved PacemakerAOOR`Sense) * [(unresolved PacemakerAOOR`AccelerometerData)] * (unresolved PacemakerAOOR`Time))) ==> (((unresolved PacemakerAOOR`Reaction) * (unresolved PacemakerAOOR`Time))))	HeartController(mk_(-, acc, time)) ==(if (acc <> nil)thenAdjustRate(acc, time);if (time in set (dom rateChangePlan))thenapplyChange(rateChangePlan(time));if (LRLf <= LRLs)then(LRLs '= 1;return (mk_(<PULSE>, time)))else(LRLs '= (LRLs + 1);return (mk_(<NONE>, time))))applyChange ((<DEC> | <INC>) ==> ())	applyChange(a) ==if (a = <INC>)thenLRLf '= 1elseLRLf '= 2AdjustRate ((unresolved PacemakerAOOR`AccelerometerData) * (unresolved PacemakerAOOR`Time) ==> ())	AdjustRate(act, time) ==if (act > ActivityThreshold)thenrateChangePlan '= {(time + (10 * 2)) |-> <INC>}elserateChangePlan '= {(time + (120 * 2)) |-> <DEC>}static private MED'(unresolved PacemakerAOOR`AccelerometerData) = 3static private LOW'(unresolved PacemakerAOOR`AccelerometerData) = 0static private MED'(unresolved PacemakerAOOR`AccelerometerData) = 1static private HIGH'(unresolved PacemakerAOOR`AccelerometerData) = 2static private sensedData'seq of ((((unresolved PacemakerAOOR`Sense) * [(unresolved PacemakerAOOR`AccelerometerData)] * (unresolved PacemakerAOOR`Time)))) = (((([mk_(<NONE>, nil, i) | i in set {1, ... ,120}] ^ [mk_(<NONE>, <HIGH>, 121)]) ^ [mk_(<NONE>, nil, i) | i in set {121, ... ,190}]) ^ [mk_(<NONE>, <LOW>, 191)]) ^ [mk_(<NONE>, nil, i) | i in set {192, ... ,436}])end PacemakerAOOR, module RateControllerexports alldefinitionsstatic private Input = map ((unresolved RateController`Time)) to ((unresolved RateController`ActivityData))static private Time = nat1static private ActivityData = nat1	inv a == (a <= 7)static private RF = nat1	inv rf == (rf <= 16)static private Output = map ((unresolved RateController`Time)) to ((unresolved RateController`PPM))static private PPM = nat1	inv ppm == ((ppm >= 30) and (ppm <= 175))static private LRL'(unresolved RateController`PPM) = 60static private MSR'(unresolved RateController`PPM) = 120static private Threshold'(unresolved RateController`ActivityData) = 6static private ReactionTime'(unresolved RateController`Time) = 150static private ResponseFactor'(unresolved RateController`RF) = 8static private RecoveryTime'(unresolved RateController`Time) = 5private Simulate((inp'(unresolved RateController`Input)))out'(unresolved RateController`Output)	pre (0 not in set (dom inp))	post (forall t in set (dom inp) & (((out(t) = MSR) => ((inp((t - ReactionTime)) > Threshold) or (out((t - 1)) = MSR))) and (forall t in set ((dom inp) \ {1}) & ((out(t) = LRL) => ((inp((t - RecoveryTime)) < Threshold) or (out((t - 1)) = LRL))))))end RateController
