WARNING:PacemakerDOO.vdmsl:5000:72,10:Definition 'Pacemaker' not used.
WARNING:RateController.vdmsl:5008:104,14:t at 101'13 hidden by t.
WARNING:PacemakerAOOR.vdmsl:5000:136,4:Definition 'MED' not used.
WARNING:PacemakerAAI.vdmsl:5000:71,10:Definition 'Pacemaker' not used.
WARNING:PacemakerAOOR.vdmsl:5000:139,11:Definition 'sensedData' not used.
WARNING:PacemakerAOOR.vdmsl:5000:135,4:Definition 'LOW' not used.
WARNING:PacemakerAAT.vdmsl:5000:46,4:Definition 'ARP' not used.
WARNING:PacemakerAOOR.vdmsl:5007:134,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5000:86,16:Definition 'ReactionTime' not used.
WARNING:PacemakerAAT.vdmsl:5000:73,10:Definition 'Pacemaker' not used.
WARNING:PacemakerAOO.vdmsl:5000:102,10:Definition 'Pacemaker' not used.
WARNING:RateController.vdmsl:5000:99,9:Definition 'Simulate' not used.
WARNING:PacemakerAOOR.vdmsl:5000:87,16:Definition 'RecoveryTime' not used.
WARNING:PacemakerAOOR.vdmsl:5000:81,7:Definition 'LRL' not used.
WARNING:PacemakerAOOR.vdmsl:5000:84,7:Definition 'MSR' not used.
WARNING:PacemakerAAT.vdmsl:5000:57,5:Definition 'Time' not used.
WARNING:PacemakerAOOR.vdmsl:5007:136,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5007:136,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5007:134,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5007:134,4:Duplicate definition' MED.
WARNING:PacemakerDOO.vdmsl:5000:72,19:Definition 'inp' not used.
WARNING:PacemakerAOOR.vdmsl:5007:134,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5007:134,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5007:136,4:Duplicate definition' MED.
WARNING:PacemakerDDD.vdmsl:5000:7,4:Definition 'LRL' not used.
WARNING:PacemakerDDD.vdmsl:5012:32,3:Recursive function has no measure.
WARNING:RateController.vdmsl:5000:90,18:Definition 'ResponseFactor' not used.
WARNING:PacemakerAOOR.vdmsl:5007:136,4:Duplicate definition' MED.
WARNING:PacemakerAOOR.vdmsl:5007:136,4:Duplicate definition' MED.
WARNING:PacemakerDDD.vdmsl:5000:28,10:Definition 'Pacemaker' not used.
RESULT:result:-1:-1,-1:module PacemakerDDDexports alldefinitionsstatic private LRL'nat = 60static private ARP'nat = 250static private VRP'nat = 320static private PVARP'nat = 250static private AVD'nat = 150static private VAD'nat = 850static private SenseTimeline = set of ((Time * Chamber))static private Chamber = (<ATRIUM> | <VENTRICLE>)static private Time = intstatic private Alarm = natstatic private ReactionTimeline = set of ((Time * Chamber))Pacemaker' (Time * SenseTimeline -> ReactionTimeline)	Pacemaker(t, s) ==(PM(mk_(1, t, s, {}, 1000, 0, -ARP, -VRP)).1)PM' ((Time * Time * SenseTimeline * ReactionTimeline * Alarm * Alarm * Time * Time) -> (ReactionTimeline * Alarm * Alarm * Time * Time))	PM(mk_(i, t, s, r, AA, VA, LastA, LastV)) ==(if (i = t)then mk_(r, AA, VA, LastA, LastV)else (if (mk_(i, <ATRIUM>) in set s)then PM(c((i + 1), t, s, SensedAtrium(i, r, AA, VA, LastA, LastV)))elseif (mk_(i, <VENTRICLE>) in set s)then PM(c((i + 1), t, s, SensedVentricle(i, r, AA, VA, LastA, LastV)))else PM(c((i + 1), t, s, SensedNothing(i, r, AA, VA, LastA, LastV)))))SensedAtrium' (Time * ReactionTimeline * Alarm * Alarm * Time * Time -> (ReactionTimeline * Alarm * Alarm * Time * Time))	SensedAtrium(t, r, AA, VA, LastA, LastV) ==(if (((t - LastA) < ARP) or ((VA > 0) or ((t - LastA) < PVARP)))then SensedNothing(t, r, AA, VA, LastA, LastV)else mk_(r, 0, (t + AVD), t, LastV))SensedVentricle' (Time * ReactionTimeline * Alarm * Alarm * Time * Time -> (ReactionTimeline * Alarm * Alarm * Time * Time))	SensedVentricle(t, r, AA, VA, LastA, LastV) ==(if ((t - LastV) < VRP)then SensedNothing(t, r, AA, VA, LastA, LastV)else mk_(r, (t + VAD), 0, LastA, t))SensedNothing' (Time * ReactionTimeline * Alarm * Alarm * Time * Time -> (ReactionTimeline * Alarm * Alarm * Time * Time))	SensedNothing(t, r, AA, VA, LastA, LastV) ==(if ((AA > 0) and (t >= AA))then mk_((r union {mk_(t, <ATRIUM>)}), 0, (t + AVD), t, LastV)elseif ((VA > 0) and (t >= VA))then mk_((r union {mk_(t, <VENTRICLE>)}), (t + VAD), 0, LastA, t)else mk_(r, AA, VA, LastA, LastV))c' (Time * Time * SenseTimeline * (ReactionTimeline * Alarm * Alarm * Time * Time) -> (Time * Time * SenseTimeline * ReactionTimeline * Alarm * Alarm * Time * Time))	c(i, t, s, mk_(r, a, v, la, lv)) ==mk_(i, t, s, r, a, v, la, lv)end PacemakerDDD, module RateControllerexports alldefinitionsstatic private Input = map (Time) to (ActivityData)static private Time = nat1static private ActivityData = nat1	inv a == (a <= 7)static private RF = nat1	inv rf == (rf <= 16)static private Output = map (Time) to (PPM)static private PPM = nat1	inv ppm == ((ppm >= 30) and (ppm <= 175))static private LRL'PPM = 60static private MSR'PPM = 120static private Threshold'ActivityData = 6static private ReactionTime'Time = 150static private ResponseFactor'RF = 8static private RecoveryTime'Time = 5private Simulate((inp'Input))out'Output	pre (0 not in set (dom inp))	post (forall t in set (dom inp) & (((out(t) = MSR) => ((inp((t - ReactionTime)) > Threshold) or (out((t - 1)) = MSR))) and (forall t in set ((dom inp) \ {1}) & ((out(t) = LRL) => ((inp((t - RecoveryTime)) < Threshold) or (out((t - 1)) = LRL))))))end RateController, module PacemakerAOOexports alldefinitionsstatic private LRL'nat = 60static private SenseTimeline = map (Time) to (Sense)static private Sense = (<NONE> | <PULSE>)static private Time = nat1static private ReactionTimeline = map (Time) to (Reaction)static private Reaction = (<NONE> | <PULSE>)private Pacemaker((inp'SenseTimeline))r'ReactionTimeline	post let m'set of (Time) = {i | [i in set (dom r)] & (r(i) = <PULSE>)} in ((((card (dom r)) = (card (dom inp))) and ((card (dom inp)) > 1)) => ((r(1) = <PULSE>) and (forall x in set m & ((exists [y in set m] & (y > x)) => (exists [y in set m] & (((abs (x - y)) <= (60000 / LRL)) and (x <> y)))))))end PacemakerAOO, module PacemakerAAIexports alldefinitionsstatic private LRL'nat = 60static private ARP'nat = 250static private SenseTimeline = seq of (Sense)static private Sense = (<NONE> | <PULSE>)static private ReactionTimeline = seq of (Reaction)static private Reaction = (<NONE> | <PULSE>)private Pacemaker((inp'SenseTimeline))r'ReactionTimeline	post let m'set of (nat1) = {i | [i in set (inds r)] & (r(i) = <PULSE>)} in (((len r) = (len inp)) and ((r(1) = <PULSE>) and (forall x in set m & ((exists [y in set m] & (y > x)) => ((exists [z in set m] & ((z >= x) and ((z - x) <= (60000 / LRL)))) or (exists [z in set (inds inp)] & ((z >= x) and (((z - x) > ARP) and (inp(z) = <PULSE>)))))))))end PacemakerAAI, module PacemakerAOORexports alldefinitionsstatic private Time = natstatic private SenseTimeline = seq of ((Sense * [AccelerometerData] * Time))	inv stl == let l'seq of ([AccelerometerData]) = [(stl(i).2) | i in set (inds stl) & ((stl(i).2) <> nil)] in ((l(1) = HIGH) and (forall i in set (inds l) & ((l(i) < MED) => (l((i - 1)) > MED))))static private AccelerometerData = nat	inv n == (n < 3)static private Sense = (<NONE> | <PULSE>)static private ReactionTimeline = seq of ((Reaction * Time))static private Reaction = (<NONE> | <PULSE>)state Sigmaof[LRL'nat, LRLs'nat, LRLf'nat, MSR'nat, ActivityThreshold'AccelerometerData, ReactionTime'nat, RecoveryTime'nat, rateChangePlan'map (nat) to ((<DEC> | <INC>))]	init s == (s = mk_Sigma(60, 0, 2, 120, MED, 10, 2, {}))Pacemaker (SenseTimeline ==> ReactionTimeline)	Pacemaker(inp) ==return ((if (inp = [])then []else ([HeartController((hd inp))] ^ Pacemaker((tl inp)))))HeartController ((Sense * [AccelerometerData] * Time) ==> (Reaction * Time))	HeartController(mk_(-, acc, time)) ==(if (acc <> nil)thenAdjustRate(acc, time);if (time in set (dom rateChangePlan))thenapplyChange(rateChangePlan(time));if (LRLf <= LRLs)then(LRLs '= 1;return (mk_(<PULSE>, time)))else(LRLs '= (LRLs + 1);return (mk_(<NONE>, time))))applyChange ((<DEC> | <INC>) ==> ())	applyChange(a) ==if (a = <INC>)thenLRLf '= 1elseLRLf '= 2AdjustRate (AccelerometerData * Time ==> ())	AdjustRate(act, time) ==if (act > ActivityThreshold)thenrateChangePlan '= {(time + (10 * 2)) |-> <INC>}elserateChangePlan '= {(time + (120 * 2)) |-> <DEC>}static private MED'AccelerometerData = 3static private LOW'AccelerometerData = 0static private MED'AccelerometerData = 1static private HIGH'AccelerometerData = 2static private sensedData'seq of ((Sense * [AccelerometerData] * Time)) = (((([mk_(<NONE>, nil, i) | i in set {1, ... ,120}] ^ [mk_(<NONE>, <HIGH>, 121)]) ^ [mk_(<NONE>, nil, i) | i in set {121, ... ,190}]) ^ [mk_(<NONE>, <LOW>, 191)]) ^ [mk_(<NONE>, nil, i) | i in set {192, ... ,436}])end PacemakerAOOR, module PacemakerDOOexports alldefinitionsstatic private Time = natstatic private SensedTimeline = set of ((Chamber * Time))static private Chamber = (<ATRIA> | <VENTRICLE>)static private ReactionTimeline = set of ((Chamber * Time))static private LRL'nat = 60static private URL'nat = 120static private FixedAV'nat = 150private Pacemaker((mk_(inp, n)'(SensedTimeline * nat1)))r'ReactionTimeline	post let nPulsesAtria'nat = (card {i | [i in set r] & ((i.1) = <ATRIA>)}), nPulsesVentricle'nat = (card {i | [i in set r] & ((i.1) = <VENTRICLE>)}) in (((nPulsesAtria / n) >= ((LRL / 60) / 1000)) and (((nPulsesVentricle / n) <= ((URL / 60) / 1000)) and (forall mk_(<ATRIA>, ta) in set r & (exists [mk_(<VENTRICLE>, tv) in set r] & (tv = (ta + FixedAV))))))end PacemakerDOO, module PacemakerAATexports alldefinitionsstatic private LRL'nat = 60static private ARP'nat = 250static private SenseTimeline = seq of (Sense)static private Sense = (<NONE> | <PULSE>)static private Time = nat1static private ReactionTimeline = seq of (Reaction)static private Reaction = (<NONE> | <PULSE>)private Pacemaker((inp'SenseTimeline))r'ReactionTimeline	post let m'set of (nat1) = {i | [i in set (inds r)] & (r(i) = <PULSE>)} in (((len r) = (len inp)) and (forall x in set m & ((exists [y in set m] & (y > x)) => (exists [z in set m] & ((z >= x) and ((z - x) <= (60000 / LRL)))))))end PacemakerAAT
