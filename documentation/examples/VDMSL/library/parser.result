RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Id = natstatic private String = (<nil> | seq of (char))static private Edition = (<nil> | nat)	inv e == (e in set ({1, ... ,50} union {<nil>}))static private Month = (<nil> | nat)	inv e == (e in set ({1, ... ,12} union {<nil>}))static private Number = (<nil> | nat1)static private Pages = (<nil> | nat1)static private Series = (<nil> | nat1)static private Volume = (<nil> | nat1)static private Year = (<nil> | nat)	inv e == (e in set ({1800, ... ,1998} union {<nil>}))static private Article = compose Article of id'(unresolved DEFAULT`Id), author'(unresolved DEFAULT`String), journal'(unresolved DEFAULT`String), month'(unresolved DEFAULT`Month), note'(unresolved DEFAULT`String), number'(unresolved DEFAULT`Number), pages'(unresolved DEFAULT`Pages), title'(unresolved DEFAULT`String), volume'(unresolved DEFAULT`Volume), year'(unresolved DEFAULT`Year) endstatic private Book = compose Book of id'(unresolved DEFAULT`Id), address'(unresolved DEFAULT`String), author'(unresolved DEFAULT`String), edition'(unresolved DEFAULT`Edition), editor'(unresolved DEFAULT`String), month'(unresolved DEFAULT`Month), note'(unresolved DEFAULT`String), publisher'(unresolved DEFAULT`String), series'(unresolved DEFAULT`Series), title'(unresolved DEFAULT`String), volume'(unresolved DEFAULT`Volume), year'(unresolved DEFAULT`Year) endstatic private Inproceeding = compose Inproceeding of id'(unresolved DEFAULT`Id), address'(unresolved DEFAULT`String), author'(unresolved DEFAULT`String), booktitle'(unresolved DEFAULT`String), editor'(unresolved DEFAULT`String), month'(unresolved DEFAULT`Month), note'(unresolved DEFAULT`String), organization'(unresolved DEFAULT`String), pages'(unresolved DEFAULT`Pages), publisher'(unresolved DEFAULT`String), title'(unresolved DEFAULT`String), year'(unresolved DEFAULT`Year) endstatic private Manual = compose Manual of id'(unresolved DEFAULT`Id), address'(unresolved DEFAULT`String), author'(unresolved DEFAULT`String), edition'(unresolved DEFAULT`Edition), month'(unresolved DEFAULT`Month), note'(unresolved DEFAULT`String), organization'(unresolved DEFAULT`String), title'(unresolved DEFAULT`String), year'(unresolved DEFAULT`Year) endstatic private Techreport = compose Techreport of id'(unresolved DEFAULT`Id), address'(unresolved DEFAULT`String), author'(unresolved DEFAULT`String), institution'(unresolved DEFAULT`String), month'(unresolved DEFAULT`Month), note'(unresolved DEFAULT`String), number'(unresolved DEFAULT`Number), title'(unresolved DEFAULT`String), type'(unresolved DEFAULT`String), year'(unresolved DEFAULT`Year) endstatic private Record = ((unresolved DEFAULT`Article) | (unresolved DEFAULT`Book) | (unresolved DEFAULT`Inproceeding) | (unresolved DEFAULT`Manual) | (unresolved DEFAULT`Techreport))static private Recordtype = (<article> | <book> | <inproceeding> | <manual> | <techreport>)static private Value = ((unresolved DEFAULT`Edition) | (unresolved DEFAULT`Id) | (unresolved DEFAULT`Month) | (unresolved DEFAULT`Number) | (unresolved DEFAULT`Pages) | (unresolved DEFAULT`Series) | (unresolved DEFAULT`String) | (unresolved DEFAULT`Volume) | (unresolved DEFAULT`Year))static private Valuetype = (<address> | <author> | <booktitle> | <edition> | <editor> | <id> | <institution> | <journal> | <month> | <note> | <number> | <organization> | <pages> | <publisher> | <series> | <title> | <type> | <volume> | <year>)state mgdof[dB'set of ((unresolved DEFAULT`Record))]	init dB == (dB = mk_mgd({}))field' ((unresolved DEFAULT`Recordtype) +> set of ((unresolved DEFAULT`Valuetype)))	field(rt) ==(required(rt) union optional(rt))	post (RESULT = (required(rt) union optional(rt)))get' (set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Id) +> (unresolved DEFAULT`Record))	get(dB, i) ==let record in set dB in (if ((record.id) = i)then recordelse get((dB \ {record}), i))	pre (i in set usedIds(dB))	post (((RESULT.id) = i) and (RESULT in set dB))CardDb' (set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Id) +> nat)	CardDb(dB, -) ==(card dB)getvalue' ((unresolved DEFAULT`Valuetype) * set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Id) +> (unresolved DEFAULT`Value))	getvalue(valuetype, dB, i) ==(cases valuetype 'case <title> -> (get(dB, i).title),case <author> -> (get(dB, i).author),case <journal> -> (get(dB, i).journal),case <year> -> (get(dB, i).year),case <booktitle> -> (get(dB, i).booktitle),case <institution> -> (get(dB, i).institution),case <publisher> -> (get(dB, i).publisher)end)	pre ((i in set usedIds(dB)) and (valuetype in set {<title>, <author>, <journal>, <year>, <booktitle>, <institution>, <publisher>}))	post (((valuetype = <title>) and (RESULT = (get(dB, i).title))) or (((valuetype = <author>) and (RESULT = (get(dB, i).author))) or (((valuetype = <journal>) and (RESULT = (get(dB, i).journal))) or (((valuetype = <year>) and (RESULT = (get(dB, i).year))) or (((valuetype = <booktitle>) and (RESULT = (get(dB, i).booktitle))) or (((valuetype = <institution>) and (RESULT = (get(dB, i).institution))) or ((valuetype = <publisher>) and (RESULT = (get(dB, i).publisher)))))))))iscomplete' (set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Id) +> bool)	iscomplete(dB, i) ==(required(recordtype(dB, i)) = {f | [f in set required(recordtype(dB, i))] & (not isempty(getvalue(f, dB, i)))})	pre (i in set usedIds(dB))	post ((forall x in set required(recordtype(dB, i)) & (not isempty(getvalue(x, dB, i)))) <=> RESULT)isedition' ((unresolved DEFAULT`Value) +> bool)	isedition(v) ==((v in set {1, ... ,50}) or (v = <nil>))isempty' ((unresolved DEFAULT`Value) +> bool)	isempty(value) ==(if (value = <nil>)then trueelse false)	post ((value = <nil>) <=> RESULT)isidentical' (set of ((unresolved DEFAULT`Record)) +> bool)	isidentical(dB) ==(if (dB = {})then falseelse let record1 in set dB in (if iscomplete(dB, (record1.id))then isidentical2(dB, (dB \ {record1}), dB, record1)else isidentical((dB \ {record1}))))	post ((exists [i, j in set usedIds(dB)] & ((i <> j) and (iscomplete(dB, i) and (iscomplete(dB, j) and ((recordtype(dB, i) = recordtype(dB, j)) and (forall x in set required(recordtype(dB, i)) & (getvalue(x, dB, i) = getvalue(x, dB, j)))))))) <=> RESULT)isidentical2' (set of ((unresolved DEFAULT`Record)) * set of ((unresolved DEFAULT`Record)) * set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Record) +> bool)	isidentical2(dB1, dB2, olddB, record1) ==(if (dB2 = {})then isidentical((dB1 \ {record1}))else let record2 in set dB2 in (if iscomplete(olddB, (record2.id))then isidentical3(dB1, dB2, olddB, record1, record2, required(recordtype(olddB, (record1.id))))else isidentical2(dB1, (dB2 \ {record2}), olddB, record1)))isidentical3' (set of ((unresolved DEFAULT`Record)) * set of ((unresolved DEFAULT`Record)) * set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Record) * (unresolved DEFAULT`Record) * set of ((unresolved DEFAULT`Valuetype)) +> bool)	isidentical3(dB1, dB2, olddB, record1, record2, requiredfields) ==(if (requiredfields = {})then trueelse let field in set requiredfields in (if (getvalue(field, olddB, (record1.id)) <> getvalue(field, olddB, (record2.id)))then isidentical2(dB1, (dB2 \ {record2}), olddB, record1)else isidentical3(dB1, dB2, olddB, record1, record2, (requiredfields \ {field}))))ismonth' ((unresolved DEFAULT`Value) +> bool)	ismonth(v) ==is_(v, nat)isnumber' ((unresolved DEFAULT`Value) +> bool)	isnumber(v) ==(is_(v, nat) or (v = <nil>))ispages' ((unresolved DEFAULT`Value) +> bool)	ispages(v) ==(is_(v, nat) or (v = <nil>))isstring' ((unresolved DEFAULT`Value) +> bool)	isstring(v) ==(if (not is_(v, real))then (if (v = [])then trueelseif is_((hd v), char)then isstring((tl v))else false)else false)issubstring' ((unresolved DEFAULT`String) * (unresolved DEFAULT`String) +> bool)	issubstring(string1, string2) ==(if (string1 = [])then trueelseif ((string2 = []) or ((string1 = <nil>) or (string2 = <nil>)))then falseelseif ((hd string1) = (hd string2))then issubstring2((tl string1), (tl string2), string1)else issubstring(string1, (tl string2)))	post (((not (string2 = <nil>)) and (exists [i, j in set (inds string2)] & (substring(string2, i, j) = string1))) <=> RESULT)issubstring2' ((unresolved DEFAULT`String) * (unresolved DEFAULT`String) * (unresolved DEFAULT`String) +> bool)	issubstring2(string1, string2, oldstring1) ==(if (string1 = [])then trueelseif (string2 = [])then falseelseif ((hd string1) = (hd string2))then issubstring2((tl string1), (tl string2), oldstring1)else issubstring(oldstring1, string2))isvalueoffield' ((unresolved DEFAULT`Value) * (unresolved DEFAULT`Valuetype) +> bool)	isvalueoffield(v, f) ==(cases f 'case <address> -> isstring(v),case <author> -> isstring(v),case <booktitle> -> isstring(v),case <edition> -> isedition(v),case <editor> -> isstring(v),case <institution> -> isstring(v),case <journal> -> isstring(v),case <month> -> ismonth(v),case <note> -> isstring(v),case <number> -> isnumber(v),case <organization> -> isstring(v),case <pages> -> ispages(v),case <publisher> -> isstring(v),case <title> -> isstring(v),case <type> -> isstring(v),case <volume> -> isvolume(v),case <year> -> isyear(v)end)	post ((((f = <address>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <author>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <booktitle>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <edition>) and (exists [x'(unresolved DEFAULT`Edition)] & (x = v))) or (((f = <editor>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <institution>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <journal>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <month>) and (exists [x'(unresolved DEFAULT`Month)] & (x = v))) or (((f = <note>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <number>) and (exists [x'(unresolved DEFAULT`Number)] & (x = v))) or (((f = <organization>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <pages>) and (exists [x'(unresolved DEFAULT`Pages)] & (x = v))) or (((f = <publisher>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <title>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <type>) and (exists [x'(unresolved DEFAULT`String)] & (x = v))) or (((f = <volume>) and (exists [x'(unresolved DEFAULT`Volume)] & (x = v))) or ((f = <year>) and (exists [x'(unresolved DEFAULT`Year)] & (x = v))))))))))))))))))) <=> RESULT)isvolume' ((unresolved DEFAULT`Value) +> bool)	isvolume(v) ==(is_(v, nat) or (v = <nil>))isyear' ((unresolved DEFAULT`Value) +> bool)	isyear(v) ==((v in set {1800, ... ,1998}) or (v = <nil>))optional' ((unresolved DEFAULT`Recordtype) +> set of ((unresolved DEFAULT`Valuetype)))	optional(rt) ==(cases rt 'case <article> -> {<volume>, <number>, <month>, <note>},case <book> -> {<volume>, <series>, <address>, <edition>, <month>, <note>, <publisher>},case <inproceeding> -> {<editor>, <pages>, <organization>, <publisher>, <address>, <pages>, <organization>},case <manual> -> {<edition>, <note>, <organization>, <month>, <address>, <author>, <organization>, <year>},case <techreport> -> {<number>, <note>, <type>, <month>, <address>}end)	post (((rt = <article>) and (RESULT = {<volume>, <number>, <month>, <note>})) or (((rt = <book>) and (RESULT = {<volume>, <series>, <address>, <edition>, <month>, <note>, <publisher>})) or (((rt = <inproceeding>) and (RESULT = {<editor>, <pages>, <organization>, <publisher>, <address>, <pages>, <organization>})) or (((rt = <manual>) and (RESULT = {<edition>, <note>, <organization>, <month>, <address>, <author>, <organization>, <year>})) or ((rt = <techreport>) and (RESULT = {<number>, <note>, <type>, <month>, <address>}))))))recordtype' (set of ((unresolved DEFAULT`Record)) * (unresolved DEFAULT`Id) +> (unresolved DEFAULT`Recordtype))	recordtype(dB, i) ==(if is_(get(dB, i), Article)then <article>elseif is_(get(dB, i), Book)then <book>elseif is_(get(dB, i), Inproceeding)then <inproceeding>elseif is_(get(dB, i), Manual)then <manual>else <techreport>)	pre (i in set usedIds(dB))	post ((is_(get(dB, i), Article) and (RESULT = <article>)) or ((is_(get(dB, i), Book) and (RESULT = <book>)) or ((is_(get(dB, i), Inproceeding) and (RESULT = <inproceeding>)) or ((is_(get(dB, i), Manual) and (RESULT = <manual>)) or (is_(get(dB, i), Techreport) and (RESULT = <techreport>))))))required' ((unresolved DEFAULT`Recordtype) +> set of ((unresolved DEFAULT`Valuetype)))	required(rt) ==(cases rt 'case <article> -> {<title>, <author>, <journal>, <year>},case <book> -> {<title>, <author>, <publisher>, <year>},case <inproceeding> -> {<title>, <author>, <booktitle>, <year>},case <manual> -> {<title>},case <techreport> -> {<title>, <author>, <institution>, <year>}end)	post (((rt = <article>) and (RESULT = {<title>, <author>, <journal>, <year>})) or (((rt = <book>) and (RESULT = {<title>, <author>, <publisher>, <year>})) or (((rt = <inproceeding>) and (RESULT = {<title>, <author>, <booktitle>, <year>})) or (((rt = <manual>) and (RESULT = {<title>})) or ((rt = <techreport>) and (RESULT = {<title>, <author>, <institution>, <year>}))))))private substring((s'(unresolved DEFAULT`String)), (i'nat1), (j'nat1))r'(unresolved DEFAULT`String)	pre ((i < j) and (j <= (len s)))	post (exists [s1, s2'(unresolved DEFAULT`String)] & (((len s1) = (i - 1)) and (((len s2) = ((len s) - j)) and (s = ((s1 ^ r) ^ s2)))))usedIds' (set of ((unresolved DEFAULT`Record)) +> set of ((unresolved DEFAULT`Id)))	usedIds(dB) ==idset(dB, {})	post (forall x in set dB & (((x.id) in set RESULT) and (forall i in set RESULT & (exists [x in set dB] & ((x.id) = i)))))idset' (set of ((unresolved DEFAULT`Record)) * set of ((unresolved DEFAULT`Id)) +> set of ((unresolved DEFAULT`Id)))	idset(dB, ids) ==(if (dB = {})then idselse let record in set dB in idset((dB \ {record}), (ids union {(record.id)})))CardRecords' (set of ((unresolved DEFAULT`Record)) * set of ((unresolved DEFAULT`Id)) +> nat)	CardRecords(s, -) ==(card s)CREATE ((unresolved DEFAULT`Recordtype) ==> (unresolved DEFAULT`Id))	CREATE(e) ==(i'nat1 '= 1(while (i in set usedIds(dB)) do i '= (i + 1));cases e '  case <article> -> dB '= (dB union {mk_Article(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <book> -> dB '= (dB union {mk_Book(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <inproceeding> -> dB '= (dB union {mk_Inproceeding(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <manual> -> dB '= (dB union {mk_Manual(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <techreport> -> dB '= (dB union {mk_Techreport(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})esac;return (i))	post (((RESULT not in set usedIds(dB~)) and ((e = <article>) and (dB = (dB~ union {mk_Article(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})))) or (((e = <book>) and (dB = (dB~ union {mk_Book(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)}))) or (((e = <inproceeding>) and (dB = (dB~ union {mk_Inproceeding(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)}))) or (((e = <manual>) and (dB = (dB~ union {mk_Manual(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)}))) or ((e = <techreport>) and (dB = (dB~ union {mk_Techreport(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})))))))UPDATE((i'(unresolved DEFAULT`Id)), (f'(unresolved DEFAULT`Valuetype)), (v'(unresolved DEFAULT`Value)))	ext [wr dB'set of ((unresolved DEFAULT`Record))]	pre ((i in set usedIds(dB)) and ((f in set field(recordtype(dB, i))) and (isvalueoffield(v, f) and (not (iscomplete(dB, i) and isidentical(dB))))))	post ((getvalue(f, dB, i) = v) and (((dB \ {get(dB, i)}) = (dB~ \ {get(dB~, i)})) and (forall x in set (field(recordtype(dB, i)) \ {f}) & (getvalue(x, dB, i) = getvalue(x, dB~, i)))))COMPLETE ((unresolved DEFAULT`Id) ==> bool)	COMPLETE(i) ==return (iscomplete(dB, i))	pre (i in set usedIds(dB))	post (iscomplete(dB, i) <=> RESULT)DELETE((i'(unresolved DEFAULT`Id)))	ext [wr dB'set of ((unresolved DEFAULT`Record))]	pre (i in set usedIds(dB))	post (dB~ = (dB union {get(dB~, i)}))SEARCH ((unresolved DEFAULT`String) ==> set of ((unresolved DEFAULT`Id)))	SEARCH(a) ==(ids'set of ((unresolved DEFAULT`Id)) '= {}for all record in set dB doif issubstring(a, (record.author))thenids '= (ids union {(record.id)})elseids '= ids;return (ids))	post (forall i in set RESULT & (issubstring(a, (get(dB, i).author)) and (not (exists [record in set dB] & (((record.id) not in set RESULT) and issubstring(a, (get(dB, i).author)))))))GET ((unresolved DEFAULT`Id) ==> (unresolved DEFAULT`Record))	GET(i) ==return (get(dB, i))	pre (i in set usedIds(dB))	post (RESULT = get(dB, i))end DEFAULT
