WARNING:library.vdmsl:5012:224,13:Recursive function has no measure.
WARNING:library.vdmsl:5008:185,19:field at 97'1 hidden by field.
WARNING:library.vdmsl:5012:159,12:Recursive function has no measure.
WARNING:library.vdmsl:5012:172,13:Recursive function has no measure.
WARNING:library.vdmsl:5012:181,13:Recursive function has no measure.
WARNING:library.vdmsl:5012:204,9:Recursive function has no measure.
WARNING:library.vdmsl:5008:350,38:x at 349'16 hidden by x.
WARNING:library.vdmsl:5012:214,12:Recursive function has no measure.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Id = natstatic private String = (<nil> | seq of (char))static private Edition = (<nil> | nat)	inv e == (e in set ({1, ... ,50} union {<nil>}))static private Month = (<nil> | nat)	inv e == (e in set ({1, ... ,12} union {<nil>}))static private Number = (<nil> | nat1)static private Pages = (<nil> | nat1)static private Series = (<nil> | nat1)static private Volume = (<nil> | nat1)static private Year = (<nil> | nat)	inv e == (e in set ({1800, ... ,1998} union {<nil>}))static private Article = compose Article of id'Id, author'String, journal'String, month'Month, note'String, number'Number, pages'Pages, title'String, volume'Volume, year'Year endstatic private Book = compose Book of id'Id, address'String, author'String, edition'Edition, editor'String, month'Month, note'String, publisher'String, series'Series, title'String, volume'Volume, year'Year endstatic private Inproceeding = compose Inproceeding of id'Id, address'String, author'String, booktitle'String, editor'String, month'Month, note'String, organization'String, pages'Pages, publisher'String, title'String, year'Year endstatic private Manual = compose Manual of id'Id, address'String, author'String, edition'Edition, month'Month, note'String, organization'String, title'String, year'Year endstatic private Techreport = compose Techreport of id'Id, address'String, author'String, institution'String, month'Month, note'String, number'Number, title'String, type'String, year'Year endstatic private Record = (Article | Book | Inproceeding | Manual | Techreport)static private Recordtype = (<article> | <book> | <inproceeding> | <manual> | <techreport>)static private Value = (Edition | Id | Month | Number | Pages | Series | String | Volume | Year)static private Valuetype = (<address> | <author> | <booktitle> | <edition> | <editor> | <id> | <institution> | <journal> | <month> | <note> | <number> | <organization> | <pages> | <publisher> | <series> | <title> | <type> | <volume> | <year>)state mgdof[dB'set of (Record)]	init dB == (dB = mk_mgd({}))field' (Recordtype +> set of (Valuetype))	field(rt) ==(required(rt) union optional(rt))	post (RESULT = (required(rt) union optional(rt)))get' (set of (Record) * Id +> Record)	get(dB, i) ==let record in set dB in (if ((record.id) = i)then recordelse get((dB \ {record}), i))	pre (i in set usedIds(dB))	post (((RESULT.id) = i) and (RESULT in set dB))CardDb' (set of (Record) * Id +> nat)	CardDb(dB, -) ==(card dB)getvalue' (Valuetype * set of (Record) * Id +> Value)	getvalue(valuetype, dB, i) ==(cases valuetype 'case <title> -> (get(dB, i).title),case <author> -> (get(dB, i).author),case <journal> -> (get(dB, i).journal),case <year> -> (get(dB, i).year),case <booktitle> -> (get(dB, i).booktitle),case <institution> -> (get(dB, i).institution),case <publisher> -> (get(dB, i).publisher)end)	pre ((i in set usedIds(dB)) and (valuetype in set {<title>, <author>, <journal>, <year>, <booktitle>, <institution>, <publisher>}))	post (((valuetype = <title>) and (RESULT = (get(dB, i).title))) or (((valuetype = <author>) and (RESULT = (get(dB, i).author))) or (((valuetype = <journal>) and (RESULT = (get(dB, i).journal))) or (((valuetype = <year>) and (RESULT = (get(dB, i).year))) or (((valuetype = <booktitle>) and (RESULT = (get(dB, i).booktitle))) or (((valuetype = <institution>) and (RESULT = (get(dB, i).institution))) or ((valuetype = <publisher>) and (RESULT = (get(dB, i).publisher)))))))))iscomplete' (set of (Record) * Id +> bool)	iscomplete(dB, i) ==(required(recordtype(dB, i)) = {f | [f in set required(recordtype(dB, i))] & (not isempty(getvalue(f, dB, i)))})	pre (i in set usedIds(dB))	post ((forall x in set required(recordtype(dB, i)) & (not isempty(getvalue(x, dB, i)))) <=> RESULT)isedition' (Value +> bool)	isedition(v) ==((v in set {1, ... ,50}) or (v = <nil>))isempty' (Value +> bool)	isempty(value) ==(if (value = <nil>)then trueelse false)	post ((value = <nil>) <=> RESULT)isidentical' (set of (Record) +> bool)	isidentical(dB) ==(if (dB = {})then falseelse let record1 in set dB in (if iscomplete(dB, (record1.id))then isidentical2(dB, (dB \ {record1}), dB, record1)else isidentical((dB \ {record1}))))	post ((exists [i, j in set usedIds(dB)] & ((i <> j) and (iscomplete(dB, i) and (iscomplete(dB, j) and ((recordtype(dB, i) = recordtype(dB, j)) and (forall x in set required(recordtype(dB, i)) & (getvalue(x, dB, i) = getvalue(x, dB, j)))))))) <=> RESULT)isidentical2' (set of (Record) * set of (Record) * set of (Record) * Record +> bool)	isidentical2(dB1, dB2, olddB, record1) ==(if (dB2 = {})then isidentical((dB1 \ {record1}))else let record2 in set dB2 in (if iscomplete(olddB, (record2.id))then isidentical3(dB1, dB2, olddB, record1, record2, required(recordtype(olddB, (record1.id))))else isidentical2(dB1, (dB2 \ {record2}), olddB, record1)))isidentical3' (set of (Record) * set of (Record) * set of (Record) * Record * Record * set of (Valuetype) +> bool)	isidentical3(dB1, dB2, olddB, record1, record2, requiredfields) ==(if (requiredfields = {})then trueelse let field in set requiredfields in (if (getvalue(field, olddB, (record1.id)) <> getvalue(field, olddB, (record2.id)))then isidentical2(dB1, (dB2 \ {record2}), olddB, record1)else isidentical3(dB1, dB2, olddB, record1, record2, (requiredfields \ {field}))))ismonth' (Value +> bool)	ismonth(v) ==is_(v, nat)isnumber' (Value +> bool)	isnumber(v) ==(is_(v, nat) or (v = <nil>))ispages' (Value +> bool)	ispages(v) ==(is_(v, nat) or (v = <nil>))isstring' (Value +> bool)	isstring(v) ==(if (not is_(v, real))then (if (v = [])then trueelseif is_((hd v), char)then isstring((tl v))else false)else false)issubstring' (String * String +> bool)	issubstring(string1, string2) ==(if (string1 = [])then trueelseif ((string2 = []) or ((string1 = <nil>) or (string2 = <nil>)))then falseelseif ((hd string1) = (hd string2))then issubstring2((tl string1), (tl string2), string1)else issubstring(string1, (tl string2)))	post (((not (string2 = <nil>)) and (exists [i, j in set (inds string2)] & (substring(string2, i, j) = string1))) <=> RESULT)issubstring2' (String * String * String +> bool)	issubstring2(string1, string2, oldstring1) ==(if (string1 = [])then trueelseif (string2 = [])then falseelseif ((hd string1) = (hd string2))then issubstring2((tl string1), (tl string2), oldstring1)else issubstring(oldstring1, string2))isvalueoffield' (Value * Valuetype +> bool)	isvalueoffield(v, f) ==(cases f 'case <address> -> isstring(v),case <author> -> isstring(v),case <booktitle> -> isstring(v),case <edition> -> isedition(v),case <editor> -> isstring(v),case <institution> -> isstring(v),case <journal> -> isstring(v),case <month> -> ismonth(v),case <note> -> isstring(v),case <number> -> isnumber(v),case <organization> -> isstring(v),case <pages> -> ispages(v),case <publisher> -> isstring(v),case <title> -> isstring(v),case <type> -> isstring(v),case <volume> -> isvolume(v),case <year> -> isyear(v)end)	post ((((f = <address>) and (exists [x'String] & (x = v))) or (((f = <author>) and (exists [x'String] & (x = v))) or (((f = <booktitle>) and (exists [x'String] & (x = v))) or (((f = <edition>) and (exists [x'Edition] & (x = v))) or (((f = <editor>) and (exists [x'String] & (x = v))) or (((f = <institution>) and (exists [x'String] & (x = v))) or (((f = <journal>) and (exists [x'String] & (x = v))) or (((f = <month>) and (exists [x'Month] & (x = v))) or (((f = <note>) and (exists [x'String] & (x = v))) or (((f = <number>) and (exists [x'Number] & (x = v))) or (((f = <organization>) and (exists [x'String] & (x = v))) or (((f = <pages>) and (exists [x'Pages] & (x = v))) or (((f = <publisher>) and (exists [x'String] & (x = v))) or (((f = <title>) and (exists [x'String] & (x = v))) or (((f = <type>) and (exists [x'String] & (x = v))) or (((f = <volume>) and (exists [x'Volume] & (x = v))) or ((f = <year>) and (exists [x'Year] & (x = v))))))))))))))))))) <=> RESULT)isvolume' (Value +> bool)	isvolume(v) ==(is_(v, nat) or (v = <nil>))isyear' (Value +> bool)	isyear(v) ==((v in set {1800, ... ,1998}) or (v = <nil>))optional' (Recordtype +> set of (Valuetype))	optional(rt) ==(cases rt 'case <article> -> {<volume>, <number>, <month>, <note>},case <book> -> {<volume>, <series>, <address>, <edition>, <month>, <note>, <publisher>},case <inproceeding> -> {<editor>, <pages>, <organization>, <publisher>, <address>, <pages>, <organization>},case <manual> -> {<edition>, <note>, <organization>, <month>, <address>, <author>, <organization>, <year>},case <techreport> -> {<number>, <note>, <type>, <month>, <address>}end)	post (((rt = <article>) and (RESULT = {<volume>, <number>, <month>, <note>})) or (((rt = <book>) and (RESULT = {<volume>, <series>, <address>, <edition>, <month>, <note>, <publisher>})) or (((rt = <inproceeding>) and (RESULT = {<editor>, <pages>, <organization>, <publisher>, <address>, <pages>, <organization>})) or (((rt = <manual>) and (RESULT = {<edition>, <note>, <organization>, <month>, <address>, <author>, <organization>, <year>})) or ((rt = <techreport>) and (RESULT = {<number>, <note>, <type>, <month>, <address>}))))))recordtype' (set of (Record) * Id +> Recordtype)	recordtype(dB, i) ==(if is_(get(dB, i), Article)then <article>elseif is_(get(dB, i), Book)then <book>elseif is_(get(dB, i), Inproceeding)then <inproceeding>elseif is_(get(dB, i), Manual)then <manual>else <techreport>)	pre (i in set usedIds(dB))	post ((is_(get(dB, i), Article) and (RESULT = <article>)) or ((is_(get(dB, i), Book) and (RESULT = <book>)) or ((is_(get(dB, i), Inproceeding) and (RESULT = <inproceeding>)) or ((is_(get(dB, i), Manual) and (RESULT = <manual>)) or (is_(get(dB, i), Techreport) and (RESULT = <techreport>))))))required' (Recordtype +> set of (Valuetype))	required(rt) ==(cases rt 'case <article> -> {<title>, <author>, <journal>, <year>},case <book> -> {<title>, <author>, <publisher>, <year>},case <inproceeding> -> {<title>, <author>, <booktitle>, <year>},case <manual> -> {<title>},case <techreport> -> {<title>, <author>, <institution>, <year>}end)	post (((rt = <article>) and (RESULT = {<title>, <author>, <journal>, <year>})) or (((rt = <book>) and (RESULT = {<title>, <author>, <publisher>, <year>})) or (((rt = <inproceeding>) and (RESULT = {<title>, <author>, <booktitle>, <year>})) or (((rt = <manual>) and (RESULT = {<title>})) or ((rt = <techreport>) and (RESULT = {<title>, <author>, <institution>, <year>}))))))private substring((s'String), (i'nat1), (j'nat1))r'String	pre ((i < j) and (j <= (len s)))	post (exists [s1, s2'String] & (((len s1) = (i - 1)) and (((len s2) = ((len s) - j)) and (s = ((s1 ^ r) ^ s2)))))usedIds' (set of (Record) +> set of (Id))	usedIds(dB) ==idset(dB, {})	post (forall x in set dB & (((x.id) in set RESULT) and (forall i in set RESULT & (exists [x in set dB] & ((x.id) = i)))))idset' (set of (Record) * set of (Id) +> set of (Id))	idset(dB, ids) ==(if (dB = {})then idselse let record in set dB in idset((dB \ {record}), (ids union {(record.id)})))CardRecords' (set of (Record) * set of (Id) +> nat)	CardRecords(s, -) ==(card s)CREATE (Recordtype ==> Id)	CREATE(e) ==(i'nat1 '= 1(while (i in set usedIds(dB)) do i '= (i + 1));cases e '  case <article> -> dB '= (dB union {mk_Article(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <book> -> dB '= (dB union {mk_Book(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <inproceeding> -> dB '= (dB union {mk_Inproceeding(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <manual> -> dB '= (dB union {mk_Manual(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})  case <techreport> -> dB '= (dB union {mk_Techreport(i, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})esac;return (i))	post (((RESULT not in set usedIds(dB~)) and ((e = <article>) and (dB = (dB~ union {mk_Article(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})))) or (((e = <book>) and (dB = (dB~ union {mk_Book(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)}))) or (((e = <inproceeding>) and (dB = (dB~ union {mk_Inproceeding(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)}))) or (((e = <manual>) and (dB = (dB~ union {mk_Manual(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)}))) or ((e = <techreport>) and (dB = (dB~ union {mk_Techreport(RESULT, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>, <nil>)})))))))UPDATE((i'Id), (f'Valuetype), (v'Value))	ext [wr dB'set of (Record)]	pre ((i in set usedIds(dB)) and ((f in set field(recordtype(dB, i))) and (isvalueoffield(v, f) and (not (iscomplete(dB, i) and isidentical(dB))))))	post ((getvalue(f, dB, i) = v) and (((dB \ {get(dB, i)}) = (dB~ \ {get(dB~, i)})) and (forall x in set (field(recordtype(dB, i)) \ {f}) & (getvalue(x, dB, i) = getvalue(x, dB~, i)))))COMPLETE (Id ==> bool)	COMPLETE(i) ==return (iscomplete(dB, i))	pre (i in set usedIds(dB))	post (iscomplete(dB, i) <=> RESULT)DELETE((i'Id))	ext [wr dB'set of (Record)]	pre (i in set usedIds(dB))	post (dB~ = (dB union {get(dB~, i)}))SEARCH (String ==> set of (Id))	SEARCH(a) ==(ids'set of (Id) '= {}for all record in set dB doif issubstring(a, (record.author))thenids '= (ids union {(record.id)})elseids '= ids;return (ids))	post (forall i in set RESULT & (issubstring(a, (get(dB, i).author)) and (not (exists [record in set dB] & (((record.id) not in set RESULT) and issubstring(a, (get(dB, i).author)))))))GET (Id ==> Record)	GET(i) ==return (get(dB, i))	pre (i in set usedIds(dB))	post (RESULT = get(dB, i))end DEFAULT
