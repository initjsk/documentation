WARNING:adt.vdmsl:5012:481,16:Recursive function has no measure.
WARNING:adt.vdmsl:5012:1478,15:Recursive function has no measure.
WARNING:adt.vdmsl:5012:234,19:Recursive function has no measure.
WARNING:adt.vdmsl:5012:1199,23:Recursive function has no measure.
WARNING:adt.vdmsl:5008:1159,60:position at 1157'41 hidden by position.
WARNING:adt.vdmsl:5012:1510,19:Recursive function has no measure.
WARNING:adt.vdmsl:5008:1159,50:data at 1157'35 hidden by data.
WARNING:adt.vdmsl:5012:692,15:Recursive function has no measure.
WARNING:adt.vdmsl:5012:468,14:Recursive function has no measure.
WARNING:adt.vdmsl:5012:455,10:Recursive function has no measure.
WARNING:adt.vdmsl:5000:1779,20:Definition 'charStack' not used.
WARNING:adt.vdmsl:5000:1778,20:Definition 'charQueue' not used.
WARNING:adt.vdmsl:5012:711,15:Recursive function has no measure.
ERROR:adt.vdmsl:3313:1681,22:Operation returns void value. Actual' (() | bool) Expected' bool
ERROR:adt.vdmsl:3313:1710,16:Operation returns void value. Actual' (() | Trees_Tree) Expected' Trees_Tree
ERROR:adt.vdmsl:3313:1563,13:Operation returns void value. Actual' (() | Trees_Tree) Expected' Trees_Tree
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private ADDRESS = natstatic private NIL'ADDRESS = 0static private Nodes_Data = Datastatic private Nodes_SingleLink = compose Nodes_SingleLink of data'Nodes_Data, next'Nodes_NodePtr endstatic private Nodes_DoubleLink = compose Nodes_DoubleLink of data'Nodes_Data, next'Nodes_NodePtr, prev'Nodes_NodePtr endstatic private Nodes_BinaryTree = compose Nodes_BinaryTree of data'Nodes_Data, right'Nodes_NodePtr, left'Nodes_NodePtr, parent'Nodes_NodePtr endstatic private Nodes_Node = (Nodes_BinaryTree | Nodes_DoubleLink | Nodes_SingleLink)static private Nodes_NodePtr = ADDRESSNodes_MkSingleLink' (Nodes_Data * Nodes_NodePtr -> Nodes_Node)	Nodes_MkSingleLink(data, ptr) ==mk_Nodes_SingleLink(data, ptr)Nodes_MkDoubleLink' (Nodes_Data * Nodes_NodePtr * Nodes_NodePtr -> Nodes_Node)	Nodes_MkDoubleLink(data, next, prev) ==mk_Nodes_DoubleLink(data, next, prev)Nodes_MkBinaryTree' (Nodes_Data * Nodes_NodePtr * Nodes_NodePtr * Nodes_NodePtr -> Nodes_Node)	Nodes_MkBinaryTree(data, right, left, parent) ==mk_Nodes_BinaryTree(data, right, left, parent)Nodes_GetData' (Nodes_Node -> Nodes_Data)	Nodes_GetData(node) ==(if is_(node, Nodes_SingleLink)then let mk_Nodes_SingleLink(data, -)'Nodes_Node = node in dataelseif is_(node, Nodes_DoubleLink)then let mk_Nodes_DoubleLink(data, -, -)'Nodes_Node = node in dataelse let mk_Nodes_BinaryTree(data, -, -, -)'Nodes_Node = node in data)	pre (is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree)))Nodes_SetData' (Nodes_Node * Nodes_Data -> Nodes_Node)	Nodes_SetData(node, data) ==(if is_(node, Nodes_SingleLink)then let mk_Nodes_SingleLink(-, next)'Nodes_Node = node in mk_Nodes_SingleLink(data, next)elseif is_(node, Nodes_DoubleLink)then let mk_Nodes_DoubleLink(-, next, prev)'Nodes_Node = node in mk_Nodes_DoubleLink(data, next, prev)else let mk_Nodes_BinaryTree(-, right, left, parent)'Nodes_Node = node in mk_Nodes_BinaryTree(data, right, left, parent))	pre (is_(node, Nodes_SingleLink) or (is_(node, Nodes_DoubleLink) or is_(node, Nodes_BinaryTree)))Nodes_GetNext' (Nodes_Node -> Nodes_NodePtr)	Nodes_GetNext(node) ==(if is_(node, Nodes_SingleLink)then let mk_Nodes_SingleLink(-, next)'Nodes_Node = node in nextelse let mk_Nodes_DoubleLink(-, next, -)'Nodes_Node = node in next)	pre (is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink))Nodes_SetNext' (Nodes_Node * Nodes_NodePtr -> Nodes_Node)	Nodes_SetNext(node, next) ==(if is_(node, Nodes_SingleLink)then let mk_Nodes_SingleLink(data, -)'Nodes_Node = node in mk_Nodes_SingleLink(data, next)else let mk_Nodes_DoubleLink(data, -, prev)'Nodes_Node = node in mk_Nodes_DoubleLink(data, next, prev))	pre (is_(node, Nodes_SingleLink) or is_(node, Nodes_DoubleLink))Nodes_GetPrev' (Nodes_Node -> Nodes_NodePtr)	Nodes_GetPrev(node) ==let mk_Nodes_DoubleLink(-, -, prev)'Nodes_Node = node in prev	pre is_(node, Nodes_DoubleLink)Nodes_SetPrev' (Nodes_Node * Nodes_NodePtr -> Nodes_Node)	Nodes_SetPrev(node, prev) ==let mk_Nodes_DoubleLink(data, next, -)'Nodes_Node = node in mk_Nodes_DoubleLink(data, next, prev)	pre is_(node, Nodes_DoubleLink)Nodes_GetRight' (Nodes_Node -> Nodes_NodePtr)	Nodes_GetRight(node) ==let mk_Nodes_BinaryTree(-, right, -, -)'Nodes_Node = node in right	pre is_(node, Nodes_BinaryTree)Nodes_SetRight' (Nodes_Node * Nodes_NodePtr -> Nodes_Node)	Nodes_SetRight(node, right) ==let mk_Nodes_BinaryTree(data, -, left, parent)'Nodes_Node = node in mk_Nodes_BinaryTree(data, right, left, parent)	pre is_(node, Nodes_BinaryTree)Nodes_GetLeft' (Nodes_Node -> Nodes_NodePtr)	Nodes_GetLeft(node) ==let mk_Nodes_BinaryTree(-, -, left, -)'Nodes_Node = node in left	pre is_(node, Nodes_BinaryTree)Nodes_SetLeft' (Nodes_Node * Nodes_NodePtr -> Nodes_Node)	Nodes_SetLeft(node, left) ==let mk_Nodes_BinaryTree(data, right, -, parent)'Nodes_Node = node in mk_Nodes_BinaryTree(data, right, left, parent)	pre is_(node, Nodes_BinaryTree)Nodes_GetParent' (Nodes_Node -> Nodes_NodePtr)	Nodes_GetParent(node) ==let mk_Nodes_BinaryTree(-, -, -, parent)'Nodes_Node = node in parent	pre is_(node, Nodes_BinaryTree)Nodes_SetParent' (Nodes_Node * Nodes_NodePtr -> Nodes_Node)	Nodes_SetParent(node, parent) ==let mk_Nodes_BinaryTree(data, right, left, -)'Nodes_Node = node in mk_Nodes_BinaryTree(data, right, left, parent)	pre is_(node, Nodes_BinaryTree)static private Heaps_Data = [Nodes_Node]static private Heaps_Size'nat1 = 20static private Heaps_Location = compose Heaps_Location of data'[Heaps_Data], allocated'bool end	inv mk_Heaps_Location(d, a) == ((a = true) <=> (d <> nil))static private Heaps_Heap = compose Heaps_Heap of storage'seq of (Heaps_Location) end	inv mk_Heaps_Heap(s) == ((len s) = Heaps_Size)Heaps_InitSequence' (nat1 -> seq of (Heaps_Location))	Heaps_InitSequence(length) ==(if (length > 1)then ([mk_Heaps_Location(nil, false)] ^ Heaps_InitSequence((length - 1)))else [mk_Heaps_Location(nil, false)])Heaps_Init' (() -> Heaps_Heap)	Heaps_Init() ==mk_Heaps_Heap(Heaps_InitSequence(Heaps_Size))Heaps_AmountUsed' (Heaps_Heap -> nat)	Heaps_AmountUsed(heap) ==let store'seq of (Heaps_Location) = (heap.storage) in (len [store(i) | i in set (inds store) & ((store(i).allocated) = true)])Heaps_Available' (Heaps_Heap -> bool)	Heaps_Available(heap) ==(Heaps_AmountUsed(heap) < (len (heap.storage)))Heaps_ModifyLoc' (Heaps_Heap * ADDRESS * Heaps_Location -> Heaps_Heap)	Heaps_ModifyLoc(heap, address, location) ==mk_Heaps_Heap(((heap.storage) ++ {address |-> location}))	pre (address in set (inds (heap.storage)))Heaps_Modify' (Heaps_Heap * ADDRESS * Heaps_Data -> Heaps_Heap)	Heaps_Modify(heap, address, data) ==Heaps_ModifyLoc(heap, address, mk_Heaps_Location(data, true))	pre let store'seq of (Heaps_Location) = (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) = true))Heaps_Retrieve' (Heaps_Heap * ADDRESS -> [Heaps_Data])	Heaps_Retrieve(heap, address) ==((heap.storage)(address).data)	pre let store'seq of (Heaps_Location) = (heap.storage) in ((address in set (inds store)) and ((store(address).allocated) = true))Heaps_UnallocatedAddresses' (Heaps_Heap -> set of (ADDRESS))	Heaps_UnallocatedAddresses(heap) ==let store'seq of (Heaps_Location) = (heap.storage) in {i | [i in set (inds store)] & ((store(i).allocated) = false)}Heaps_UnallocatedAddress' (Heaps_Heap -> ADDRESS)	Heaps_UnallocatedAddress(heap) ==(iota new in set Heaps_UnallocatedAddresses(heap) & (forall i in set Heaps_UnallocatedAddresses(heap) & (new <= i)))	pre Heaps_Available(heap)NEW (Heaps_Data ==> ADDRESS)	NEW(data) ==(def newAddress = Heaps_UnallocatedAddress(heap) in def newLoc = mk_Heaps_Location(data, true) in (heap '= Heaps_ModifyLoc(heap, newAddress, newLoc);return (newAddress)))	pre Heaps_Available(heap)DISPOSE (ADDRESS ==> ())	DISPOSE(address) ==heap '= Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))	pre pre_Heaps_ModifyLoc(heap, address, mk_Heaps_Location(nil, false))SET_DATA (ADDRESS * Data ==> ())	SET_DATA(ptr, data) ==heap '= Heaps_Modify(heap, ptr, Nodes_SetData(Heaps_Retrieve(heap, ptr), data))SET_NEXT (ADDRESS * ADDRESS ==> ())	SET_NEXT(ptr, next) ==heap '= Heaps_Modify(heap, ptr, Nodes_SetNext(Heaps_Retrieve(heap, ptr), next))SET_LEFT (ADDRESS * ADDRESS ==> ())	SET_LEFT(ptr, left) ==heap '= Heaps_Modify(heap, ptr, Nodes_SetLeft(Heaps_Retrieve(heap, ptr), left))SET_RIGHT (ADDRESS * ADDRESS ==> ())	SET_RIGHT(ptr, right) ==heap '= Heaps_Modify(heap, ptr, Nodes_SetRight(Heaps_Retrieve(heap, ptr), right))SET_PREV (ADDRESS * ADDRESS ==> ())	SET_PREV(ptr, prev) ==heap '= Heaps_Modify(heap, ptr, Nodes_SetPrev(Heaps_Retrieve(heap, ptr), prev))SET_PARENT (ADDRESS * ADDRESS ==> ())	SET_PARENT(ptr, parent) ==heap '= Heaps_Modify(heap, ptr, Nodes_SetParent(Heaps_Retrieve(heap, ptr), parent))DATA (ADDRESS ==> Data)	DATA(ptr) ==return (Nodes_GetData(Heaps_Retrieve(heap, ptr)))NEXT (ADDRESS ==> ADDRESS)	NEXT(ptr) ==return (Nodes_GetNext(Heaps_Retrieve(heap, ptr)))LEFT (ADDRESS ==> ADDRESS)	LEFT(ptr) ==return (Nodes_GetLeft(Heaps_Retrieve(heap, ptr)))RIGHT (ADDRESS ==> ADDRESS)	RIGHT(ptr) ==return (Nodes_GetRight(Heaps_Retrieve(heap, ptr)))PARENT (ADDRESS ==> ADDRESS)	PARENT(ptr) ==return (Nodes_GetParent(Heaps_Retrieve(heap, ptr)))static private SList_Data = Datastatic private SList_List = Nodes_NodePtrSList_IsEmpty' (SList_List -> bool)	SList_IsEmpty(list) ==(list = NIL)SList_Seq' (Heaps_Heap * SList_List -> seq of (SList_Data))	SList_Seq(heap, list) ==(if (not SList_IsEmpty(list))then let node'[Heaps_Data] = Heaps_Retrieve(heap, list) in let data'Nodes_Data = Nodes_GetData(node) in let tail'Nodes_NodePtr = Nodes_GetNext(node) in ([data] ^ SList_Seq(heap, tail))else [])SList_Lengthf' (Heaps_Heap * SList_List -> nat)	SList_Lengthf(heap, list) ==(if (not SList_IsEmpty(list))then let tail'Nodes_NodePtr = Nodes_GetNext(Heaps_Retrieve(heap, list)) in (1 + SList_Lengthf(heap, tail))else 0)	post (RESULT = (len SList_Seq(heap, list)))SList_PtrToNode' (Heaps_Heap * SList_List * nat1 -> Nodes_NodePtr)	SList_PtrToNode(heap, list, position) ==let tail'Nodes_NodePtr = Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (position > 1)then SList_PtrToNode(heap, tail, (position - 1))else list)	pre (position <= SList_Lengthf(heap, list))	post let data'Nodes_Data = Nodes_GetData(Heaps_Retrieve(heap, RESULT)), listSeq'seq of (SList_Data) = SList_Seq(heap, list) in (data = listSeq(position))SList_Init' (() -> SList_List)	SList_Init() ==NILSList_InsertAtBeginning (SList_List * SList_Data ==> SList_List)	SList_InsertAtBeginning(list, data) ==return (NEW(Nodes_MkSingleLink(data, list)))	post (([data] ^ SList_Seq(heap~, list)) = SList_Seq(heap, RESULT))SList_InsertAfter (SList_List * Nodes_NodePtr * SList_Data ==> SList_List)	SList_InsertAfter(list, ptr, data) ==(new'Nodes_NodePtr '= NEW(Nodes_MkSingleLink(data, NEXT(ptr)))SET_NEXT(ptr, new);return (list))	post let old'seq of (SList_Data) = SList_Seq(heap~, ptr) in ((([old(1)] ^ [data]) ^ (tl old)) = SList_Seq(heap, ptr))SList_Insert (SList_List * SList_Data * nat1 ==> SList_List)	SList_Insert(list, data, position) ==if (position = 1)thenreturn (SList_InsertAtBeginning(list, data))elsereturn (SList_InsertAfter(list, SList_PtrToNode(heap, list, (position - 1)), data))	pre ((position <= (SList_Lengthf(heap, list) + 1)) and Heaps_Available(heap))	post let new'seq of (SList_Data) = SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) = [new(i) | i in set (inds new) & (i <> position)]) and ((new(position) = data) and ((Heaps_AmountUsed(heap~) + 1) = Heaps_AmountUsed(heap))))SList_Append (SList_List * SList_Data ==> SList_List)	SList_Append(list, data) ==(ptr'Nodes_NodePtr '= listif (ptr = NIL)thenreturn (SList_InsertAtBeginning(list, data))else(while (NEXT(ptr) <> NIL) do ptr '= NEXT(ptr);return (SList_InsertAfter(list, ptr, data))))	pre Heaps_Available(heap)	post (((SList_Seq(heap~, list) ^ [data]) = SList_Seq(heap, RESULT)) and ((Heaps_AmountUsed(heap~) + 1) = Heaps_AmountUsed(heap)))SList_Update (SList_List * SList_Data * nat1 ==> SList_List)	SList_Update(list, data, position) ==(ptr'Nodes_NodePtr '= SList_PtrToNode(heap, list, position)SET_DATA(ptr, data);return (list))	pre (position <= SList_Lengthf(heap, list))	post (((SList_Seq(heap~, list) ++ {position |-> data}) = SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) = Heaps_AmountUsed(heap)))SList_DeleteAtBeginning (SList_List ==> SList_List)	SList_DeleteAtBeginning(list) ==(temp'Nodes_NodePtr '= listnewlist'SList_List '= NEXT(list)DISPOSE(temp);return (newlist))	post ((tl SList_Seq(heap~, list)) = SList_Seq(heap, RESULT))SList_DeleteAfter (SList_List * Nodes_NodePtr ==> SList_List)	SList_DeleteAfter(list, ptr) ==(temp'Nodes_NodePtr '= (undefined)temp '= NEXT(ptr);SET_NEXT(ptr, NEXT(temp));DISPOSE(temp);return (list))	post let old'seq of (SList_Data) = SList_Seq(heap~, ptr) in (([old(1)] ^ (tl (tl old))) = SList_Seq(heap, ptr))SList_Delete (SList_List * nat1 ==> SList_List)	SList_Delete(list, position) ==(if (position = 1)thenreturn (SList_DeleteAtBeginning(list))elsereturn (SList_DeleteAfter(list, SList_PtrToNode(heap, list, (position - 1)))))	pre (position <= SList_Lengthf(heap, list))	post let old'seq of (SList_Data) = SList_Seq(heap~, list) in (([old(i) | i in set (inds old) & (i <> position)] = SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) = (Heaps_AmountUsed(heap) + 1)))SList_Traverse (SList_List * (SList_Data -> SList_Data) ==> SList_List)	SList_Traverse(list, traversal) ==(ptr'Nodes_NodePtr '= listwhile (ptr <> NIL) do (SET_DATA(ptr, traversal(DATA(ptr)));ptr '= NEXT(ptr));return (list))	post let old'seq of (SList_Data) = SList_Seq(heap~, list) in ((old <> []) => ([traversal(old(i)) | i in set (inds old)] = SList_Seq(heap, RESULT)))SList_Length (SList_List ==> nat)	SList_Length(list) ==return (SList_Lengthf(heap, list))SList_Empty (SList_List ==> bool)	SList_Empty(list) ==return (SList_IsEmpty(list))SList_Element (SList_List * nat1 ==> SList_Data)	SList_Element(list, position) ==DATA(SList_PtrToNode(heap, list, position))static private DList_Data = Datastatic private DList_List = Nodes_NodePtrDList_LastNode' (Heaps_Heap * DList_List -> Nodes_NodePtr)	DList_LastNode(heap, list) ==let next'Nodes_NodePtr = Nodes_GetNext(Heaps_Retrieve(heap, list)) in (if (next <> NIL)then DList_LastNode(heap, next)else list)DList_Forward' (Heaps_Heap * DList_List -> seq of (DList_Data))	DList_Forward(heap, list) ==SList_Seq(heap, list)DList_Backward' (Heaps_Heap * DList_List -> seq of (DList_Data))	DList_Backward(heap, list) ==(if (list <> NIL)then let prev'Nodes_NodePtr = Nodes_GetPrev(Heaps_Retrieve(heap, list)) in let data'Nodes_Data = Nodes_GetData(Heaps_Retrieve(heap, list)) in (DList_Backward(heap, prev) ^ [data])else [])DList_IsList' (Heaps_Heap * DList_List -> bool)	DList_IsList(heap, list) ==(if (list <> NIL)then (DList_Forward(heap, list) = DList_Backward(heap, DList_LastNode(heap, list)))else true)DList_Init' (() -> DList_List)	DList_Init() ==NILDList_InsertAtBeginning (DList_List * DList_Data ==> DList_List)	DList_InsertAtBeginning(list, data) ==(new'Nodes_NodePtr '= NEW(Nodes_MkDoubleLink(data, list, NIL))if (list <> NIL)thenSET_PREV(list, new);return (new))	post (([data] ^ SList_Seq(heap~, list)) = SList_Seq(heap, RESULT))DList_InsertAfter (DList_List * Nodes_NodePtr * DList_Data ==> DList_List)	DList_InsertAfter(list, ptr, data) ==(new'Nodes_NodePtr '= NEW(Nodes_MkDoubleLink(data, NEXT(ptr), ptr))if (NEXT(ptr) <> NIL)thenSET_PREV(NEXT(ptr), new);SET_NEXT(ptr, new);return (list))	post let old'seq of (SList_Data) = SList_Seq(heap~, ptr) in ((([old(1)] ^ [data]) ^ (tl old)) = SList_Seq(heap, ptr))DList_Insert (DList_List * DList_Data * nat1 ==> DList_List)	DList_Insert(list, data, position) ==if (position = 1)thenreturn (DList_InsertAtBeginning(list, data))elsereturn (DList_InsertAfter(list, SList_PtrToNode(heap, list, (position - 1)), data))	pre ((position <= (SList_Lengthf(heap, list) + 1)) and (Heaps_Available(heap) and DList_IsList(heap, list)))	post (DList_IsList(heap, RESULT) and let new'seq of (SList_Data) = SList_Seq(heap, RESULT) in ((SList_Seq(heap~, list) = [new(i) | i in set (inds new) & (i <> position)]) and (new(position) = data)))DList_DeleteAtBeginning (DList_List ==> DList_List)	DList_DeleteAtBeginning(list) ==(temp'Nodes_NodePtr '= listnewlist'DList_List '= NEXT(list)if (newlist <> NIL)thenSET_PREV(newlist, NIL);DISPOSE(temp);return (newlist))	post ((tl SList_Seq(heap~, list)) = SList_Seq(heap, RESULT))DList_DeleteAfter (DList_List * Nodes_NodePtr ==> DList_List)	DList_DeleteAfter(list, ptr) ==(temp'Nodes_NodePtr '= (undefined)nextPtr'Nodes_NodePtr '= (undefined)temp '= NEXT(ptr);nextPtr '= NEXT(temp);SET_NEXT(ptr, nextPtr);if (nextPtr <> NIL)thenSET_PREV(nextPtr, ptr);DISPOSE(temp);return (list))	post let old'seq of (SList_Data) = SList_Seq(heap~, ptr) in (([old(1)] ^ (tl (tl old))) = SList_Seq(heap, ptr))DList_Delete (DList_List * nat1 ==> DList_List)	DList_Delete(list, position) ==(if (position = 1)thenreturn (DList_DeleteAtBeginning(list))elsereturn (DList_DeleteAfter(list, SList_PtrToNode(heap, list, (position - 1)))))	pre ((position <= SList_Lengthf(heap, list)) and DList_IsList(heap, list))	post (DList_IsList(heap, RESULT) and let old'seq of (SList_Data) = SList_Seq(heap~, list) in (([old(i) | i in set (inds old) & (i <> position)] = SList_Seq(heap, RESULT)) and (Heaps_AmountUsed(heap~) = (Heaps_AmountUsed(heap) + 1))))DList_Append (DList_List * DList_Data ==> DList_List)	DList_Append(list, data) ==(ptr'Nodes_NodePtr '= listif (ptr = NIL)thenreturn (DList_InsertAtBeginning(list, data))else(while (NEXT(ptr) <> NIL) do ptr '= NEXT(ptr);return (DList_InsertAfter(list, ptr, data))))	pre (Heaps_Available(heap) and DList_IsList(heap, list))	post (((SList_Seq(heap~, list) ^ [data]) = SList_Seq(heap, RESULT)) and (((Heaps_AmountUsed(heap~) + 1) = Heaps_AmountUsed(heap)) and DList_IsList(heap, RESULT)))DList_Empty (DList_List ==> bool)	DList_Empty(list) ==SList_Empty(list)DList_Element (DList_List * nat1 ==> DList_Data)	DList_Element(list, position) ==SList_Element(list, position)DList_Length (DList_List ==> nat)	DList_Length(list) ==SList_Length(list)DList_Traverse (DList_List * (DList_Data -> DList_Data) ==> DList_List)	DList_Traverse(list, traversal) ==SList_Traverse(list, traversal)DList_Update (DList_List * DList_Data * nat1 ==> DList_List)	DList_Update(list, data, position) ==SList_Update(list, data, position)static private Queues_Data = Datastatic private Queues_Queue = SList_ListQueues_Init' (() -> Queues_Queue)	Queues_Init() ==SList_Init()Queues_Enqueue (Queues_Queue * Queues_Data ==> Queues_Queue)	Queues_Enqueue(queue, data) ==return (SList_Append(queue, data))Queues_Dequeue (Queues_Queue ==> (Queues_Queue * Queues_Data))	Queues_Dequeue(queue) ==(if (not SList_Empty(queue))then(data'Queues_Data '= Queues_Head(queue)return (mk_(SList_Delete(queue, 1), data)))elseerror)Queues_Head (Queues_Queue ==> Queues_Data)	Queues_Head(queue) ==if (not SList_Empty(queue))thenSList_Element(queue, 1)elseerrorstatic private Stacks_Data = Datastatic private Stacks_Stack = SList_ListStacks_Init' (() -> Stacks_Stack)	Stacks_Init() ==SList_Init()Stacks_Push (Stacks_Stack * Stacks_Data ==> Stacks_Stack)	Stacks_Push(stack, data) ==return (SList_Insert(stack, data, 1))Stacks_Top (Stacks_Stack ==> Stacks_Data)	Stacks_Top(stack) ==if (not SList_Empty(stack))thenSList_Element(stack, 1)elseerrorStacks_Pop (Stacks_Stack ==> (Stacks_Stack * Stacks_Data))	Stacks_Pop(stack) ==(if (not SList_Empty(stack))then(data'Stacks_Data '= Stacks_Top(stack)return (mk_(SList_Delete(stack, 1), data)))elseerror)static private STrees_Data = Datastatic private STrees_Direction = (<ToLeft> | <ToRight> | <ToRoot>)static private STrees_Node = compose STrees_Node of data'STrees_Data, position'nat1 endstatic private STrees_Tree = set of (STrees_Node)	inv tree == ((forall node in set tree & ((not STrees_IsRoot(tree, node)) <=> (STrees_IsChild(tree, node) and STrees_IsUnique(tree, node)))) and ((tree <> {}) <=> (exists1 node in set tree & STrees_IsRoot(tree, node))))static private STrees_Info = compose STrees_Info of tree'STrees_Tree, current'[STrees_Node] end	inv mk_STrees_Info(t, c) == (((c = nil) <=> (t = {})) and ((c <> nil) <=> ((c in set t) and let r'STrees_Node = STrees_Root(t) in ((r.position) = 1))))STrees_GetTree' (STrees_Info -> STrees_Tree)	STrees_GetTree(mk_STrees_Info(tree, -)) ==treeSTrees_MkNode' (STrees_Data * nat1 -> STrees_Node)	STrees_MkNode(data, position) ==mk_STrees_Node(data, position)STrees_MkTree' (set of (STrees_Node) -> STrees_Tree)	STrees_MkTree(tree) ==tree	pre inv_STrees_Tree(tree)STrees_MkInfo' (STrees_Tree * STrees_Node -> STrees_Info)	STrees_MkInfo(tree, current) ==mk_STrees_Info(tree, current)	pre inv_STrees_Info(mk_STrees_Info(tree, current))STrees_Init' (() -> STrees_Info)	STrees_Init() ==mk_STrees_Info({}, nil)STrees_IsRoot' (set of (STrees_Node) * STrees_Node -> bool)	STrees_IsRoot(tree, mk_STrees_Node(dr, pr)) ==(not STrees_IsChild(tree, mk_STrees_Node(dr, pr)))	pre (mk_STrees_Node(dr, pr) in set tree)STrees_IsParent' (STrees_Tree * STrees_Node -> bool)	STrees_IsParent(tree, node) ==(exists [child in set tree] & STrees_IsParentOf(tree, node, child))	pre (node in set tree)STrees_IsChild' (set of (STrees_Node) * STrees_Node -> bool)	STrees_IsChild(tree, node) ==((exists [parent in set tree] & STrees_IsParentOf(tree, parent, node)) and (exists1 parent in set tree & STrees_IsParentOf(tree, parent, node)))	pre (node in set tree)STrees_IsUnique' (set of (STrees_Node) * STrees_Node -> bool)	STrees_IsUnique(tree, mk_STrees_Node(data, position)) ==((mk_STrees_Node(data, position) in set tree) and (exists1 node in set tree & ((node.position) = position)))STrees_IsParentOf' (set of (STrees_Node) * STrees_Node * STrees_Node -> bool)	STrees_IsParentOf(tree, node1, node2) ==(STrees_IsRightChildOf(tree, node2, node1) or STrees_IsLeftChildOf(tree, node2, node1))	pre ((node1 in set tree) and (node2 in set tree))STrees_IsRightChildOf' (set of (STrees_Node) * STrees_Node * STrees_Node -> bool)	STrees_IsRightChildOf(tree, node1, node2) ==let mk_STrees_Node(-, position1)'STrees_Node = node1 in let mk_STrees_Node(-, position2)'STrees_Node = node2 in (position1 = ((2 * position2) + 1))	pre ((node1 in set tree) and (node2 in set tree))STrees_IsLeftChildOf' (set of (STrees_Node) * STrees_Node * STrees_Node -> bool)	STrees_IsLeftChildOf(tree, node1, node2) ==let mk_STrees_Node(-, position1)'STrees_Node = node1 in let mk_STrees_Node(-, position2)'STrees_Node = node2 in (position1 = (2 * position2))	pre ((node1 in set tree) and (node2 in set tree))STrees_Insert' (STrees_Info * STrees_Data * STrees_Direction -> STrees_Info)	STrees_Insert(mk_STrees_Info(tree, current), data, direction) ==(cases mk_(current, direction) 'case mk_(nil, <ToRoot>) -> STrees_InsertRoot(data),case mk_(-, <ToLeft>) -> STrees_InsertLeft(tree, current, data),case mk_(-, <ToRight>) -> STrees_InsertRight(tree, current, data)end)	pre (((direction = <ToRoot>) => (tree = {})) and (((direction = <ToLeft>) => (not STrees_HasLeftChild(tree, current))) and ((direction = <ToRight>) => (not STrees_HasRightChild(tree, current)))))	post inv_STrees_Info(RESULT)STrees_InsertRoot' (STrees_Data -> STrees_Info)	STrees_InsertRoot(data) ==let root'STrees_Node = mk_STrees_Node(data, 1) in mk_STrees_Info({root}, root)STrees_InsertLeft' (STrees_Tree * STrees_Node * STrees_Data -> STrees_Info)	STrees_InsertLeft(tree, current, data) ==let mk_STrees_Node(-, position)'STrees_Node = current in let new'STrees_Node = mk_STrees_Node(data, (2 * position)) in mk_STrees_Info((tree union {new}), new)	pre (not STrees_HasLeftChild(tree, current))STrees_InsertRight' (STrees_Tree * STrees_Node * STrees_Data -> STrees_Info)	STrees_InsertRight(tree, current, data) ==let mk_STrees_Node(-, position)'STrees_Node = current in let new'STrees_Node = mk_STrees_Node(data, ((2 * position) + 1)) in mk_STrees_Info((tree union {new}), new)	pre (not STrees_HasRightChild(tree, current))STrees_Traverse' (STrees_Info * (STrees_Data -> STrees_Data) -> STrees_Info)	STrees_Traverse(treeinfo, traversal) ==let mk_STrees_Info(tree, current)'STrees_Info = treeinfo in (if (current <> nil)then let mk_STrees_Node(data, position)'[STrees_Node] = current in let newtree'set of (STrees_Node) = {mk_STrees_Node(traversal(data), position) | [mk_STrees_Node(data, position) in set tree]} in mk_STrees_Info(newtree, mk_STrees_Node(traversal(data), position))else treeinfo)STrees_MoveInDir' (STrees_Info * STrees_Direction -> STrees_Info)	STrees_MoveInDir(mk_STrees_Info(tree, current), direction) ==(cases direction 'case <ToRoot> -> mk_STrees_Info(tree, STrees_Root(tree)),case <ToLeft> -> mk_STrees_Info(tree, STrees_LeftChild(tree, current)),case <ToRight> -> mk_STrees_Info(tree, STrees_RightChild(tree, current))end)	pre STrees_ExistsDirection(mk_STrees_Info(tree, current), direction)STrees_MoveToNode' (STrees_Info * nat1 -> STrees_Info)	STrees_MoveToNode(mk_STrees_Info(tree, current), position) ==mk_STrees_Info(tree, STrees_GetNode(tree, position))	pre STrees_ExistsNode(mk_STrees_Info(tree, current), position)STrees_MoveToParent' (STrees_Info -> STrees_Info)	STrees_MoveToParent(mk_STrees_Info(tree, current)) ==mk_STrees_Info(tree, STrees_Parent(tree, current))	pre (not STrees_IsRoot(tree, current))STrees_MoveToAnscestor' (STrees_Info * nat1 -> STrees_Info)	STrees_MoveToAnscestor(treeinfo, pathlength) ==(if (pathlength > 1)then STrees_MoveToAnscestor(STrees_MoveToParent(treeinfo), (pathlength - 1))else STrees_MoveToParent(treeinfo))	pre pre_STrees_MoveToParent(treeinfo)STrees_Root' (STrees_Tree -> STrees_Node)	STrees_Root(tree) ==(iota root in set tree & STrees_IsRoot(tree, root))	pre (tree <> {})STrees_Parent' (STrees_Tree * STrees_Node -> STrees_Node)	STrees_Parent(tree, node) ==(iota parent in set tree & STrees_IsParentOf(tree, parent, node))	pre ((node in set tree) and (not STrees_IsRoot(tree, node)))STrees_LeftChild' (STrees_Tree * STrees_Node -> STrees_Node)	STrees_LeftChild(tree, parent) ==(iota leftchild in set tree & STrees_IsLeftChildOf(tree, leftchild, parent))	pre ((parent in set tree) and STrees_HasLeftChild(tree, parent))STrees_RightChild' (STrees_Tree * STrees_Node -> STrees_Node)	STrees_RightChild(tree, parent) ==(iota rightchild in set tree & STrees_IsRightChildOf(tree, rightchild, parent))	pre ((parent in set tree) and STrees_HasRightChild(tree, parent))STrees_GetNode' (STrees_Tree * nat1 -> STrees_Node)	STrees_GetNode(tree, position) ==(iota node in set tree & ((node.position) = position))	pre (exists [node in set tree] & ((node.position) = position))STrees_GetData' (STrees_Info * nat1 -> STrees_Data)	STrees_GetData(mk_STrees_Info(tree, current), position) ==let mk_STrees_Node(data, -)'STrees_Node = STrees_GetNode(tree, position) in data	pre STrees_ExistsNode(mk_STrees_Info(tree, current), position)STrees_StoreCurrentData' (STrees_Info * STrees_Data -> STrees_Info)	STrees_StoreCurrentData(mk_STrees_Info(tree, current), data) ==let mk_STrees_Node(-, position)'[STrees_Node] = current in let newcurrent'STrees_Node = mk_STrees_Node(data, position) in mk_STrees_Info(((tree \ {current}) union {newcurrent}), newcurrent)	pre (current <> nil)STrees_GetCurrentData' (STrees_Info -> STrees_Data)	STrees_GetCurrentData(mk_STrees_Info(tree, mk_STrees_Node(data, -))) ==data	pre (tree <> {})STrees_Size' (STrees_Info -> nat)	STrees_Size(mk_STrees_Info(tree, -)) ==(card tree)STrees_GetCurrentNode' (STrees_Info -> STrees_Node)	STrees_GetCurrentNode(mk_STrees_Info(-, current)) ==currentSTrees_SetCurrentNode' (STrees_Info * STrees_Node -> STrees_Info)	STrees_SetCurrentNode(mk_STrees_Info(tree, -), newcurrent) ==mk_STrees_Info(tree, newcurrent)	pre (newcurrent in set tree)STrees_HasLeftChild' (STrees_Tree * STrees_Node -> bool)	STrees_HasLeftChild(tree, parent) ==(exists1 child in set tree & STrees_IsLeftChildOf(tree, child, parent))	pre (parent in set tree)STrees_HasRightChild' (STrees_Tree * STrees_Node -> bool)	STrees_HasRightChild(tree, parent) ==(exists1 child in set tree & STrees_IsRightChildOf(tree, child, parent))	pre (parent in set tree)STrees_InOrderPredecessor' (STrees_Tree * STrees_Node -> STrees_Node)	STrees_InOrderPredecessor(tree, node) ==let leftchild'STrees_Node = STrees_LeftChild(tree, node) in let left'STrees_Tree = STrees_Subtree(tree, leftchild) in let rightpath'set of (STrees_Node) = {n | [n in set left] & (exists [p in set {0, ... ,(card left)}] & ((n.position) = ((((leftchild.position) + 1) * (2 ** p)) - 1)))} in (iota pred in set rightpath & (forall n in set rightpath & ((n.position) <= (pred.position))))	pre ((node in set tree) and STrees_HasLeftChild(tree, node))STrees_Delete' (STrees_Info -> STrees_Info)	STrees_Delete(mk_STrees_Info(tree, current)) ==let old'STrees_Tree = STrees_Subtree(tree, current) in (if (STrees_HasRightChild(tree, current) and STrees_HasLeftChild(tree, current))then let leftchild'STrees_Node = STrees_LeftChild(tree, current), rightchild'STrees_Node = STrees_RightChild(tree, current), left'STrees_Tree = STrees_Subtree(old, leftchild), mk_STrees_Node(-, position)'STrees_Node = STrees_InOrderPredecessor(old, current), newright'STrees_Tree = STrees_MoveSubtree(old, rightchild, ((2 * position) + 1)), newleft'STrees_Tree = (left union newright), new'STrees_Tree = STrees_MoveSubtree(newleft, STrees_Root(newleft), (current.position)) in mk_STrees_Info(((tree \ old) union new), STrees_Root(new))elseif STrees_HasLeftChild(tree, current)then let leftchild'STrees_Node = STrees_LeftChild(tree, current), new'STrees_Tree = STrees_MoveSubtree(old, leftchild, (current.position)) in mk_STrees_Info(((tree \ old) union new), STrees_Root(new))elseif STrees_HasRightChild(tree, current)then let rightchild'STrees_Node = STrees_RightChild(tree, current), new'STrees_Tree = STrees_MoveSubtree(old, rightchild, (current.position)) in mk_STrees_Info(((tree \ old) union new), STrees_Root(new))else mk_STrees_Info((tree \ {current}), STrees_Parent(tree, current)))	pre (current <> nil)	post inv_STrees_Info(RESULT)STrees_Subtree' (STrees_Tree * STrees_Node -> STrees_Tree)	STrees_Subtree(tree, mk_STrees_Node(rootdata, rootpos)) =={mk_STrees_Node(d, p) | [mk_STrees_Node(d, p) in set tree] & (exists1 n in set {0, ... ,(card tree)} & ((p >= (rootpos * (2 ** n))) and (p < ((rootpos + 1) * (2 ** n)))))}	pre (mk_STrees_Node(rootdata, rootpos) in set tree)STrees_MoveSubtree' (STrees_Tree * STrees_Node * nat1 -> STrees_Tree)	STrees_MoveSubtree(tree, subtreeRoot, newRootPos) ==let subtree'STrees_Tree = STrees_Subtree(tree, subtreeRoot), mk_STrees_Node(-, oldRootPos)'STrees_Node = subtreeRoot in {STrees_MoveNode(tree, node, oldRootPos, newRootPos) | [node in set subtree]}	pre (subtreeRoot in set tree)STrees_MoveNode' (STrees_Tree * STrees_Node * nat1 * nat1 -> STrees_Node)	STrees_MoveNode(tree, mk_STrees_Node(d, p), oldRootPos, newRootPos) ==let n'int = (iota n in set {0, ... ,(card tree)} & ((p >= (oldRootPos * (2 ** n))) and (p < ((oldRootPos + 1) * (2 ** n))))) in mk_STrees_Node(d, (((newRootPos * (2 ** n)) + p) - (oldRootPos * (2 ** n))))STrees_ExistsData' (STrees_Info * STrees_Data -> bool)	STrees_ExistsData(mk_STrees_Info(tree, -), data) ==(exists [node in set tree] & ((node.data) = data))STrees_ExistsNode' (STrees_Info * nat1 -> bool)	STrees_ExistsNode(mk_STrees_Info(tree, -), position) ==(exists [node in set tree] & ((node.position) = position))STrees_ExistsDirection' (STrees_Info * STrees_Direction -> bool)	STrees_ExistsDirection(mk_STrees_Info(tree, current), direction) ==(cases direction 'case <ToRoot> -> (tree <> {}),case <ToLeft> -> (if (current <> nil)then STrees_HasLeftChild(tree, current)else false),case <ToRight> -> (if (current <> nil)then STrees_HasRightChild(tree, current)else false)end)static private Trees_Data = Datastatic private Trees_Direction = STrees_Directionstatic private Trees_Tree = compose Trees_Tree of treePtr'Nodes_NodePtr, current'Nodes_NodePtr endTrees_Position' (Heaps_Heap * Nodes_NodePtr -> nat1)	Trees_Position(heap, child) ==let parent'Nodes_NodePtr = Nodes_GetParent(Heaps_Retrieve(heap, child)) in (if (parent = NIL)then 1elseif Trees_IsRightChildOf(heap, child, parent)then ((2 * Trees_Position(heap, parent)) + 1)else (2 * Trees_Position(heap, parent)))	pre (child <> NIL)Trees_Set' (Heaps_Heap * Trees_Tree -> STrees_Info)	Trees_Set(heap, mk_Trees_Tree(treePtr, current)) ==(if (treePtr <> NIL)then let treeset'STrees_Tree = STrees_MkTree(Trees_SubtreeToSet(heap, treePtr, 1)) in let data'Nodes_Data = Nodes_GetData(Heaps_Retrieve(heap, current)) in let position'nat1 = Trees_Position(heap, current) in let currentnode'STrees_Node = STrees_MkNode(data, position) in STrees_MkInfo(treeset, currentnode)else STrees_Init())Trees_SubtreeToSet' (Heaps_Heap * Nodes_NodePtr * nat1 -> set of (STrees_Node))	Trees_SubtreeToSet(heap, subtree, position) ==(if (subtree <> NIL)then (({STrees_MkNode(Nodes_GetData(Heaps_Retrieve(heap, subtree)), position)} union Trees_SubtreeToSet(heap, Nodes_GetLeft(Heaps_Retrieve(heap, subtree)), (2 * position))) union Trees_SubtreeToSet(heap, Nodes_GetRight(Heaps_Retrieve(heap, subtree)), ((2 * position) + 1)))else {})Trees_HasLeftChild' (Heaps_Heap * Nodes_NodePtr -> bool)	Trees_HasLeftChild(heap, ptr) ==(if (ptr <> NIL)then (Nodes_GetLeft(Heaps_Retrieve(heap, ptr)) <> NIL)else false)	pre ((ptr <> NIL) => pre_Heaps_Retrieve(heap, ptr))Trees_HasRightChild' (Heaps_Heap * Nodes_NodePtr -> bool)	Trees_HasRightChild(heap, ptr) ==(if (ptr <> NIL)then (Nodes_GetRight(Heaps_Retrieve(heap, ptr)) <> NIL)else false)	pre ((ptr <> NIL) => pre_Heaps_Retrieve(heap, ptr))Trees_IsRightChildOf' (Heaps_Heap * Nodes_NodePtr * Nodes_NodePtr -> bool)	Trees_IsRightChildOf(heap, child, parent) ==((child = Nodes_GetRight(Heaps_Retrieve(heap, parent))) and (parent = Nodes_GetParent(Heaps_Retrieve(heap, child))))	pre (pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child))Trees_IsLeftChildOf' (Heaps_Heap * Nodes_NodePtr * Nodes_NodePtr -> bool)	Trees_IsLeftChildOf(heap, child, parent) ==((child = Nodes_GetLeft(Heaps_Retrieve(heap, parent))) and (parent = Nodes_GetParent(Heaps_Retrieve(heap, child))))	pre (pre_Heaps_Retrieve(heap, parent) and pre_Heaps_Retrieve(heap, child))Trees_IsRoot' (Heaps_Heap * Nodes_NodePtr -> bool)	Trees_IsRoot(heap, ptr) ==(Nodes_GetParent(Heaps_Retrieve(heap, ptr)) = NIL)	pre (ptr <> NIL)Trees_Init' (() -> Trees_Tree)	Trees_Init() ==mk_Trees_Tree(NIL, NIL)Trees_Insert (Trees_Tree * Trees_Data * Trees_Direction ==> Trees_Tree)	Trees_Insert(tree, data, direction) ==cases direction '  case <ToRoot> -> return (Trees_InsertRoot(data))  case <ToLeft> -> return (Trees_InsertLeft(tree, data))  case <ToRight> -> return (Trees_InsertRight(tree, data))esac	pre (Heaps_Available(heap) and let mk_Trees_Tree(treePtr, current)'Trees_Tree = tree in (((direction = <ToRoot>) => (treePtr = NIL)) and (((direction = <ToRight>) => (not Trees_HasRightChild(heap, current))) and ((direction = <ToLeft>) => (not Trees_HasLeftChild(heap, current))))))	post (((Heaps_AmountUsed(heap~) + 1) = Heaps_AmountUsed(heap)) and let old'STrees_Info = Trees_Set(heap~, tree) in (STrees_Insert(old, data, direction) = Trees_Set(heap, RESULT)))Trees_InsertRoot (Trees_Data ==> Trees_Tree)	Trees_InsertRoot(data) ==(newTreePtr'Nodes_NodePtr '= NEW(Nodes_MkBinaryTree(data, NIL, NIL, NIL))return (mk_Trees_Tree(newTreePtr, newTreePtr)))Trees_InsertLeft (Trees_Tree * Trees_Data ==> Trees_Tree)	Trees_InsertLeft(mk_Trees_Tree(treePtr, current), data) ==(new'Nodes_NodePtr '= NEW(Nodes_MkBinaryTree(data, NIL, NIL, current))SET_LEFT(current, new);return (mk_Trees_Tree(treePtr, new)))Trees_InsertRight (Trees_Tree * Trees_Data ==> Trees_Tree)	Trees_InsertRight(mk_Trees_Tree(treePtr, current), data) ==(new'Nodes_NodePtr '= NEW(Nodes_MkBinaryTree(data, NIL, NIL, current))SET_RIGHT(current, new);return (mk_Trees_Tree(treePtr, new)))Trees_InOrderPredecessor (Nodes_NodePtr ==> Nodes_NodePtr)	Trees_InOrderPredecessor(ptr) ==(pred'Nodes_NodePtr '= LEFT(ptr)while Trees_HasRightChild(heap, pred) do pred '= RIGHT(pred);return (pred))	pre Trees_HasLeftChild(heap, ptr)Trees_Delete (Trees_Tree ==> Trees_Tree)	Trees_Delete(mk_Trees_Tree(treePtr, current)) ==(hasLeftChild'bool '= Trees_HasLeftChild(heap, current)hasRightChild'bool '= Trees_HasRightChild(heap, current)newcurrent'Nodes_NodePtr '= (undefined)newtree'Nodes_NodePtr '= treePtrparent'Nodes_NodePtr '= PARENT(current)newchild'Nodes_NodePtr '= (undefined)if (hasLeftChild or hasRightChild)then(if hasLeftChildthen(newcurrent '= LEFT(current);if hasRightChildthen(right'Nodes_NodePtr '= RIGHT(current)pred'Nodes_NodePtr '= Trees_InOrderPredecessor(current)SET_PARENT(right, pred);SET_RIGHT(pred, right)))elsenewcurrent '= RIGHT(current);newchild '= newcurrent;SET_PARENT(newcurrent, parent))else(newcurrent '= parent;newchild '= NIL);if Trees_IsRoot(heap, current)thennewtree '= newchildelseif Trees_IsRightChildOf(heap, current, parent)thenSET_RIGHT(parent, newchild)elseSET_LEFT(parent, newchild);DISPOSE(current);return (mk_Trees_Tree(newtree, newcurrent)))	pre (treePtr <> NIL)	post ((Heaps_AmountUsed(heap~) = (Heaps_AmountUsed(heap) + 1)) and let old'STrees_Info = Trees_Set(heap~, mk_Trees_Tree(treePtr, current)) in (STrees_Delete(old) = Trees_Set(heap, RESULT)))Trees_SearchSubtree (Nodes_NodePtr * Trees_Data ==> bool)	Trees_SearchSubtree(subtree, dataToFind) ==(if (subtree <> NIL)then(def data = DATA(subtree) in if (data = dataToFind)thenreturn (true)elsereturn ((Trees_SearchSubtree(RIGHT(subtree), dataToFind) or Trees_SearchSubtree(LEFT(subtree), dataToFind))))elsereturn (false))Trees_ExistsData (Trees_Tree * Trees_Data ==> bool)	Trees_ExistsData(tree, data) ==Trees_SearchSubtree((tree.treePtr), data)	post (STrees_ExistsData(Trees_Set(heap, tree), data) = RESULT)Trees_ExistsDirection (Trees_Tree * Trees_Direction ==> bool)	Trees_ExistsDirection(tree, direction) ==cases direction '  case <ToRoot> -> return (((tree.treePtr) <> NIL))  case <ToLeft> -> return ((((tree.current) <> NIL) and Trees_HasLeftChild(heap, (tree.current))))  case <ToRight> -> return ((((tree.current) <> NIL) and Trees_HasRightChild(heap, (tree.current))))esac	post (STrees_ExistsDirection(Trees_Set(heap, tree), direction) = RESULT)Trees_GetCurrentData (Trees_Tree ==> Trees_Data)	Trees_GetCurrentData(tree) ==DATA((tree.current))	pre ((tree.treePtr) <> NIL)	post (STrees_GetCurrentData(Trees_Set(heap, tree)) = RESULT)Trees_StoreCurrentData (Trees_Tree * Trees_Data ==> Trees_Tree)	Trees_StoreCurrentData(tree, data) ==(SET_DATA((tree.current), data);return (tree))	pre ((tree.treePtr) <> NIL)	post (STrees_StoreCurrentData(Trees_Set(heap~, tree), data) = Trees_Set(heap, RESULT))Trees_MoveInDir (Trees_Tree * Trees_Direction ==> Trees_Tree)	Trees_MoveInDir(tree, direction) ==cases direction '  case <ToRoot> -> return (mk_Trees_Tree((tree.treePtr), (tree.treePtr)))  case <ToLeft> -> return (mk_Trees_Tree((tree.treePtr), LEFT((tree.current))))  case <ToRight> -> return (mk_Trees_Tree((tree.treePtr), RIGHT((tree.current))))esac	pre (((tree.treePtr) <> NIL) and (((direction = <ToLeft>) => Trees_HasLeftChild(heap, (tree.current))) and ((direction = <ToRight>) => Trees_HasRightChild(heap, (tree.current)))))	post (STrees_MoveInDir(Trees_Set(heap~, tree), direction) = Trees_Set(heap, RESULT))Trees_MoveToParent (Trees_Tree ==> Trees_Tree)	Trees_MoveToParent(tree) ==return (mk_Trees_Tree((tree.treePtr), PARENT((tree.current))))	pre (not Trees_IsRoot(heap, (tree.current)))	post (STrees_MoveToParent(Trees_Set(heap~, tree)) = Trees_Set(heap, RESULT))Trees_Size (Trees_Tree ==> nat)	Trees_Size(tree) ==Trees_SubtreeSize((tree.treePtr))	post (STrees_Size(Trees_Set(heap~, tree)) = RESULT)Trees_SubtreeSize (Nodes_NodePtr ==> nat)	Trees_SubtreeSize(subtree) ==if (subtree <> NIL)thenreturn (((1 + Trees_SubtreeSize(RIGHT(subtree))) + Trees_SubtreeSize(LEFT(subtree))))elsereturn (0)Trees_Traverse (Trees_Tree * (Trees_Data -> Trees_Data) ==> Trees_Tree)	Trees_Traverse(tree, traversal) ==(Trees_TraverseSubtree((tree.treePtr), traversal);return (tree))	post (STrees_Traverse(Trees_Set(heap~, tree), traversal) = Trees_Set(heap, RESULT))Trees_TraverseSubtree (Nodes_NodePtr * (Trees_Data -> Trees_Data) ==> ())	Trees_TraverseSubtree(subtree, traversal) ==if (subtree <> NIL)then(SET_DATA(subtree, traversal(DATA(subtree)));Trees_TraverseSubtree(LEFT(subtree), traversal);Trees_TraverseSubtree(RIGHT(subtree), traversal))state SystemStateof[heap'Heaps_Heap, slist'SList_List, charQueue'Queues_Queue, charStack'Stacks_Stack, dlist'DList_List, charTree'Trees_Tree, stree'STrees_Info]	init s == (s = mk_SystemState(Heaps_Init(), SList_Init(), Queues_Init(), Stacks_Init(), DList_Init(), Trees_Init(), STrees_Init()))static private Data = charTestSList (() ==> bool)	TestSList() ==(slist '= SList_Insert(slist, 'b', 1);slist '= SList_Update(slist, 'a', 1);slist '= SList_Delete(slist, 1);slist '= SList_Insert(slist, 'a', 1);slist '= SList_Insert(slist, 'b', 2);slist '= SList_Update(slist, 'c', 2);slist '= SList_Delete(slist, 2);slist '= SList_Insert(slist, 'b', 2);slist '= SList_Insert(slist, 'c', 3);slist '= SList_Update(slist, 'd', 2);slist '= SList_Update(slist, 'b', 3);slist '= SList_Delete(slist, 2);slist '= SList_Append(slist, 'c');slist '= SList_Delete(slist, 1);slist '= SList_Insert(slist, 'a', 1);slist '= SList_Insert(slist, 'f', 4);slist '= SList_Insert(slist, 'd', 4);slist '= SList_Append(slist, 'g');slist '= SList_Insert(slist, 'e', 5);slist '= SList_Append(slist, 'h');slist '= SList_Append(slist, 'i');slist '= SList_Append(slist, 'j');slist '= SList_Delete(slist, 10);return (([SList_Element(slist, i) | i in set {1, ... ,9}] = "abcdefghi")))TestDList (() ==> bool)	TestDList() ==(dlist '= DList_Insert(dlist, 'b', 1);dlist '= DList_Update(dlist, 'a', 1);dlist '= DList_Delete(dlist, 1);dlist '= DList_Insert(dlist, 'a', 1);dlist '= DList_Insert(dlist, 'b', 2);dlist '= DList_Update(dlist, 'c', 2);dlist '= DList_Delete(dlist, 2);dlist '= DList_Insert(dlist, 'b', 2);dlist '= DList_Insert(dlist, 'c', 3);dlist '= DList_Update(dlist, 'd', 2);dlist '= DList_Update(dlist, 'b', 3);dlist '= DList_Delete(dlist, 2);dlist '= DList_Append(dlist, 'c');dlist '= DList_Delete(dlist, 1);dlist '= DList_Insert(dlist, 'a', 1);dlist '= DList_Insert(dlist, 'f', 4);dlist '= DList_Insert(dlist, 'd', 4);dlist '= DList_Append(dlist, 'g');dlist '= DList_Insert(dlist, 'e', 5);dlist '= DList_Append(dlist, 'h');dlist '= DList_Append(dlist, 'i');dlist '= DList_Append(dlist, 'j');dlist '= DList_Delete(dlist, 10);return (([DList_Element(dlist, i) | i in set {1, ... ,9}] = "abcdefghi")))static private InsertResult'STrees_Tree = STrees_MkTree({STrees_MkNode('a', 1), STrees_MkNode('b', 2), STrees_MkNode('c', 3), STrees_MkNode('d', 4), STrees_MkNode('e', 5), STrees_MkNode('f', 6), STrees_MkNode('g', 7), STrees_MkNode('h', 8), STrees_MkNode('i', 9), STrees_MkNode('j', 10), STrees_MkNode('k', 11), STrees_MkNode('l', 12), STrees_MkNode('m', 13), STrees_MkNode('n', 14), STrees_MkNode('o', 15), STrees_MkNode('p', 16), STrees_MkNode('q', 17), STrees_MkNode('r', 18), STrees_MkNode('s', 19), STrees_MkNode('t', 20), STrees_MkNode('u', 21), STrees_MkNode('v', 22), STrees_MkNode('w', 23), STrees_MkNode('x', 24), STrees_MkNode('y', 25), STrees_MkNode('z', 26)})static private DeleteResult'STrees_Tree = STrees_MkTree({STrees_MkNode('a', 1), STrees_MkNode('d', 2), STrees_MkNode('c', 3), STrees_MkNode('h', 4), STrees_MkNode('i', 5), STrees_MkNode('f', 6), STrees_MkNode('o', 7), STrees_MkNode('p', 8), STrees_MkNode('r', 10), STrees_MkNode('s', 11), STrees_MkNode('l', 12), STrees_MkNode('z', 13), STrees_MkNode('j', 23), STrees_MkNode('x', 24), STrees_MkNode('y', 25), STrees_MkNode('t', 46), STrees_MkNode('u', 47), STrees_MkNode('k', 95), STrees_MkNode('v', 190), STrees_MkNode('w', 191)})static private TraverseResult'STrees_Tree = STrees_MkTree({STrees_MkNode('a', 1), STrees_MkNode('a', 2), STrees_MkNode('a', 3), STrees_MkNode('a', 4), STrees_MkNode('a', 5), STrees_MkNode('a', 6), STrees_MkNode('b', 7), STrees_MkNode('b', 8), STrees_MkNode('b', 10), STrees_MkNode('b', 11), STrees_MkNode('b', 12), STrees_MkNode('b', 13), STrees_MkNode('a', 23), STrees_MkNode('b', 24), STrees_MkNode('b', 25), STrees_MkNode('b', 46), STrees_MkNode('b', 47), STrees_MkNode('b', 95), STrees_MkNode('b', 190), STrees_MkNode('b', 191)})static private AlphabetSubset'set of (char) = {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}Traversal' (char -> char)	Traversal(ch) ==(if (ch in set AlphabetSubset)then 'a'else 'b')TestSTreesInsert (() ==> bool)	TestSTreesInsert() ==(stree '= STrees_Insert(stree, 'a', <ToRoot>);stree '= STrees_Insert(stree, 'b', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'c', <ToRight>);stree '= STrees_MoveToParent(stree);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_Insert(stree, 'd', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'e', <ToRight>);stree '= STrees_MoveInDir(stree, <ToRoot>);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_Insert(stree, 'f', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'g', <ToRight>);stree '= STrees_MoveInDir(stree, <ToRoot>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_Insert(stree, 'h', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'i', <ToRight>);stree '= STrees_MoveToAnscestor(stree, 2);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_Insert(stree, 'j', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'k', <ToRight>);stree '= STrees_MoveInDir(stree, <ToRoot>);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_Insert(stree, 'l', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'm', <ToRight>);stree '= STrees_MoveToAnscestor(stree, 2);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_Insert(stree, 'n', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'o', <ToRight>);stree '= STrees_MoveInDir(stree, <ToRoot>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_Insert(stree, 'p', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'q', <ToRight>);stree '= STrees_MoveToAnscestor(stree, 2);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_Insert(stree, 'r', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 's', <ToRight>);stree '= STrees_MoveToAnscestor(stree, 3);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_Insert(stree, 't', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'u', <ToRight>);stree '= STrees_MoveToAnscestor(stree, 2);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_Insert(stree, 'v', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'w', <ToRight>);stree '= STrees_MoveInDir(stree, <ToRoot>);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_MoveInDir(stree, <ToLeft>);stree '= STrees_Insert(stree, 'x', <ToLeft>);stree '= STrees_MoveToParent(stree);stree '= STrees_Insert(stree, 'y', <ToRight>);stree '= STrees_MoveToAnscestor(stree, 2);stree '= STrees_MoveInDir(stree, <ToRight>);stree '= STrees_Insert(stree, 'z', <ToLeft>);return ((STrees_GetTree(stree) = InsertResult)))TestSTreesDelete (() ==> bool)	TestSTreesDelete() ==(stree '= STrees_MoveToNode(stree, 14);stree '= STrees_Delete(stree);stree '= STrees_MoveToNode(stree, 17);stree '= STrees_Delete(stree);stree '= STrees_MoveToNode(stree, 13);stree '= STrees_Delete(stree);stree '= STrees_MoveToNode(stree, 7);stree '= STrees_Delete(stree);stree '= STrees_MoveToNode(stree, 5);stree '= STrees_Delete(stree);stree '= STrees_MoveToNode(stree, 2);stree '= STrees_Delete(stree);return ((STrees_GetTree(stree) = DeleteResult)))TestSTrees (() ==> bool)	TestSTrees() ==(if STrees_ExistsDirection(stree, <ToLeft>)thenreturn (false);if STrees_ExistsDirection(stree, <ToRight>)thenreturn (false);if (not TestSTreesInsert())thenreturn (false);if (not TestSTreesDelete())thenreturn (false);if (not STrees_ExistsData(stree, 'c'))thenreturn (false);if (not STrees_ExistsNode(stree, 3))thenreturn (false);stree '= STrees_MoveToNode(stree, 3);if (not STrees_ExistsDirection(stree, <ToLeft>))thenreturn (false);if (not STrees_ExistsDirection(stree, <ToRight>))thenreturn (false);if (not STrees_ExistsDirection(stree, <ToRoot>))thenreturn (false);if ('z' <> STrees_GetData(stree, 13))thenreturn (false);stree '= STrees_SetCurrentNode(stree, STrees_MkNode('z', 13));if (STrees_MkNode('z', 13) <> STrees_GetCurrentNode(stree))thenreturn (false);stree '= STrees_StoreCurrentData(stree, 'Z');if ('Z' <> STrees_GetCurrentData(stree))thenreturn (false);if (STrees_Size(stree) <> 20)thenreturn (false);stree '= STrees_Traverse(stree, Traversal);return ((STrees_GetTree(stree) = TraverseResult)))TestTreesInsert (() ==> ())	TestTreesInsert() ==(charTree '= Trees_Insert(charTree, 'a', <ToRoot>);charTree '= Trees_Insert(charTree, 'b', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'c', <ToRight>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_Insert(charTree, 'd', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'e', <ToRight>);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_Insert(charTree, 'f', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'g', <ToRight>);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_Insert(charTree, 'h', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'i', <ToRight>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_Insert(charTree, 'j', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'k', <ToRight>);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_Insert(charTree, 'l', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'm', <ToRight>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_Insert(charTree, 'n', <ToLeft>);charTree '= Trees_MoveToParent(charTree);charTree '= Trees_Insert(charTree, 'o', <ToRight>))TestTreesDelete (() ==> ())	TestTreesDelete() ==(charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_Delete(charTree);charTree '= Trees_Delete(charTree);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_Delete(charTree);charTree '= Trees_Delete(charTree);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToLeft>);charTree '= Trees_Delete(charTree);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_MoveInDir(charTree, <ToRight>);charTree '= Trees_Delete(charTree);charTree '= Trees_MoveInDir(charTree, <ToRoot>);charTree '= Trees_Delete(charTree))TestTrees (() ==> bool)	TestTrees() ==(if Trees_ExistsDirection(charTree, <ToLeft>)thenreturn (false);if Trees_ExistsDirection(charTree, <ToRight>)thenreturn (false);TestTreesInsert();TestTreesDelete();if (not Trees_ExistsData(charTree, 'i'))thenreturn (false);if Trees_ExistsDirection(charTree, <ToLeft>)thenreturn (false);if (not Trees_ExistsDirection(charTree, <ToRight>))thenreturn (false);if (not Trees_ExistsDirection(charTree, <ToRoot>))thenreturn (false);charTree '= Trees_StoreCurrentData(charTree, 'Z');if ('Z' <> Trees_GetCurrentData(charTree))thenreturn (false);if (Trees_Size(charTree) <> 8)thenreturn (false);charTree '= Trees_Traverse(charTree, Traversal);return (true))end DEFAULT
