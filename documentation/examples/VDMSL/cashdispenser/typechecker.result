RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstate Systemof[accounts'map (AccountId) to (Account), illegalCards'set of (CardId), curCard'[Card], cardOk'bool, retainedCards'set of (Card)]	inv mk_System(accs, -, curCard, cardOk, -) == (((curCard = nil) => (not cardOk)) and (forall id1, id2 in set (dom accs) & ((id1 <> id2) => (((dom (accs(id1).cards)) inter (dom (accs(id2).cards))) = {}))))	init s == (s = mk_System({}, {}, nil, false, {}))static private Account = compose Account of cards'map (CardId) to (Cardholder), balance'nat, transactions'seq of (Transaction) end	inv account == TransactionsInvariant((account.transactions))static private Transaction = compose Transaction of date'Date, cardId'CardId, amount'nat endstatic private Card = compose Card of code'Code, cardId'CardId, accountId'AccountId endstatic private Cardholder = compose Cardholder of name'Name endstatic private AccountId = natstatic private Name = seq of (char)static private CardId = natstatic private Code = natstatic private PinCode = natstatic private Date = seq of (char)static private TransactionsInvariant' (seq of (Transaction) +> bool)	TransactionsInvariant(ts) ==(forall date in set {(ts(i).date) | [i in set (inds ts)]} & (DateTotal(date, ts) <= dailyLimit))static private DateTotal' (Date * seq of (Transaction) +> nat)	DateTotal(date, ts) ==Sum([(ts(i).amount) | i in set (inds ts) & ((ts(i).date) = date)])static private dailyLimit'nat = 2000InsertCard (Card ==> ())	InsertCard(c) ==curCard '= c	pre (curCard = nil)Validate (PinCode ==> (<PinNotOk> | <PinOk> | <Retained>))	Validate(pin) ==let private value codeOk'boolprivate value cardLegal'bool in (if (not cardLegal)then(retainedCards '= (retainedCards union {curCard});cardOk '= false;curCard '= nil;return (<Retained>))elsecardOk '= codeOk;return ((if cardOkthen <PinOk>else <PinNotOk>)))	pre ((curCard <> nil) and (not cardOk))ReturnCard (() ==> ())	ReturnCard() ==(cardOk '= false;curCard '= nil)	pre (curCard <> nil)GetBalance (() ==> nat)	GetBalance() ==return ((accounts((curCard.accountId)).balance))	pre ((curCard <> nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts)))MakeWithdrawal (nat * Date ==> bool)	MakeWithdrawal(amount, date) ==let private value cardId, accountId'[Card]private value transaction'Transaction in if ((((accounts(accountId).balance) - amount) >= 0) and (DateTotal(date, ((accounts(accountId).transactions) ^ [transaction])) <= dailyLimit))then(accounts(accountId).balance '= ((accounts(accountId).balance) - amount);accounts(accountId).transactions '= ((accounts(accountId).transactions) ^ [transaction]);return (true))elsereturn (false)	pre ((curCard <> nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts)))RequestStatement (() ==> (Name * seq of (Transaction) * nat))	RequestStatement() ==let private value cardId, accountId'[Card]private value cards, balance, transactions'Account in return (mk_((cards(cardId).name), transactions, balance))	pre ((curCard <> nil) and (cardOk and IsLegalCard(curCard, illegalCards, accounts)))static private IsLegalCard' (Card * set of (CardId) * map (AccountId) to (Account) -> bool)	IsLegalCard(mk_Card(-, cardId, accountId), pillegalcards, paccounts) ==((cardId not in set pillegalcards) and ((accountId in set (dom paccounts)) and (cardId in set (dom (paccounts(accountId).cards)))))ReportIllegalCard (CardId ==> ())	ReportIllegalCard(cardId) ==illegalCards '= (illegalCards union {cardId})AddAccount (AccountId * Account ==> ())	AddAccount(accountId, account) ==accounts '= (accounts munion {accountId |-> account})	pre (accountId not in set (dom accounts))static private Encode' (PinCode +> Code)	Encode(pin) ==pinstatic private Sum' (seq of (real) +> real)	Sum(rs) ==(if (rs = [])then 0else ((hd rs) + Sum((tl rs))))static private Len' (seq of (real) +> nat)	Len(list) ==(len list)[TestCash] = [[let c in set {mk_Card(1, 1, 1), mk_Card(2, 2, 2)} in [[InsertCard(c)], [Validate(1111)], [ReportIllegalCard((c.cardId))]]{1, 5}]]end DEFAULT
