RESULT:result:-1:-1,-1:module Databaseexportsexport alldefinitionsstatic private PhysicalFile = compose PhysicalFile of headersec'map (seq of (char)) to (seq of ((unresolved Database`Parameter))), datasec'map (nat) to ((([(unresolved Database`Scope)] * (unresolved Database`Record)))) endstatic private HeaderEntity = compose HeaderEntity of name'seq of (char), parms'seq of ((unresolved Database`Parameter)) endstatic private Scope = compose Scope of  endstatic private Record = ((unresolved Database`SimpleRecord) | (unresolved Database`SuperRecord))static private SuperRecord = compose SuperRecord of rec_list'seq of ((unresolved Database`SimpleRecord)) endstatic private SimpleRecord = compose SimpleRecord of name'seq of (char), parms'seq of ((unresolved Database`Parameter)) endstatic private Parameter = ((unresolved Database`BinaryParameter) | (unresolved Database`EntityInstanceName) | (unresolved Database`EnumerationParameter) | (unresolved Database`IntegerParameter) | (unresolved Database`ListParameter) | (unresolved Database`OmittedParameter) | (unresolved Database`RealParameter) | (unresolved Database`StringParameter) | (unresolved Database`TypedParameter) | (unresolved Database`UnknownParameter))static private StringParameter = compose StringParameter of data'seq of (char) endstatic private RealParameter = compose RealParameter of data'real endstatic private IntegerParameter = compose IntegerParameter of data'int endstatic private EntityInstanceName = compose EntityInstanceName of data'nat endstatic private EnumerationParameter = compose EnumerationParameter of data'seq of (char) endstatic private BinaryParameter = compose BinaryParameter of data'bool endstatic private ListParameter = compose ListParameter of data'seq of ((unresolved Database`Parameter)) endstatic private TypedParameter = compose TypedParameter of name'seq of (char), data'(unresolved Database`Parameter) endstatic private OmittedParameter = compose OmittedParameter of  endstatic private UnknownParameter = compose UnknownParameter of  endCheckReferences ((unresolved Database`Parameter) ==> set of (nat))	CheckReferences(parm) ==cases parm '  case mk_(unresolved Database`EntityInstanceName)(id) -> return ({id})  case mk_(unresolved Database`ListParameter)(parms) -> (res'set of (nat) '= {}for subparm in parms dores '= (res union CheckReferences(subparm));return (res))  others -> return ({})esacFindAllReferencesToEntity (nat ==> set of (nat))	FindAllReferencesToEntity(eid) ==let private value eins'? in (res'set of (nat) '= {}for all ein in set eins dolet private value parms'? in if (eid in set CheckReferences(mk_ListParameter(parms)))thenres '= (res union {ein});return (res))FindAllInstances (seq of (char) ==> set of (nat))	FindAllInstances(nm) ==let private value eins'? in (res'set of (nat) '= {}for all ein in set eins dolet private value rec'? in if IsA(rec, nm)thenres '= (res union {ein});return (res))LookUpEntityInstance (nat ==> [(unresolved Database`Record)])	LookUpEntityInstance(ein) ==let private value eins'? in if (ein in set eins)thenlet private value rec'? in return (rec)elsereturn (nil)TransformRmVertex (nat ==> nat)	TransformRmVertex(rmv_id) ==let private value parms'? in let private value cpnt_id'? in return (cpnt_id)TransformRmEdge (nat ==> set of (((nat * nat))))	TransformRmEdge(rme_id) ==let private value parms'? in let private value rmees'? in (res'set of (((nat * nat))) '= {}for rmee in rmees dolet private value rmee_id'? in let private value rmee_ref'? in res '= (res union {mk_(rme_id, TransformRmVertex(rmee_ref))});return (res))TransformRmLoop (nat ==> seq of (nat))	TransformRmLoop(rml_id) ==let private value parms'? in let private value rmess'? in (res'set of (((nat * nat))) '= {}for rmes in rmess dolet private value rmes_id'? in let private value rme_ref'? in for all rme_id in set rme_ref dores '= (res union TransformRmEdge(rme_id));return (SortPoints(res)))Transform (() ==> set of (seq of (nat)))	Transform() ==let private value rmls'? in (res'set of (seq of (nat)) '= {}for all rml in set rmls dores '= (res union {TransformRmLoop(rml)});return (res))Create (set of (seq of (nat)) ==> ())	Create(AbstrMod) ==(ds'map (nat) to ((([(unresolved Database`Scope)] * (unresolved Database`Record)))) '= {}LookUpTable'map (nat) to (nat) '= {}polylist'seq of ((unresolved Database`EntityInstanceName)) '= []for all ent in set Collect(AbstrMod) do(last_id '= (last_id + 1);LookUpTable '= (LookUpTable munion {ent |-> last_id});let private value parms'? in ds '= (ds munion {last_id |-> mk_(nil, mk_SimpleRecord("VERTEX", [parms(3)]))}));for all poly in set AbstrMod do(last_id '= (last_id + 1);ds '= (ds munion {last_id |-> mk_(nil, mk_SimpleRecord("POLYLINE", [mk_ListParameter(MapInToOut(poly, LookUpTable))]))});polylist '= (polylist ^ [mk_EntityInstanceName(last_id)]));ds '= (ds munion {(last_id + 1) |-> mk_(nil, mk_SimpleRecord("DRAWING", [mk_ListParameter(polylist)]))});out_model '= mk_PhysicalFile({"FILE_NAME" |-> [mk_UnknownParameter()], "FILE_DESCRIPTION" |-> [mk_UnknownParameter()], "FILE_SCHEMA" |-> [mk_UnknownParameter()]}, ds))DoMapping ((unresolved Database`PhysicalFile) ==> (unresolved Database`PhysicalFile))	DoMapping(pf) ==(in_model '= pf;Create(Transform());return (out_model))MapInToOut' (seq of (nat) * map (nat) to (nat) -> seq of ((unresolved Database`EntityInstanceName)))	MapInToOut(ins, lut) ==(if (ins = [])then []else ([mk_EntityInstanceName(lut((hd ins)))] ^ MapInToOut((tl ins), lut)))LenPar1' (seq of (nat) * map (nat) to (nat) -> nat)	LenPar1(list, -) ==(len list)Collect' (set of (seq of (nat)) -> set of (nat))	Collect(theSet) ==(cases theSet 'case {} -> {}others let e in set theSet in ((elems e) union Collect((theSet \ {e})))end)SetCard' (set of (seq of (nat)) -> nat)	SetCard(s) ==(card s)IsA' ((unresolved Database`Record) * seq of (char) -> bool)	IsA(rec, nm) ==(if is_(rec, SimpleRecord)then let mk_(unresolved Database`SimpleRecord)(name, -) = rec in (nm = name)else false)SortInnerLeft' (set of (((nat * nat))) * nat -> seq of (nat))	SortInnerLeft(theSet, goal) ==(cases theSet 'case {} -> []others let mk_(a, b) in set theSet be st (a = goal) in SortInnerRight((theSet \ {mk_(a, b)}), b)end)SortInnerRight' (set of (((nat * nat))) * nat -> seq of (nat))	SortInnerRight(theSet, goal) ==(cases theSet 'case {} -> []others let mk_(a, b) in set theSet be st (b = goal) in ([b] ^ SortInnerLeft((theSet \ {mk_(a, b)}), a))end)SortPoints' (set of (((nat * nat))) -> seq of (nat))	SortPoints(theSet) ==let mk_(a, b) in set theSet in SortInnerRight((theSet \ {mk_(a, b)}), b)state Kernelof[in_model'(unresolved Database`PhysicalFile), out_model'(unresolved Database`PhysicalFile), last_id'nat]	init k == (k = mk_Kernel(mk_PhysicalFile({}, {}), mk_PhysicalFile({}, {}), 0))end Database
