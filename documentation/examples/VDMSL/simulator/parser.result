RESULT:result:-1:-1,-1:module TROMexportsexport alldefinitionsstatic private PortType = compose PortType of label'(unresolved TROM`String), cardinality'nat, portlist'seq of ((unresolved TROM`Port)) end	inv mk_(unresolved TROM`PortType)(label, cardinality, portlist) == (cardinality = (card (elems portlist)))static private Event = compose Event of label'(unresolved TROM`String), type'(unresolved TROM`EventType), porttype'(unresolved TROM`PortType) end	inv mk_(unresolved TROM`Event)(label, type, porttype) == (((type = <INTERNAL>) and ((porttype.label) = "NULLPORT")) or (((type = <INPUT>) and ((porttype.label) <> "NULLPORT")) or ((type = <OUTPUT>) and ((porttype.label) <> "NULLPORT"))))static private State = compose State of label'(unresolved TROM`String), type'(unresolved TROM`StateType), isinitial'bool, substates'set of ((unresolved TROM`State)) end	inv mk_(unresolved TROM`State)(label, type, isinitial, substates) == let exists_entry_state' (set of ((unresolved TROM`State)) +> bool)	exists_entry_state(substates) ==((exists1 s in set substates & ((s.isinitial) = true)) and (forall s in set substates & ((((s.type) = <SIMPLE>) and ((s.substates) = {})) or (((s.type) = <COMPLEX>) and exists_entry_state((s.substates)))))) in (((type = <SIMPLE>) and (substates = {})) or ((type = <COMPLEX>) and exists_entry_state(substates)))static private Attribute = compose Attribute of label'(unresolved TROM`String), type'(unresolved TROM`String) endstatic private LSLTrait = compose LSLTrait of traitlabel'(unresolved TROM`String), traittype'(unresolved TROM`String), elementtypes'seq of ((unresolved TROM`String)) endstatic private AttrFunction = compose AttrFunction of stat'(unresolved TROM`State), attributes'set of ((unresolved TROM`Attribute)) endstatic private TransitionSpec = compose TransitionSpec of label'(unresolved TROM`String), sourcestate'(unresolved TROM`State), destinstate'(unresolved TROM`State), triggerevent'(unresolved TROM`Event), portcondition'bool, enabcondition'bool, postcondition'bool endstatic private TimeConstraint = compose TimeConstraint of label'(unresolved TROM`String), transition'(unresolved TROM`TransitionSpec), constrainedevent'(unresolved TROM`Event), timebounds'(unresolved TROM`ReactionWindow), disablingstates'set of ((unresolved TROM`State)), reactionwindows'set of ((unresolved TROM`ReactionWindow)) end	inv mk_(unresolved TROM`TimeConstraint)(label, transition, cevent, tbounds, dstates, rwindows) == ((((cevent.type) = <INTERNAL>) or ((cevent.type) = <OUTPUT>)) and (forall rw in set rwindows & (((rw.uppertimebound) - (rw.lowertimebound)) = ((tbounds.uppertimebound) - (tbounds.lowertimebound)))))static private EventType = (<INPUT> | <INTERNAL> | <OUTPUT>)static private StateType = (<COMPLEX> | <SIMPLE>)static private ReactionWindow = compose ReactionWindow of lowertimebound'nat, uppertimebound'nat end	inv mk_(unresolved TROM`ReactionWindow)(lowertimebound, uppertimebound) == (lowertimebound <= uppertimebound)static private Port = compose Port of label'(unresolved TROM`String) endstatic private PortLink = compose PortLink of tromporttuple1'(unresolved TROM`TromPortTuple), tromporttuple2'(unresolved TROM`TromPortTuple) end	inv mk_(unresolved TROM`PortLink)(tromporttuple1, tromporttuple2) == ((tromporttuple1.tromlabel) <> (tromporttuple2.tromlabel))static private TromPortTuple = compose TromPortTuple of tromlabel'(unresolved TROM`String), portlabel'(unresolved TROM`String) endstatic private SimulationEvent = compose SimulationEvent of eventlabel'(unresolved TROM`String), tromlabel'(unresolved TROM`String), portlabel'(unresolved TROM`String), occurtime'nat, eventhistory'[(unresolved TROM`EventHistory)] endstatic private EventHistory = compose EventHistory of triggeredtransition'bool, tromcurrentstate'[(unresolved TROM`State)], assignmentvector'[token], reactionshistory'set of ((unresolved TROM`ReactionHistory)) endstatic private ReactionHistory = compose ReactionHistory of timeconstraint'(unresolved TROM`TimeConstraint), reactionwindow'(unresolved TROM`ReactionWindow), reaction'(unresolved TROM`Reaction) endstatic private Reaction = (<DISABLED> | <ENABLED> | <FIRED>)static private LSLTraitDefinition = compose LSLTraitDefinition of label'(unresolved TROM`String), paramets'seq of ((unresolved TROM`String)) endstatic private String = seq1 of (char)static private Trom = compose Trom of label'(unresolved TROM`String), tromclass'(unresolved TROM`String), porttypes'set of ((unresolved TROM`PortType)), events'set of ((unresolved TROM`Event)), states'set of ((unresolved TROM`State)), attributes'set of ((unresolved TROM`Attribute)), lsltraits'set of ((unresolved TROM`LSLTrait)), attrfunctions'set of ((unresolved TROM`AttrFunction)), transitionspecs'set of ((unresolved TROM`TransitionSpec)), timeconstraints'set of ((unresolved TROM`TimeConstraint)), currentstate'(unresolved TROM`State), assignmentvector'token end	inv mk_(unresolved TROM`Trom)(label, tromclass, porttypes, events, states, attributes, lsltraits, attrfunctions, transitionspecs, timeconstraints, currentstate, assignmentvector) == ((forall pt1, pt2 in set porttypes & (((pt1.label) = (pt2.label)) => (pt1 = pt2))) and ((forall e1, e2 in set events & (((e1.label) = (e2.label)) => (e1 = e2))) and ((forall s1, s2 in set states & (((s1.label) = (s2.label)) => (s1 = s2))) and ((forall a1, a2 in set attributes & (((a1.label) = (a2.label)) => (a1 = a2))) and ((forall tr1, tr2 in set lsltraits & (((tr1.traittype) = (tr2.traittype)) => (tr1 = tr2))) and ((forall af1, af2 in set attrfunctions & (((af1.stat) = (af2.stat)) => (af1 = af2))) and ((forall ts1, ts2 in set transitionspecs & (((ts1.label) = (ts2.label)) => (ts1 = ts2))) and ((forall tc1, tc2 in set timeconstraints & (((tc1.label) = (tc2.label)) => (tc1 = tc2))) and ((forall e in set events & (exists [pt in set porttypes] & (pt = (e.porttype)))) and ((exists1 s in set states & ((s.isinitial) = true)) and ((exists1 s in set states & ((currentstate = s) or substate_of(currentstate, s))) and ((forall a in set attributes & ((exists1 pt in set porttypes & ((pt.label) = (a.type))) or (exists1 tr in set lsltraits & ((tr.traittype) = (a.type))))) and ((forall tr in set lsltraits & (forall el in set (elems (tr.elementtypes)) & ((exists1 pt in set porttypes & ((pt.label) = el)) or (exists1 tr2 in set lsltraits & ((tr2.traittype) = el))))) and ((forall af in set attrfunctions & ((exists1 s in set states & ((s = (af.stat)) or substate_of((af.stat), s))) and (forall afa in set (af.attributes) & (exists1 a in set attributes & (a = afa))))) and ((forall ts in set transitionspecs & ((exists1 s in set states & ((s = (ts.sourcestate)) or substate_of((ts.sourcestate), s))) and ((exists1 d in set states & ((d = (ts.destinstate)) or substate_of((ts.destinstate), d))) and (exists1 e in set events & (e = (ts.triggerevent)))))) and (forall tc in set timeconstraints & ((exists1 ts in set transitionspecs & (ts = (tc.transition))) and ((exists1 e in set events & ((e = (tc.constrainedevent)) and (((e.type) = <INTERNAL>) or ((e.type) = <OUTPUT>)))) and (forall ds in set (tc.disablingstates) & (exists1 s in set states & ((s = ds) or substate_of(ds, s))))))))))))))))))))))static private Subsystem = compose Subsystem of label'(unresolved TROM`String), includes'set of ((unresolved TROM`Subsystem)), troms'set of ((unresolved TROM`Trom)), portlinks'set of ((unresolved TROM`PortLink)) end	inv mk_(unresolved TROM`Subsystem)(label, includes, troms, portlinks) == ((forall s1, s2 in set includes & (((s1.label) = (s2.label)) => (s1 = s2))) and (let included_subsystem' ((unresolved TROM`String) * set of ((unresolved TROM`Subsystem)) +> bool)	included_subsystem(subsystemlabel, subsystems) ==(exists1 s in set subsystems & (((s.label) = subsystemlabel) or included_subsystem(subsystemlabel, (s.includes)))) in (not included_subsystem(label, includes)) and ((forall trom1, trom2 in set troms & (((trom1.label) = (trom2.label)) => (trom1 = trom2))) and (let included_trom' ((unresolved TROM`String) * set of ((unresolved TROM`Subsystem)) +> bool)	included_trom(tromlabel, subsystems) ==(exists1 s in set subsystems & ((exists1 trom in set (s.troms) & ((trom.label) = tromlabel)) or included_trom(tromlabel, (s.includes)))) in (forall trom in set troms & (not included_trom((trom.label), includes))) and let linked_trom' ((unresolved TROM`TromPortTuple) * set of ((unresolved TROM`Trom)) +> bool)	linked_trom(tptuple, troms) ==(exists1 trom in set troms & (((trom.label) = (tptuple.tromlabel)) and (exists1 pt in set (trom.porttypes) & (exists1 p in set (elems (pt.portlist)) & ((p.label) = (tptuple.portlabel)))))), linked_subsystem' ((unresolved TROM`TromPortTuple) * set of ((unresolved TROM`Subsystem)) +> bool)	linked_subsystem(tptuple, subsystems) ==(exists1 s in set subsystems & (((linked_trom(tptuple, (s.troms)) and (not linked_subsystem(tptuple, (s.includes)))) or ((not linked_trom(tptuple, (s.troms))) and linked_subsystem(tptuple, (s.includes)))) and (forall s2 in set {su | [su'(unresolved TROM`Subsystem)] & ((su in set subsystems) and (su <> s))} & ((not linked_trom(tptuple, (s2.troms))) and (not linked_subsystem(tptuple, (s2.includes))))))) in (forall pl in set portlinks & (((linked_trom((pl.tromporttuple1), troms) and (not linked_subsystem((pl.tromporttuple1), includes))) or ((not linked_trom((pl.tromporttuple1), troms)) and linked_subsystem((pl.tromporttuple1), includes))) and ((linked_trom((pl.tromporttuple2), troms) and (not linked_subsystem((pl.tromporttuple2), includes))) or ((not linked_trom((pl.tromporttuple2), troms)) and linked_subsystem((pl.tromporttuple2), includes)))))))))state Systemof[SUBSYSTEM'(unresolved TROM`Subsystem), SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent)), LSLLIBRARY'set of ((unresolved TROM`LSLTraitDefinition)), CLOCK'nat]	inv mk_(unresolved TROM`System)(subsystem, simulationeventlist, lsllibrary, clock) == (let contains_trom' ((unresolved TROM`Subsystem) +> bool)	contains_trom(subsys) ==(((subsys.troms) <> {}) or (exists1 s in set (subsys.includes) & contains_trom(s))) in contains_trom(subsystem) and (let contains_portlink' ((unresolved TROM`Subsystem) +> bool)	contains_portlink(subsys) ==(((subsys.portlinks) <> {}) or (exists1 s in set (subsys.includes) & contains_portlink(s))) in contains_portlink(subsystem) and ((forall i, j in set (inds simulationeventlist) & (((i = j) and (simulationeventlist(i) = simulationeventlist(j))) or (((i < j) and ((simulationeventlist(i).occurtime) <= (simulationeventlist(j).occurtime))) or ((i > j) and ((simulationeventlist(i).occurtime) >= (simulationeventlist(j).occurtime)))))) and ((forall se1, se2 in set (elems simulationeventlist) & ((((se1.occurtime) = (se2.occurtime)) and ((se1.tromlabel) <> (se2.tromlabel))) or ((se1.occurtime) <> (se2.occurtime)))) and (let accepted_by_trom' ((unresolved TROM`SimulationEvent) * (unresolved TROM`Subsystem) +> bool)	accepted_by_trom(se, subsys) ==(exists1 trom in set (subsys.troms) & (((trom.label) = (se.tromlabel)) and (exists1 e in set (trom.events) & (((e.label) = (se.eventlabel)) and (exists1 pt in set (trom.porttypes) & ((pt = (e.porttype)) and (exists1 p in set (elems (pt.portlist)) & ((p.label) = (se.portlabel))))))))) in let accepted_by_subsystem' ((unresolved TROM`SimulationEvent) * (unresolved TROM`Subsystem) +> bool)	accepted_by_subsystem(se, subsys) ==(exists1 s in set (subsys.includes) & (((accepted_by_trom(se, s) and (not accepted_by_subsystem(se, s))) or ((not accepted_by_trom(se, s)) and accepted_by_subsystem(se, s))) and (forall s2 in set {su | [su'(unresolved TROM`Subsystem)] & ((su in set (subsys.includes)) and (su <> s))} & ((not accepted_by_trom(se, s2)) and (not accepted_by_subsystem(se, s2)))))) in (forall se in set (elems simulationeventlist) & ((accepted_by_trom(se, subsystem) and (not accepted_by_subsystem(se, subsystem))) or ((not accepted_by_trom(se, subsystem)) and accepted_by_subsystem(se, subsystem)))) and let exists_lsltrait' ((unresolved TROM`Subsystem) +> bool)	exists_lsltrait(subsys) ==((forall trom in set (subsys.troms) & (forall tr in set (trom.lsltraits) & (exists [traitdef in set lsllibrary] & ((traitdef.label) = (tr.traitlabel))))) and (forall s in set (subsys.includes) & exists_lsltrait(s))) in exists_lsltrait(subsystem))))))	init mk_(unresolved TROM`System)(subsys, simeventlist, lsllib, clock) == ((simeventlist <> []) and (clock = 0))private get_trom_object((tromlabel'(unresolved TROM`String)), (subsystem'(unresolved TROM`Subsystem)))trom'[(unresolved TROM`Trom)]	post (((trom in set (subsystem.troms)) and ((trom.label) = tromlabel)) or ((exists1 s in set (subsystem.includes) & (trom = get_trom_object(tromlabel, s))) or (trom = nil)))private get_transition_spec((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)))ts'[(unresolved TROM`TransitionSpec)]	pre ((trom.label) = (se.tromlabel))	post (((ts in set (trom.transitionspecs)) and (((((trom.currentstate).label) = ((ts.sourcestate).label)) or substate_of((trom.currentstate), (ts.sourcestate))) and ((((ts.triggerevent).label) = (se.eventlabel)) and (((ts.portcondition) = true) and ((ts.enabcondition) = true))))) or (ts = nil))substate_of' ((unresolved TROM`State) * (unresolved TROM`State) +> bool)	substate_of(substate, complexstate) ==((substate in set (complexstate.substates)) or (exists1 s in set (complexstate.substates) & (((s.type) = <COMPLEX>) and substate_of(substate, s))))	pre ((complexstate.type) = <COMPLEX>)private get_entry_state((complexstate'(unresolved TROM`State)))entry'(unresolved TROM`State)	pre ((complexstate.type) = <COMPLEX>)	post (exists1 s in set (complexstate.substates) & (((s.isinitial) = true) and ((((s.type) = <SIMPLE>) and (entry = s)) or (((s.type) = <COMPLEX>) and (entry = get_entry_state(s))))))private get_initial_state((trom'(unresolved TROM`Trom)))initial'(unresolved TROM`State)	pre ((trom.states) <> {})	post (exists1 s in set (trom.states) & (((s.isinitial) = true) and ((((s.type) = <SIMPLE>) and (initial = s)) or (((s.type) = <COMPLEX>) and (initial = get_entry_state(s))))))private get_linked_tromport_tuple((tupleA'(unresolved TROM`TromPortTuple)), (subsystem'(unresolved TROM`Subsystem)))tupleB'[(unresolved TROM`TromPortTuple)]	post ((exists1 pl in set (subsystem.portlinks) & ((((pl.tromporttuple1) = tupleA) and ((pl.tromporttuple2) = tupleB)) or (((pl.tromporttuple2) = tupleA) and ((pl.tromporttuple1) = tupleB)))) or ((exists1 s in set (subsystem.includes) & (tupleB = get_linked_tromport_tuple(tupleA, s))) or (tupleB = nil)))exists_in_subsystem' ((unresolved TROM`Trom) * (unresolved TROM`Subsystem) +> bool)	exists_in_subsystem(trom, subsys) ==((trom in set (subsys.troms)) or (exists1 subsystem in set (subsys.includes) & exists_in_subsystem(trom, subsystem)))	pre (((subsys.troms) <> {}) or ((subsys.includes) <> {}))private get_unconstrained_internal_event((trom'(unresolved TROM`Trom)))event'[(unresolved TROM`Event)]	post ((exists [ts in set (trom.transitionspecs)] & (((ts.sourcestate) = (trom.currentstate)) and ((((ts.triggerevent).type) = <INTERNAL>) and ((not constrained_event(trom, (ts.triggerevent))) and (event = (ts.triggerevent)))))) or (event = nil))constrained_event' ((unresolved TROM`Trom) * (unresolved TROM`Event) +> bool)	constrained_event(trom, event) ==(exists [tc in set (trom.timeconstraints)] & ((tc.constrainedevent) = event))	pre (event in set (trom.events))private get_simevent_index((se'(unresolved TROM`SimulationEvent)), (se_list'seq of ((unresolved TROM`SimulationEvent))))index'nat1	pre (se in set (elems se_list))	post (se_list(index) = se)private get_random_time_within_rw((rw'(unresolved TROM`ReactionWindow)))time'nat	post ((time >= (rw.lowertimebound)) and (time <= (rw.uppertimebound)))private get_lru_port((portlist'seq of ((unresolved TROM`Port))))port'(unresolved TROM`Port)	pre (portlist <> [])	post (port in set (elems portlist))simulator (() ==> ())	simulator() ==(i'nat1 '= 1initialize_simulation_clock();schedule_unconstrained_internal_events_from_initial_state();while (i <= (len SIMULATIONEVENTLIST)) do (while (CLOCK < (SIMULATIONEVENTLIST(i).occurtime)) do (update_simulation_clock());while ((i <= (len SIMULATIONEVENTLIST)) and (CLOCK = (SIMULATIONEVENTLIST(i).occurtime))) do (handle_event(SIMULATIONEVENTLIST(i));i '= (i + 1))))	pre ((SIMULATIONEVENTLIST <> []) and ((forall se in set (elems SIMULATIONEVENTLIST) & (((se.occurtime) >= CLOCK) and ((se.eventhistory) = nil))) and (forall trom in set {trom | [trom'(unresolved TROM`Trom)] & exists_in_subsystem(trom, SUBSYSTEM)} & (((trom.currentstate) = get_initial_state(trom)) and (forall tc in set (trom.timeconstraints) & ((tc.reactionwindows) = {}))))))	post ((SIMULATIONEVENTLIST <> []) and (((SIMULATIONEVENTLIST((len SIMULATIONEVENTLIST)).occurtime) = CLOCK) and ((forall se in set (elems SIMULATIONEVENTLIST) & (((se.occurtime) <= CLOCK) and ((se.eventhistory) <> nil))) and (forall trom in set {trom | [trom'(unresolved TROM`Trom)] & exists_in_subsystem(trom, SUBSYSTEM)} & (forall tc in set (trom.timeconstraints) & ((tc.reactionwindows) = {}))))))handle_event ((unresolved TROM`SimulationEvent) ==> ())	handle_event(se) ==(trom'[(unresolved TROM`Trom)] '= (undefined)ts'[(unresolved TROM`TransitionSpec)] '= (undefined)trom '= get_trom_object((se.tromlabel), SUBSYSTEM);if (trom = nil)thenreturnelseskip;ts '= get_transition_spec(trom, se);if (ts = nil)then(update_history_notransition(trom, se, ts))else(update_history_assignment_vector(trom, se, ts);if ((ts.postcondition) = false)then(update_history_notransition(trom, se, ts))else(update_history_transition(trom, se, ts);update_trom_current_state(trom, se, ts);handle_transition(trom, se, ts);schedule_unconstrained_internal_event(trom, se))))	pre ((se.occurtime) = CLOCK)	post (CLOCK = CLOCK~)handle_transition ((unresolved TROM`Trom) * (unresolved TROM`SimulationEvent) * (unresolved TROM`TransitionSpec) ==> ())	handle_transition(trom, se, ts) ==(for all tc in set (trom.timeconstraints) do(if (((tc.constrainedevent).label) = (se.eventlabel))then(for all rw in set (tc.reactionwindows) do(if (((se.occurtime) >= (rw.lowertimebound)) and ((se.occurtime) <= (rw.uppertimebound)))then(update_history_fire_reaction(trom, se, tc, rw);fire_reaction(trom, se, tc, rw))));if ((trom.currentstate) in set (tc.disablingstates))then(for all rw in set (tc.reactionwindows) do(update_history_disable_reaction(trom, se, tc, rw);disable_reaction(trom, se, tc, rw)));if ((ts.label) = ((tc.transition).label))then(update_history_enable_reaction(trom, se, tc, ts);enable_reaction(trom, se, tc, ts))))	pre ((se.occurtime) = CLOCK)	post (CLOCK = CLOCK~)update_trom_current_state((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (ts'(unresolved TROM`TransitionSpec)))	pre ((ts.postcondition) = true)	post (((((ts.destinstate).type) = <SIMPLE>) and ((trom.currentstate) = (ts.destinstate))) or ((((ts.destinstate).type) = <COMPLEX>) and ((trom.currentstate) = get_entry_state((ts.destinstate)))))update_history_assignment_vector((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (ts'[(unresolved TROM`TransitionSpec)]))	pre (ts <> nil)	post (((se.eventhistory).assignmentvector) = (trom.assignmentvector))update_history_notransition((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (ts'[(unresolved TROM`TransitionSpec)]))	pre ((ts = nil) or ((ts.postcondition) = false))	post ((((se.eventhistory).triggeredtransition) = false) and ((((se.eventhistory).tromcurrentstate) = nil) and ((((se.eventhistory).assignmentvector) = nil) and (((se.eventhistory).reactionshistory) = {}))))update_history_transition((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (ts'(unresolved TROM`TransitionSpec)))	pre ((ts.postcondition) = true)	post ((((se.eventhistory).triggeredtransition) = true) and ((((se.eventhistory).tromcurrentstate) = (trom.currentstate)) and ((((se.eventhistory).assignmentvector) = (trom.assignmentvector)) and (((se.eventhistory).reactionshistory) = {}))))update_history_fire_reaction((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (tc'(unresolved TROM`TimeConstraint)), (rw'(unresolved TROM`ReactionWindow)))	pre ((((tc.constrainedevent).label) = (se.eventlabel)) and ((rw in set (tc.reactionwindows)) and (((se.occurtime) >= (rw.lowertimebound)) and ((se.occurtime) <= (rw.uppertimebound)))))	post (exists [rh in set ((se.eventhistory).reactionshistory)] & (((rh.timeconstraint) = tc) and (((rh.reactionwindow) = rw) and ((rh.reaction) = <FIRED>))))update_history_disable_reaction((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (tc'(unresolved TROM`TimeConstraint)), (rw'(unresolved TROM`ReactionWindow)))	pre (((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows)))	post (exists [rh in set ((se.eventhistory).reactionshistory)] & (((rh.timeconstraint) = tc) and (((rh.reactionwindow) = rw) and ((rh.reaction) = <DISABLED>))))update_history_enable_reaction((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (tc'(unresolved TROM`TimeConstraint)), (ts'(unresolved TROM`TransitionSpec)))	ext [rd CLOCK'nat]	pre ((ts.label) = ((tc.transition).label))	post let rw'(unresolved TROM`ReactionWindow) be st (rw = mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in (exists [rh in set ((se.eventhistory).reactionshistory)] & (((rh.timeconstraint) = tc) and (((rh.reactionwindow) = rw) and ((rh.reaction) = <ENABLED>))))fire_reaction((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (tc'(unresolved TROM`TimeConstraint)), (rw'(unresolved TROM`ReactionWindow)))	pre ((((tc.constrainedevent).label) = (se.eventlabel)) and ((rw in set (tc.reactionwindows)) and (((se.occurtime) >= (rw.lowertimebound)) and ((se.occurtime) <= (rw.uppertimebound)))))	post (rw not in set (tc.reactionwindows))disable_reaction((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (tc'(unresolved TROM`TimeConstraint)), (rw'(unresolved TROM`ReactionWindow)))	ext [rd SUBSYSTEM'(unresolved TROM`Subsystem), wr SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent))]	pre (((trom.currentstate) in set (tc.disablingstates)) and (rw in set (tc.reactionwindows)))	post ((rw not in set (tc.reactionwindows)) and let se2'(unresolved TROM`SimulationEvent) be st (se2 = get_enabled_simevent(trom, tc)) in (((((tc.constrainedevent).type) = <INTERNAL>) and (SIMULATIONEVENTLIST = [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) & (SIMULATIONEVENTLIST~(i) <> se2)])) or ((((tc.constrainedevent).type) = <OUTPUT>) and let tromporttuple'[(unresolved TROM`TromPortTuple)] be st (tromporttuple = get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in let se3'(unresolved TROM`SimulationEvent) be st (se3 = get_enabled_simevent_synch(tromporttuple, tc)) in (SIMULATIONEVENTLIST = [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) & ((SIMULATIONEVENTLIST~(i) <> se2) and (SIMULATIONEVENTLIST~(i) <> se3))]))))enable_reaction((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)), (tc'(unresolved TROM`TimeConstraint)), (ts'(unresolved TROM`TransitionSpec)))	ext [rd CLOCK'nat, rd SUBSYSTEM'(unresolved TROM`Subsystem), wr SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent))]	pre ((ts.label) = ((tc.transition).label))	post let rw'(unresolved TROM`ReactionWindow) be st (rw = mk_ReactionWindow((((tc.timebounds).lowertimebound) + CLOCK), (((tc.timebounds).uppertimebound) + CLOCK))) in let port'(unresolved TROM`Port) be st (port = get_lru_port((((tc.constrainedevent).porttype).portlist))) in let occurtime'nat be st (occurtime = get_random_time_within_rw(rw)) in let se2'(unresolved TROM`SimulationEvent) be st (se2 = mk_SimulationEvent(((tc.constrainedevent).label), (trom.label), (port.label), occurtime, nil)) in ((rw in set (tc.reactionwindows)) and ((se2 in set (elems SIMULATIONEVENTLIST)) and (((((tc.constrainedevent).type) = <OUTPUT>) and let tromporttuple'[(unresolved TROM`TromPortTuple)] be st (tromporttuple = get_linked_tromport_tuple(mk_TromPortTuple((se2.tromlabel), (se2.portlabel)), SUBSYSTEM)) in (((tromporttuple <> nil) and let se3'(unresolved TROM`SimulationEvent) be st (se3 = mk_SimulationEvent((se2.eventlabel), (tromporttuple.tromlabel), (tromporttuple.portlabel), (se2.occurtime), nil)) in (se3 in set (elems SIMULATIONEVENTLIST))) or (tromporttuple = nil))) or (((tc.constrainedevent).type) = <INTERNAL>))))get_enabled_simevent((trom'(unresolved TROM`Trom)), (tc'(unresolved TROM`TimeConstraint))) se'(unresolved TROM`SimulationEvent)	ext [rd CLOCK'nat, rd SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent))]	pre (tc in set (trom.timeconstraints))	post ((se in set (elems SIMULATIONEVENTLIST)) and (((se.eventlabel) = ((tc.constrainedevent).label)) and (((se.tromlabel) = (trom.label)) and (((se.occurtime) >= CLOCK) and ((se.eventhistory) = nil)))))get_enabled_simevent_synch((tromporttuple'(unresolved TROM`TromPortTuple)), (tc'(unresolved TROM`TimeConstraint))) se'(unresolved TROM`SimulationEvent)	ext [rd CLOCK'nat, rd SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent))]	post ((se in set (elems SIMULATIONEVENTLIST)) and (((se.eventlabel) = ((tc.constrainedevent).label)) and (((se.tromlabel) = (tromporttuple.tromlabel)) and (((se.occurtime) >= CLOCK) and ((se.eventhistory) = nil)))))schedule_unconstrained_internal_events_from_initial_state()	ext [rd CLOCK'nat, rd SUBSYSTEM'(unresolved TROM`Subsystem), wr SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent))]	pre (CLOCK = 0)	post ((CLOCK = 0) and (forall trom in set {trom | [trom'(unresolved TROM`Trom)] & exists_in_subsystem(trom, SUBSYSTEM)} & let event'[(unresolved TROM`Event)] = get_unconstrained_internal_event(trom) in (((event <> nil) and let se'(unresolved TROM`SimulationEvent) be st (se = mk_SimulationEvent((event.label), (trom.label), "NULLPORT", CLOCK, nil)) in ((se in set (elems SIMULATIONEVENTLIST)) and let i'nat1 be st (SIMULATIONEVENTLIST(i) = se) in (forall se2 in set (elems SIMULATIONEVENTLIST~) & let j'nat1 be st (SIMULATIONEVENTLIST(j) = se2) in (i < j)))) or (event = nil))))schedule_unconstrained_internal_event((trom'(unresolved TROM`Trom)), (se'(unresolved TROM`SimulationEvent)))	ext [rd CLOCK'nat, wr SIMULATIONEVENTLIST'seq of ((unresolved TROM`SimulationEvent))]	pre ((se in set (elems SIMULATIONEVENTLIST)) and ((se.tromlabel) = (trom.label)))	post let event'[(unresolved TROM`Event)] = get_unconstrained_internal_event(trom) in (((event <> nil) and let j'nat1 be st (j = get_simevent_index(se, SIMULATIONEVENTLIST)) in let se2'(unresolved TROM`SimulationEvent) be st (se2 = mk_SimulationEvent((event.label), (trom.label), "NULLPORT", CLOCK, nil)) in (SIMULATIONEVENTLIST = (([SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) & (i <= j)] ^ [se2]) ^ [SIMULATIONEVENTLIST~(i) | i in set (inds SIMULATIONEVENTLIST~) & (i > j)]))) or (event = nil))initialize_simulation_clock()	ext [wr CLOCK'nat]	post (CLOCK = 0)update_simulation_clock()	ext [wr CLOCK'nat]	post (CLOCK = (CLOCK~ + 1))end TROM
