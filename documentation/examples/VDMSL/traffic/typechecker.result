WARNING:traffic.vdmsl:5008:86,39:conflicts at 24'3 hidden by conflicts.
WARNING:traffic.vdmsl:5008:79,37:conflicts at 24'3 hidden by conflicts.
WARNING:traffic.vdmsl:5008:73,28:p1 at 10'3 hidden by p1.
WARNING:traffic.vdmsl:5008:69,29:lights at 18'3 hidden by lights.
WARNING:traffic.vdmsl:5008:91,18:lights at 18'3 hidden by lights.
WARNING:traffic.vdmsl:5000:41,7:Definition 'Time' not used.
WARNING:traffic.vdmsl:5008:73,31:p2 at 12'3 hidden by p2.
WARNING:traffic.vdmsl:5008:79,27:lights at 18'3 hidden by lights.
WARNING:traffic.vdmsl:5008:86,29:lights at 18'3 hidden by lights.
WARNING:traffic.vdmsl:5008:69,39:conflicts at 24'3 hidden by conflicts.
RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private p1'Path = mk_token("A1North")static private p2'Path = mk_token("A1South")static private p3'Path = mk_token("A66East")static private p4'Path = mk_token("A66West")static private lights'map (Path) to (Light) = {p1 |-> <Red>, p2 |-> <Red>, p3 |-> <Green>, p4 |-> <Green>}static private conflicts'set of (Conflict) = {mk_Conflict(p1, p3), mk_Conflict(p1, p4), mk_Conflict(p2, p3), mk_Conflict(p2, p4), mk_Conflict(p3, p1), mk_Conflict(p4, p1), mk_Conflict(p3, p2), mk_Conflict(p4, p2)}static private kernel'Kernel = mk_Kernel(lights, conflicts)static private Light = (<Amber> | <Green> | <Red>)static private Time = real	inv t == (t >= 0)static private Path = tokenstatic private Conflict = compose Conflict of path1'Path, path2'Path end	inv mk_Conflict(path1, path2) == (path1 <> path2)static private Kernel = compose Kernel of lights'map (Path) to (Light), conflicts'set of (Conflict) end	inv mk_Kernel(ls, cs) == (forall c in set cs & ((mk_Conflict((c.path2), (c.path1)) in set cs) and (((c.path1) in set (dom ls)) and (((c.path2) in set (dom ls)) and ((ls((c.path1)) = <Red>) or (ls((c.path2)) = <Red>))))))ToGreen' (Path * Kernel -> Kernel)	ToGreen(p, mk_Kernel(lights, conflicts)) ==mk_Kernel(ChgLight(lights, p, <Green>), conflicts)	pre ((p in set (dom lights)) and ((lights(p) = <Red>) and (forall mk_Conflict(p1, p2) in set conflicts & ((p = p1) => (lights(p2) = <Red>)))))ToRed' (Path * Kernel -> Kernel)	ToRed(p, mk_Kernel(lights, conflicts)) ==mk_Kernel(ChgLight(lights, p, <Red>), conflicts)	pre ((p in set (dom lights)) and (lights(p) = <Amber>))ToAmber' (Path * Kernel -> Kernel)	ToAmber(p, mk_Kernel(lights, conflicts)) ==mk_Kernel(ChgLight(lights, p, <Amber>), conflicts)	pre ((p in set (dom lights)) and (lights(p) = <Green>))ChgLight' (map (Path) to (Light) * Path * Light -> map (Path) to (Light))	ChgLight(lights, p, colour) ==(lights ++ {p |-> colour})end DEFAULT
