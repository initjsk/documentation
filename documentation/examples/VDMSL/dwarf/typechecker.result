RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private LampId = (<L1> | <L2> | <L3>)static private darklamps'set of (LampId) = {}static private stoplamps'set of (LampId) = {<L1>, <L2>}static private warninglamps'set of (LampId) = {<L1>, <L3>}static private drivelamps'set of (LampId) = {<L2>, <L3>}static private Signal = set of (LampId)static private LogCom = (<dark> | <drive> | <stop> | <warning>)static private Message = (<port_failure> | <unknown> | LogCom)static private Errors = set of (LampId)Control ([LogCom] * set of (LampId) ==> (Message * Errors * Trace))	Control(com, failures) ==let private value newstate'Dwarf in ErrorCorrection(com, newstate, failures)	pre AllowedCommand(com, lampstate)static private AllowedCommand' ([LogCom] * Signal +> bool)	AllowedCommand(com, signal) ==(((com = <dark>) => (signal in set {stoplamps, darklamps})) and ((com in set {<warning>, <drive>}) => (signal <> darklamps)))static private Trace = seq of (set of (LampId))state Dwarfof[trace'Trace, lampstate'Signal]	inv mk_Dwarf(t, s) == (MaxOneLampChange(t) and (StopToDriveOrWarning(t) and (ToAndFromDark(t) and AlwaysDefinedState(s))))	init s == (s = mk_Dwarf([stoplamps], stoplamps))NormalTrans ([LogCom] ==> Dwarf)	NormalTrans(command) ==cases command '  case nil -> return (mk_Dwarf([], lampstate))  case <dark> -> let private value t'([] | seq1 of ((set of (<L1>) | set of (LampId)))) in return (mk_Dwarf(t, darklamps))  case <stop> -> let private value t'([] | seq1 of ((set of (<L1>) | set of (LampId))) | seq1 of ((set of (<L2>) | set of (LampId)))) in return (mk_Dwarf(t, stoplamps))  case <warning> -> let private value t'([] | seq1 of ((set of (<L1>) | set of (LampId))) | seq1 of ((set of (<L3>) | set of (LampId)))) in return (mk_Dwarf(t, warninglamps))  case <drive> -> let private value t'([] | seq1 of ((set of (<L2>) | set of (LampId))) | seq1 of ((set of (<L3>) | set of (LampId)))) in return (mk_Dwarf(t, drivelamps))  others -> erroresac	pre AllowedCommand(command, lampstate)ErrorCorrection ([LogCom] * Dwarf * set of (LampId) ==> (Message * Errors * Trace))	ErrorCorrection(com, dwarf, failures) ==if (failures = {<L2>})then(cases com '  case nil -> if (<L2> in set lampstate)thenlet private value errdwarf'Dwarf in NoCorrection(com, errdwarf, failures)elseNoCorrection(com, dwarf, failures)  case <dark> -> NoCorrection(com, dwarf, failures)  case <stop> -> let private value errdwarf'Dwarf in NoCorrection(com, errdwarf, failures)  case <warning> -> NoCorrection(com, dwarf, failures)  case <drive> -> let private value errdwarf'Dwarf in NoCorrection(com, errdwarf, failures)  others -> erroresac)else(NoCorrection(com, dwarf, failures))NoCorrection ([LogCom] * Dwarf * set of (LampId) ==> (Message * Errors * Trace))	NoCorrection(com, mk_Dwarf(newtr, newsignals), failures) ==(trace '= (trace ^ newtr);lampstate '= newsignals;let private value m'(<port_failure> | <unknown> | [LogCom]) in return (mk_(m, {}, newtr)))static private MaxOneLampChange' (Trace +> bool)	MaxOneLampChange(t) ==(forall i in set ((inds t) \ {1}) & (((card (t((i - 1)) \ t(i))) <= 1) and ((card (t(i) \ t((i - 1)))) <= 1)))static private StopToDriveOrWarning' (Trace +> bool)	StopToDriveOrWarning(t) ==(forall i, j in set (inds t) & (((i < j) and ((t(i) = stoplamps) and ((t(j) in set {drivelamps, warninglamps}) and (not (exists [k in set {(i + 1), ... ,(j - 1)}] & (t(k) in set {darklamps, warninglamps, drivelamps})))))) => (forall k in set {(i + 1), ... ,(j - 1)} & (((card t(k)) < 3) and ((card t(k)) > 0)))))static private ToAndFromDark' (Trace +> bool)	ToAndFromDark(t) ==(forall i in set (inds t) & ((t(i) = darklamps) => ToOrFromStop(t, i)))static private ToOrFromStop' (Trace * nat1 +> bool)	ToOrFromStop(t, i) ==(((i > 2) => (t((i - 2)) = stoplamps)) and (((i + 1) < (len t)) => (t((i + 2)) = stoplamps)))static private AlwaysDefinedState' (Signal +> bool)	AlwaysDefinedState(sig) ==(sig in set {darklamps, stoplamps, warninglamps, drivelamps})[SeqTest] = [[[[let com'LogCom in NormalTrans(com)]]{5}]]end DEFAULT
