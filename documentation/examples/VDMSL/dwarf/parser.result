RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private LampId = (<L1> | <L2> | <L3>)static private darklamps'set of ((unresolved DEFAULT`LampId)) = {}static private stoplamps'set of ((unresolved DEFAULT`LampId)) = {<L1>, <L2>}static private warninglamps'set of ((unresolved DEFAULT`LampId)) = {<L1>, <L3>}static private drivelamps'set of ((unresolved DEFAULT`LampId)) = {<L2>, <L3>}static private Signal = set of ((unresolved DEFAULT`LampId))static private LogCom = (<dark> | <drive> | <stop> | <warning>)static private Message = ((unresolved DEFAULT`LogCom) | <port_failure> | <unknown>)static private Errors = set of ((unresolved DEFAULT`LampId))Control ([(unresolved DEFAULT`LogCom)] * set of ((unresolved DEFAULT`LampId)) ==> ((unresolved DEFAULT`Message) * (unresolved DEFAULT`Errors) * (unresolved DEFAULT`Trace)))	Control(com, failures) ==let private value newstate'? in ErrorCorrection(com, newstate, failures)	pre AllowedCommand(com, lampstate)static private AllowedCommand' ([(unresolved DEFAULT`LogCom)] * (unresolved DEFAULT`Signal) +> bool)	AllowedCommand(com, signal) ==(((com = <dark>) => (signal in set {stoplamps, darklamps})) and ((com in set {<warning>, <drive>}) => (signal <> darklamps)))static private Trace = seq of (set of ((unresolved DEFAULT`LampId)))state Dwarfof[trace'(unresolved DEFAULT`Trace), lampstate'(unresolved DEFAULT`Signal)]	inv mk_(unresolved DEFAULT`Dwarf)(t, s) == (MaxOneLampChange(t) and (StopToDriveOrWarning(t) and (ToAndFromDark(t) and AlwaysDefinedState(s))))	init s == (s = mk_Dwarf([stoplamps], stoplamps))NormalTrans ([(unresolved DEFAULT`LogCom)] ==> (unresolved DEFAULT`Dwarf))	NormalTrans(command) ==cases command '  case nil -> return (mk_Dwarf([], lampstate))  case <dark> -> let private value t'? in return (mk_Dwarf(t, darklamps))  case <stop> -> let private value t'? in return (mk_Dwarf(t, stoplamps))  case <warning> -> let private value t'? in return (mk_Dwarf(t, warninglamps))  case <drive> -> let private value t'? in return (mk_Dwarf(t, drivelamps))  others -> erroresac	pre AllowedCommand(command, lampstate)ErrorCorrection ([(unresolved DEFAULT`LogCom)] * (unresolved DEFAULT`Dwarf) * set of ((unresolved DEFAULT`LampId)) ==> ((unresolved DEFAULT`Message) * (unresolved DEFAULT`Errors) * (unresolved DEFAULT`Trace)))	ErrorCorrection(com, dwarf, failures) ==if (failures = {<L2>})then(cases com '  case nil -> if (<L2> in set lampstate)thenlet private value errdwarf'? in NoCorrection(com, errdwarf, failures)elseNoCorrection(com, dwarf, failures)  case <dark> -> NoCorrection(com, dwarf, failures)  case <stop> -> let private value errdwarf'? in NoCorrection(com, errdwarf, failures)  case <warning> -> NoCorrection(com, dwarf, failures)  case <drive> -> let private value errdwarf'? in NoCorrection(com, errdwarf, failures)  others -> erroresac)else(NoCorrection(com, dwarf, failures))NoCorrection ([(unresolved DEFAULT`LogCom)] * (unresolved DEFAULT`Dwarf) * set of ((unresolved DEFAULT`LampId)) ==> ((unresolved DEFAULT`Message) * (unresolved DEFAULT`Errors) * (unresolved DEFAULT`Trace)))	NoCorrection(com, mk_(unresolved DEFAULT`Dwarf)(newtr, newsignals), failures) ==(trace '= (trace ^ newtr);lampstate '= newsignals;let private value m'? in return (mk_(m, {}, newtr)))static private MaxOneLampChange' ((unresolved DEFAULT`Trace) +> bool)	MaxOneLampChange(t) ==(forall i in set ((inds t) \ {1}) & (((card (t((i - 1)) \ t(i))) <= 1) and ((card (t(i) \ t((i - 1)))) <= 1)))static private StopToDriveOrWarning' ((unresolved DEFAULT`Trace) +> bool)	StopToDriveOrWarning(t) ==(forall i, j in set (inds t) & (((i < j) and ((t(i) = stoplamps) and ((t(j) in set {drivelamps, warninglamps}) and (not (exists [k in set {(i + 1), ... ,(j - 1)}] & (t(k) in set {darklamps, warninglamps, drivelamps})))))) => (forall k in set {(i + 1), ... ,(j - 1)} & (((card t(k)) < 3) and ((card t(k)) > 0)))))static private ToAndFromDark' ((unresolved DEFAULT`Trace) +> bool)	ToAndFromDark(t) ==(forall i in set (inds t) & ((t(i) = darklamps) => ToOrFromStop(t, i)))static private ToOrFromStop' ((unresolved DEFAULT`Trace) * nat1 +> bool)	ToOrFromStop(t, i) ==(((i > 2) => (t((i - 2)) = stoplamps)) and (((i + 1) < (len t)) => (t((i + 2)) = stoplamps)))static private AlwaysDefinedState' ((unresolved DEFAULT`Signal) +> bool)	AlwaysDefinedState(sig) ==(sig in set {darklamps, stoplamps, warninglamps, drivelamps})[SeqTest] = [[[[let com'(unresolved DEFAULT`LogCom) in NormalTrans(com)]]{5}]]end DEFAULT
