RESULT:result:-1:-1,-1:module relationsexportsexport alldefinitionsstatic private Node = nat1static private BinRel = set of (((nat1 * nat1)))static private A0'(unresolved relations`BinRel) = {}static private A1'(unresolved relations`BinRel) = {mk_(1, 2)}static private A2'(unresolved relations`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(3, 4)}static private A3'(unresolved relations`BinRel) = (A1 union {mk_(4, 5), mk_(4, 1), mk_(5, 6), mk_(6, 7), mk_(7, 8), mk_(8, 9), mk_(9, 10), mk_(2, 3)})static private A4'(unresolved relations`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 5), mk_(5, 6)}static private A5'(unresolved relations`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7)}static private A6'(unresolved relations`BinRel) = {mk_(1, 1), mk_(2, 2), mk_(3, 3), mk_(4, 4), mk_(5, 5)}static private A7'(unresolved relations`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7), mk_(5, 2)}static private A8'(unresolved relations`BinRel) = (A7 union {mk_(6, 1)})IsReflexive' ((unresolved relations`BinRel) -> bool)	IsReflexive(R) ==(forall x in set field(R) & (mk_(x, x) in set R))IsSymmetrical' ((unresolved relations`BinRel) -> bool)	IsSymmetrical(R) ==(forall x, y in set field(R) & ((mk_(x, y) in set R) => (mk_(y, x) in set R)))IsTransitive' ((unresolved relations`BinRel) -> bool)	IsTransitive(R) ==(forall x, y, z in set field(R) & (((mk_(x, y) in set R) and (mk_(y, z) in set R)) => (mk_(x, z) in set R)))IsEquivalence' ((unresolved relations`BinRel) -> bool)	IsEquivalence(R) ==(IsReflexive(R) and (IsSymmetrical(R) and IsTransitive(R)))domain' ((unresolved relations`BinRel) -> set of (nat1))	domain(R) =={x | [mk_(x, -) in set R]}domain1' ((unresolved relations`BinRel) -> set of (nat1))	domain1(R) =={x | [x'nat1] & (exists [y'nat1] & (mk_(x, y) in set R))}range' ((unresolved relations`BinRel) -> set of (nat1))	range(R) =={y | [mk_(-, y) in set R]}field' ((unresolved relations`BinRel) -> set of (nat1))	field(R) ==(domain(R) union range(R))inverse_rel' ((unresolved relations`BinRel) -> (unresolved relations`BinRel))	inverse_rel(R) =={mk_(y, x) | [mk_(x, y) in set R]}id_rel' ((unresolved relations`BinRel) -> (unresolved relations`BinRel))	id_rel(R) =={mk_(x, x) | [x in set field(R)]}Composition' ((unresolved relations`BinRel) * (unresolved relations`BinRel) -> (unresolved relations`BinRel))	Composition(R, Q) =={mk_(a, c) | [mk_(a, b1) in set R, mk_(b2, c) in set Q] & (b1 = b2)}power_of' ((unresolved relations`BinRel) * nat1 -> (unresolved relations`BinRel))	power_of(R, x) ==(if (x = 1)then Relse Composition(R, power_of(R, (x - 1))))	pre (x > 0)Power_rel' ((unresolved relations`BinRel) * nat -> (unresolved relations`BinRel))	Power_rel(R, k) ==(if (k = 0)then id_rel(R)elseif (k = 1)then Relse Composition(R, Power_rel(R, (k - 1))))Reflexive_cl' ((unresolved relations`BinRel) -> (unresolved relations`BinRel))	Reflexive_cl(R) ==(R union id_rel(R))Symmetric_cl' ((unresolved relations`BinRel) -> (unresolved relations`BinRel))	Symmetric_cl(R) ==(R union inverse_rel(R))Transitive_cl' ((unresolved relations`BinRel) -> (unresolved relations`BinRel))	Transitive_cl(R) ==(dunion {Power_rel(R, k) | [k in set {1, ... ,(card field(R))}]})TransitiveRefl_cl' ((unresolved relations`BinRel) -> (unresolved relations`BinRel))	TransitiveRefl_cl(R) ==(dunion {Power_rel(R, k) | [k in set {0, ... ,(card field(R))}]})PowerList' ((unresolved relations`BinRel) -> seq of ((unresolved relations`BinRel)))	PowerList(R) ==BuildList(R, (card field(R)))	pre (R <> {})BuildList' ((unresolved relations`BinRel) * nat1 -> seq of ((unresolved relations`BinRel)))	BuildList(R, n) ==(if (n = 1)then [R]else let M = BuildList(R, (n - 1)), C = Composition(M((len M)), R) in (if (C = {})then Melse (M ^ [C])))	pre (n > 0)max_set' (set of (int) -> int)	max_set(S) ==let x in set S in (if ((card S) = 1)then xelse max2(x, max_set((S \ {x}))))	pre (S <> {})max2' (int * int -> int)	max2(a, b) ==(if (a >= b)then aelse b)Warshall ((unresolved relations`BinRel) ==> (unresolved relations`BinRel))	Warshall(Q) ==(i'nat1 '= (undefined)j'nat1 '= (undefined)k'nat1 '= (undefined)R'(unresolved relations`BinRel) '= (undefined)R '= Q;let private value n'? in for k = 1 to nfor i = 1 to nfor j = 1 to nif (mk_(i, j) not in set R)thenif ((mk_(i, k) in set R) and (mk_(k, j) in set R))thenR '= (R union {mk_(i, j)});return (R))test_PowerList' ((unresolved relations`BinRel) -> bool)	test_PowerList(R) ==let L = PowerList(R), n = (card field(R)) in (((forall i in set (inds L) & (L(i) = Power_rel(R, i))) and ((len L) < n)) => (Power_rel(R, ((len L) + 1)) = {}))end relations, module flowgraph_typesimportsfrom relationsimport allexportsexport alldefinitionsstatic private Node = nat1static private Nodes = set of ((unresolved flowgraph_types`Node))static private GraphNodes = set of ((unresolved flowgraph_types`Node))	inv N == (((card N) > 0) and (N = {1, ... ,(card N)}))static private Arc = ((unresolved flowgraph_types`Node) * (unresolved flowgraph_types`Node))static private BinRel = (unresolved relations`BinRel)static private Variable = tokenstatic private Vars = set of ((unresolved flowgraph_types`Variable))static private Varmap = seq of ((unresolved flowgraph_types`Vars))static private Path = seq of ((unresolved flowgraph_types`Node))static private Paths = set of ((unresolved flowgraph_types`Path))static private FlowGraph = compose FlowGraph of N'(unresolved flowgraph_types`Nodes), A'(unresolved flowgraph_types`BinRel), S'(unresolved flowgraph_types`Node), E'(unresolved flowgraph_types`Node) end	inv G == ((relations`field((G.A)) subset (G.N)) and (((G.S) in set (G.N)) and ((G.E) in set (G.N))))static private ExtendedFlowGraph = compose ExtendedFlowGraph of G'(unresolved flowgraph_types`FlowGraph), U'(unresolved flowgraph_types`Varmap), D'(unresolved flowgraph_types`Varmap) end	inv mk_(unresolved flowgraph_types`ExtendedFlowGraph)(G, U, D) == (((len U) = (card (G.N))) and ((len D) = (card (G.N))))static private N1'(unresolved flowgraph_types`Nodes) = {1, ... ,4}static private N2'(unresolved flowgraph_types`Nodes) = {1, ... ,10}static private N3'(unresolved flowgraph_types`Nodes) = {1}static private A0'(unresolved flowgraph_types`BinRel) = {}static private A1'(unresolved flowgraph_types`BinRel) = {mk_(1, 2)}static private A2'(unresolved flowgraph_types`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(3, 4)}static private A3'(unresolved flowgraph_types`BinRel) = (A1 union {mk_(4, 5), mk_(4, 1), mk_(5, 6), mk_(6, 7), mk_(7, 8), mk_(8, 9), mk_(9, 10)})static private A4'(unresolved flowgraph_types`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 5), mk_(5, 6)}static private A5'(unresolved flowgraph_types`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7)}static private A6'(unresolved flowgraph_types`BinRel) = {mk_(1, 1), mk_(2, 2), mk_(3, 3), mk_(4, 4), mk_(5, 5)}static private A7'(unresolved flowgraph_types`BinRel) = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7), mk_(5, 2)}static private A8'(unresolved flowgraph_types`BinRel) = (A7 union {mk_(6, 1)})static private G1'(unresolved flowgraph_types`FlowGraph) = mk_FlowGraph(N1, A1, 1, 4)static private G2'(unresolved flowgraph_types`FlowGraph) = mk_FlowGraph(N1, A2, 1, 4)static private G3'(unresolved flowgraph_types`FlowGraph) = mk_FlowGraph(N2, A3, 1, 6)static private G5'(unresolved flowgraph_types`FlowGraph) = mk_FlowGraph(N2, A5, 1, 7)static private G6'(unresolved flowgraph_types`FlowGraph) = mk_FlowGraph(N2, A6, 1, 5)state STof[G'(unresolved flowgraph_types`FlowGraph)]	init x == (x = mk_ST(mk_FlowGraph({1, 2}, {}, 1, 2)))end flowgraph_types, module digraphimportsfrom flowgraph_typesimport allfrom relationsimport allexportsexport alldefinitionsstatic private Node = (unresolved flowgraph_types`Node)static private Flowgraph = (unresolved flowgraph_types`FlowGraph)succ' ((unresolved digraph`Flowgraph) * (unresolved digraph`Node) -> set of ((unresolved digraph`Node)))	succ(G, n) =={k | [k in set (G.N)] & (mk_(n, k) in set (G.A))}pred' ((unresolved digraph`Flowgraph) * (unresolved digraph`Node) -> set of ((unresolved digraph`Node)))	pred(G, n) =={k | [k in set (G.N)] & (mk_(k, n) in set (G.A))}existspath' ((unresolved digraph`Flowgraph) * (unresolved digraph`Node) * (unresolved digraph`Node) -> bool)	existspath(MFG, n1, n2) ==(mk_(n1, n2) in set relations`Warshall((MFG.A)))end digraph
