WARNING:Relations.vdmsl:5012:101,10:Recursive function has no measure.
WARNING:Relations.vdmsl:5012:149,11:Recursive function has no measure.
WARNING:Relations.vdmsl:5008:199,12:j at 192'16 hidden by j.
WARNING:Relations.vdmsl:5008:197,9:k at 192'25 hidden by k.
WARNING:Relations.vdmsl:5012:108,11:Recursive function has no measure.
WARNING:Relations.vdmsl:5008:198,11:i at 192'7 hidden by i.
WARNING:Relations.vdmsl:5012:169,9:Recursive function has no measure.
RESULT:result:-1:-1,-1:module digraphimportsfrom flowgraph_typesimport allfrom relationsimport allexportsexport alldefinitionsstatic private Node = Nodestatic private Flowgraph = FlowGraphsucc' (Flowgraph * Node -> set of (Node))	succ(G, n) =={k | [k in set (G.N)] & (mk_(n, k) in set (G.A))}pred' (Flowgraph * Node -> set of (Node))	pred(G, n) =={k | [k in set (G.N)] & (mk_(k, n) in set (G.A))}existspath' (Flowgraph * Node * Node -> bool)	existspath(MFG, n1, n2) ==(mk_(n1, n2) in set relations`Warshall((MFG.A)))end digraph, module relationsexportsexport alldefinitionsstatic private Node = nat1static private BinRel = set of ((nat1 * nat1))static private A0'BinRel = {}static private A1'BinRel = {mk_(1, 2)}static private A2'BinRel = {mk_(1, 2), mk_(2, 3), mk_(3, 4)}static private A3'BinRel = (A1 union {mk_(4, 5), mk_(4, 1), mk_(5, 6), mk_(6, 7), mk_(7, 8), mk_(8, 9), mk_(9, 10), mk_(2, 3)})static private A4'BinRel = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 5), mk_(5, 6)}static private A5'BinRel = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7)}static private A6'BinRel = {mk_(1, 1), mk_(2, 2), mk_(3, 3), mk_(4, 4), mk_(5, 5)}static private A7'BinRel = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7), mk_(5, 2)}static private A8'BinRel = (A7 union {mk_(6, 1)})IsReflexive' (BinRel -> bool)	IsReflexive(R) ==(forall x in set field(R) & (mk_(x, x) in set R))IsSymmetrical' (BinRel -> bool)	IsSymmetrical(R) ==(forall x, y in set field(R) & ((mk_(x, y) in set R) => (mk_(y, x) in set R)))IsTransitive' (BinRel -> bool)	IsTransitive(R) ==(forall x, y, z in set field(R) & (((mk_(x, y) in set R) and (mk_(y, z) in set R)) => (mk_(x, z) in set R)))IsEquivalence' (BinRel -> bool)	IsEquivalence(R) ==(IsReflexive(R) and (IsSymmetrical(R) and IsTransitive(R)))domain' (BinRel -> set of (nat1))	domain(R) =={x | [mk_(x, -) in set R]}domain1' (BinRel -> set of (nat1))	domain1(R) =={x | [x'nat1] & (exists [y'nat1] & (mk_(x, y) in set R))}range' (BinRel -> set of (nat1))	range(R) =={y | [mk_(-, y) in set R]}field' (BinRel -> set of (nat1))	field(R) ==(domain(R) union range(R))inverse_rel' (BinRel -> BinRel)	inverse_rel(R) =={mk_(y, x) | [mk_(x, y) in set R]}id_rel' (BinRel -> BinRel)	id_rel(R) =={mk_(x, x) | [x in set field(R)]}Composition' (BinRel * BinRel -> BinRel)	Composition(R, Q) =={mk_(a, c) | [mk_(a, b1) in set R, mk_(b2, c) in set Q] & (b1 = b2)}power_of' (BinRel * nat1 -> BinRel)	power_of(R, x) ==(if (x = 1)then Relse Composition(R, power_of(R, (x - 1))))	pre (x > 0)Power_rel' (BinRel * nat -> BinRel)	Power_rel(R, k) ==(if (k = 0)then id_rel(R)elseif (k = 1)then Relse Composition(R, Power_rel(R, (k - 1))))Reflexive_cl' (BinRel -> BinRel)	Reflexive_cl(R) ==(R union id_rel(R))Symmetric_cl' (BinRel -> BinRel)	Symmetric_cl(R) ==(R union inverse_rel(R))Transitive_cl' (BinRel -> BinRel)	Transitive_cl(R) ==(dunion {Power_rel(R, k) | [k in set {1, ... ,(card field(R))}]})TransitiveRefl_cl' (BinRel -> BinRel)	TransitiveRefl_cl(R) ==(dunion {Power_rel(R, k) | [k in set {0, ... ,(card field(R))}]})PowerList' (BinRel -> seq of (BinRel))	PowerList(R) ==BuildList(R, (card field(R)))	pre (R <> {})BuildList' (BinRel * nat1 -> seq of (BinRel))	BuildList(R, n) ==(if (n = 1)then [R]else let M'seq of (BinRel) = BuildList(R, (n - 1)), C'BinRel = Composition(M((len M)), R) in (if (C = {})then Melse (M ^ [C])))	pre (n > 0)max_set' (set of (int) -> int)	max_set(S) ==let x in set S in (if ((card S) = 1)then xelse max2(x, max_set((S \ {x}))))	pre (S <> {})max2' (int * int -> int)	max2(a, b) ==(if (a >= b)then aelse b)Warshall (BinRel ==> BinRel)	Warshall(Q) ==(i'nat1 '= (undefined)j'nat1 '= (undefined)k'nat1 '= (undefined)R'BinRel '= (undefined)R '= Q;let private value n'int in for k = 1 to nfor i = 1 to nfor j = 1 to nif (mk_(i, j) not in set R)thenif ((mk_(i, k) in set R) and (mk_(k, j) in set R))thenR '= (R union {mk_(i, j)});return (R))test_PowerList' (BinRel -> bool)	test_PowerList(R) ==let L'seq of (BinRel) = PowerList(R), n'nat = (card field(R)) in (((forall i in set (inds L) & (L(i) = Power_rel(R, i))) and ((len L) < n)) => (Power_rel(R, ((len L) + 1)) = {}))end relations, module flowgraph_typesimportsfrom relationsimport allexportsexport alldefinitionsstatic private Node = nat1static private Nodes = set of (Node)static private GraphNodes = set of (Node)	inv N == (((card N) > 0) and (N = {1, ... ,(card N)}))static private Arc = (Node * Node)static private BinRel = BinRelstatic private Variable = tokenstatic private Vars = set of (Variable)static private Varmap = seq of (Vars)static private Path = seq of (Node)static private Paths = set of (Path)static private FlowGraph = compose FlowGraph of N'Nodes, A'BinRel, S'Node, E'Node end	inv G == ((relations`field((G.A)) subset (G.N)) and (((G.S) in set (G.N)) and ((G.E) in set (G.N))))static private ExtendedFlowGraph = compose ExtendedFlowGraph of G'FlowGraph, U'Varmap, D'Varmap end	inv mk_ExtendedFlowGraph(G, U, D) == (((len U) = (card (G.N))) and ((len D) = (card (G.N))))static private N1'Nodes = {1, ... ,4}static private N2'Nodes = {1, ... ,10}static private N3'Nodes = {1}static private A0'BinRel = {}static private A1'BinRel = {mk_(1, 2)}static private A2'BinRel = {mk_(1, 2), mk_(2, 3), mk_(3, 4)}static private A3'BinRel = (A1 union {mk_(4, 5), mk_(4, 1), mk_(5, 6), mk_(6, 7), mk_(7, 8), mk_(8, 9), mk_(9, 10)})static private A4'BinRel = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 5), mk_(5, 6)}static private A5'BinRel = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7)}static private A6'BinRel = {mk_(1, 1), mk_(2, 2), mk_(3, 3), mk_(4, 4), mk_(5, 5)}static private A7'BinRel = {mk_(1, 2), mk_(2, 3), mk_(2, 4), mk_(3, 5), mk_(4, 6), mk_(6, 5), mk_(5, 7), mk_(5, 2)}static private A8'BinRel = (A7 union {mk_(6, 1)})static private G1'FlowGraph = mk_FlowGraph(N1, A1, 1, 4)static private G2'FlowGraph = mk_FlowGraph(N1, A2, 1, 4)static private G3'FlowGraph = mk_FlowGraph(N2, A3, 1, 6)static private G5'FlowGraph = mk_FlowGraph(N2, A5, 1, 7)static private G6'FlowGraph = mk_FlowGraph(N2, A6, 1, 5)state STof[G'FlowGraph]	init x == (x = mk_ST(mk_FlowGraph({1, 2}, {}, 1, 2)))end flowgraph_types
