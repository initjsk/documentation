RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Graph = map ((unresolved DEFAULT`Id)) to (set of ((unresolved DEFAULT`Id)))	inv g == ((dunion (rng g)) subset (dom g))static private ASyncGraph = (unresolved DEFAULT`Graph)	inv asyncg == (forall id in set (dom asyncg) & (id not in set TransClos(asyncg, id)))static private Path = seq of ((unresolved DEFAULT`Id))static private Id = natPaths' ((unresolved DEFAULT`ASyncGraph) * (unresolved DEFAULT`Id) -> set of ((unresolved DEFAULT`Path)))	Paths(g, id) ==let children = g(id) in (if (children = {})then {[id]}else (dunion {{([id] ^ p) | [p in set Paths(g, c)]} | [c in set children]}))	pre (id in set (dom g))measureTransClos' ((unresolved DEFAULT`ASyncGraph) * (unresolved DEFAULT`Id) -> nat)	measureTransClos(g, id) ==(card TransClos(g, id))LinearPath' ((unresolved DEFAULT`Graph) * (unresolved DEFAULT`Id) -> (unresolved DEFAULT`Path))	LinearPath(g, id) ==let children = g(id) in (if (((card children) <> 1) or (exists [parent in set (dom g)] & ((parent <> id) and (children subset g(parent)))))then [id]else let child in set children in ([id] ^ LinearPath(g, child)))	pre ((id in set (dom g)) and (id not in set TransClos(g, id)))TransClos' ((unresolved DEFAULT`Graph) * (unresolved DEFAULT`Id) -> set of ((unresolved DEFAULT`Id)))	TransClos(g, id) ==(dunion {TransClosAux(g, c, {}) | [c in set g(id)]})	pre (id in set (dom g))TransClosAux' ((unresolved DEFAULT`Graph) * (unresolved DEFAULT`Id) * set of ((unresolved DEFAULT`Id)) -> set of ((unresolved DEFAULT`Id)))	TransClosAux(g, id, reached) ==(if (id in set reached)then {}else ({id} union (dunion {TransClosAux(g, c, (reached union {id})) | [c in set g(id)]})))	pre (id in set (dom g))measureGraphReached' ((unresolved DEFAULT`Graph) * (unresolved DEFAULT`Id) * set of ((unresolved DEFAULT`Id)) -> nat)	measureGraphReached(g, -, reached) ==((card (dom g)) - (card reached))AsycDescendents' ((unresolved DEFAULT`AcyclicGraph) * (unresolved DEFAULT`Id) -> set of ((unresolved DEFAULT`Id)))	AsycDescendents(g, id) ==({id} union (dunion {AsycDescendents(g, c) | [c in set g(id)]}))	pre (id in set (dom g))Descendents' ((unresolved DEFAULT`Graph) * (unresolved DEFAULT`Id) * set of ((unresolved DEFAULT`Id)) -> set of ((unresolved DEFAULT`Id)))	Descendents(g, id, reached) ==(if (id in set reached)then {}else ({id} union (dunion {Descendents(g, c, (reached union {id})) | [c in set g(id)]})))	pre (id in set (dom g))AllDesc' ((unresolved DEFAULT`Graph) * (unresolved DEFAULT`Id) -> set of ((unresolved DEFAULT`Id)))	AllDesc(g, id) ==(dunion {TransClosAux(g, c, {}) | [c in set g(id)]})	pre (id in set (dom g))static private AcyclicGraph = (unresolved DEFAULT`Graph)	inv acg == (not (exists [id in set (dom acg)] & (id in set AllDesc(acg, id))))static private graph'(unresolved DEFAULT`Graph) = {1 |-> {2, 3}, 2 |-> {4}, 3 |-> {5}, 4 |-> {6}, 5 |-> {6}, 6 |-> {}}end DEFAULT, module DEFAULTexports alldefinitionsstatic private LabGraph = map ((unresolved DEFAULT`NodeId)) to ((map ((unresolved DEFAULT`ArcId)) to ((unresolved DEFAULT`NodeId))))	inv g == (UniqueArcIds(g) and (forall m in set (rng g) & ((rng m) subset (dom g))))static private AcyclicLabGraph = (unresolved DEFAULT`LabGraph)	inv acg == (not (exists [id in set (dom acg)] & (id in set AllLabDesc(acg, id))))static private NodeId = natstatic private ArcId = natAllLabDesc' ((unresolved DEFAULT`LabGraph) * (unresolved DEFAULT`NodeId) -> set of ((unresolved DEFAULT`NodeId)))	AllLabDesc(g, id) ==(dunion {LabDescendents(g, c, {}) | [c in set (rng g(id))]})	pre (id in set (dom g))measureLabGraphReached' ((unresolved DEFAULT`LabGraph) * (unresolved DEFAULT`Id) * set of ((unresolved DEFAULT`Id)) -> nat)	measureLabGraphReached(g, -, reached) ==((card (dom g)) - (card reached))LabDescendents' ((unresolved DEFAULT`LabGraph) * (unresolved DEFAULT`NodeId) * set of ((unresolved DEFAULT`NodeId)) -> set of ((unresolved DEFAULT`NodeId)))	LabDescendents(g, id, reached) ==(if (id in set reached)then {}else ({id} union (dunion {LabDescendents(g, c, (reached union {id})) | [c in set (rng g(id))]})))	pre (id in set (dom g))UniqueArcIds' (map ((unresolved DEFAULT`NodeId)) to ((map ((unresolved DEFAULT`ArcId)) to ((unresolved DEFAULT`NodeId)))) -> bool)	UniqueArcIds(g) ==let m = {nid |-> (dom g(nid)) | nid in set (dom g)} in (forall nid1, nid2 in set (dom m) & ((nid1 <> nid2) => ((m(nid1) inter m(nid2)) = {})))static private lgraph'(unresolved DEFAULT`LabGraph) = {1 |-> {1 |-> 2, 2 |-> 3}, 2 |-> {3 |-> 4}, 3 |-> {4 |-> 5}, 4 |-> {5 |-> 6}, 5 |-> {6 |-> 6}, 6 |-> {}}end DEFAULT
