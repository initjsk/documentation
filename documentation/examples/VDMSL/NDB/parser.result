RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Eid = tokenstatic private Value = tokenstatic private Esetnm = tokenstatic private Rnm = tokenstatic private Maptp = (<MANYTOMANY> | <MANYTOONE> | <ONETOMANY> | <ONETOONE>)static private Tuple = compose Tuple of fv'(unresolved DEFAULT`Eid), tv'(unresolved DEFAULT`Eid) endstatic private Rinf = compose Rinf of tp'(unresolved DEFAULT`Maptp), r'set of ((unresolved DEFAULT`Tuple)) endstatic private Rkey = compose Rkey of nm'[(unresolved DEFAULT`Rnm)], fs'(unresolved DEFAULT`Esetnm), ts'(unresolved DEFAULT`Esetnm) endcheckinv' (map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))) * map ((unresolved DEFAULT`Eid)) to ([(unresolved DEFAULT`Value)]) * map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf)) -> bool)	checkinv(esm, em, rm) ==(((dom em) = (dunion (rng esm))) and (forall rk in set (dom rm) & let mk_(unresolved DEFAULT`Rkey)(-, fs, ts) = rk in let mk_(unresolved DEFAULT`Rinf)(tp, r) = rm(rk) in (({fs, ts} subset (dom esm)) and (((tp = <ONETOMANY>) => (forall t1, t2 in set r & (((t1.tv) = (t2.tv)) => ((t1.fv) = (t2.fv))))) and (((tp = <MANYTOONE>) => (forall t1, t2 in set r & (((t1.fv) = (t2.fv)) => ((t1.tv) = (t2.tv))))) and (((tp = <ONETOONE>) => (forall t1, t2 in set r & (((t1.fv) = (t2.fv)) <=> ((t1.tv) = (t2.tv))))) and (forall mk_(unresolved DEFAULT`Tuple)(fv, tv) in set r & ((fv in set esm(fs)) and (tv in set esm(ts))))))))))state Ndbof[esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))), em'map ((unresolved DEFAULT`Eid)) to ([(unresolved DEFAULT`Value)]), rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf))]	inv mk_(unresolved DEFAULT`Ndb)(esm, em, rm) == checkinv(esm, em, rm)	init ndb == (ndb = mk_Ndb({}, {}, {}))ADDES((es'(unresolved DEFAULT`Esetnm)))	ext [wr esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid)))]	pre (es not in set (dom esm))	post (esm = (esm~ munion {es |-> {}}))DELES((es'(unresolved DEFAULT`Esetnm)))	ext [wr esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))), rd rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf))]	pre ((es in set (dom esm)) and ((esm(es) = {}) and (es not in set ({(rk.fs) | [rk in set (dom rm)]} union {(rk.ts) | [rk in set (dom rm)]}))))	post (esm = ({es} <-' esm~))ADDENT((memb'set of ((unresolved DEFAULT`Esetnm))), (val'[(unresolved DEFAULT`Value)])) eid'(unresolved DEFAULT`Eid)	ext [wr esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))), wr em'map ((unresolved DEFAULT`Eid)) to ([(unresolved DEFAULT`Value)])]	pre (memb subset (dom esm))	post ((eid not in set (dom em~)) and ((em = (em~ munion {eid |-> val})) and (esm = (esm~ ++ {es |-> (esm~(es) union {eid}) | es in set memb}))))DELENT((eid'(unresolved DEFAULT`Eid)))	ext [wr esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))), wr em'map ((unresolved DEFAULT`Eid)) to ([(unresolved DEFAULT`Value)]), rd rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf))]	pre ((eid in set (dom em)) and (forall t in set (dunion {(ri.r) | [ri in set (rng rm)]}) & (((t.fv) <> eid) and ((t.tv) <> eid))))	post ((esm = {es |-> (esm~(es) \ {eid}) | es in set (dom esm~)}) and (em = ({eid} <-' em~)))ADDREL((rk'(unresolved DEFAULT`Rkey)), (tp'(unresolved DEFAULT`Maptp)))	ext [rd esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))), wr rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf))]	pre (({(rk.fs), (rk.ts)} subset (dom esm)) and (rk not in set (dom rm)))	post (rm = (rm~ munion {rk |-> mk_Rinf(tp, {})}))DELREL((rk'(unresolved DEFAULT`Rkey)))	ext [wr rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf))]	pre ((rk in set (dom rm)) and ((rm(rk).r) = {}))	post (rm = ({rk} <-' rm~))ADDTUP((fval, tval'(unresolved DEFAULT`Eid)), (rk'(unresolved DEFAULT`Rkey)))	ext [wr rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf)), rd esm'map ((unresolved DEFAULT`Esetnm)) to (set of ((unresolved DEFAULT`Eid))), rd em'map ((unresolved DEFAULT`Eid)) to ([(unresolved DEFAULT`Value)])]	pre ((rk in set (dom rm)) and let ri = mu(rm(rk), r |-> ((rm(rk).r) union {mk_Tuple(fval, tval)})) in checkinv(esm, em, (rm ++ {rk |-> ri})))	post let ri = mu(rm~(rk), r |-> ((rm~(rk).r) union {mk_Tuple(fval, tval)})) in (rm = (rm~ ++ {rk |-> ri}))DELTUP((fval, tval'(unresolved DEFAULT`Eid)), (rk'(unresolved DEFAULT`Rkey)))	ext [wr rm'map ((unresolved DEFAULT`Rkey)) to ((unresolved DEFAULT`Rinf))]	pre (rk in set (dom rm))	post let ri = mu(rm~(rk), r |-> ((rm~(rk).r) \ {mk_Tuple(fval, tval)})) in (rm = (rm~ ++ {rk |-> ri}))end DEFAULT
