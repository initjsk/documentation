RESULT:result:-1:-1,-1:module DEFAULTexports alldefinitionsstatic private Literal = seq of (token)static private State = set of ((unresolved DEFAULT`Literal))static private Goal = set of ((unresolved DEFAULT`Literal))static private Action = compose Action of name'(unresolved DEFAULT`Literal), pra'set of ((unresolved DEFAULT`Literal)), add'set of ((unresolved DEFAULT`Literal)), del'set of ((unresolved DEFAULT`Literal)) endstatic private Planning_Problem = compose Planning_Problem of AS'set of ((unresolved DEFAULT`Action)), I'(unresolved DEFAULT`State), G'(unresolved DEFAULT`Goal) end	inv mk_(unresolved DEFAULT`Planning_Problem)(AS, I, G) == (forall l in set G & (((l in set I) or (exists [A in set AS] & (l in set (A.add)))) and ((not (G subset I)) and (forall A in set AS & (not (exists [p'(unresolved DEFAULT`Literal)] & ((p in set (A.add)) and (p in set (A.del)))))))))static private Action_id = tokenstatic private Action_instances = map ((unresolved DEFAULT`Action_id)) to ((unresolved DEFAULT`Action))static private Arc = compose Arc of source'(unresolved DEFAULT`Action_id), dest'(unresolved DEFAULT`Action_id) endstatic private Bounded_Poset = set of ((unresolved DEFAULT`Arc))	inv p == (forall x, y in set get_nodes(p) & (((not (before(x, y, p) and before(y, x, p))) and (x <> mk_token("pinit"))) => ((before(mk_token("pinit"), x, p) and (x <> mk_token("goal"))) => before(x, mk_token("goal"), p))))static private Goal_instance = compose Goal_instance of gl'(unresolved DEFAULT`Literal), ai'(unresolved DEFAULT`Action_id) endstatic private Goal_instances = set of ((unresolved DEFAULT`Goal_instance))state Partial_Planof[pp'(unresolved DEFAULT`Planning_Problem), Os'(unresolved DEFAULT`Action_instances), Ts'(unresolved DEFAULT`Bounded_Poset), Ps'(unresolved DEFAULT`Goal_instances), As'(unresolved DEFAULT`Goal_instances)]	inv mk_(unresolved DEFAULT`Partial_Plan)(pp, Os, Ts, Ps, As) == ((Os(mk_token("pinit")) = mk_Action([mk_token("pinit")], {}, (pp.I), {})) and ((Os(mk_token("goal")) = mk_Action([mk_token("goal")], (pp.G), {}, {})) and (((rng Os) subset ((pp.AS) union {Os(mk_token("pinit")), Os(mk_token("goal"))})) and (((dom Os) = get_nodes(Ts)) and (((As inter Ps) = {}) and (forall A in set (dom Os) & ((forall p in set (Os(A).pra) & (mk_Goal_instance(p, A) in set (Ps union As))) and (forall gi in set As & (exists [A in set (dom Os)] & achieve(Os, Ts, A, gi))))))))))get_nodes' (set of ((unresolved DEFAULT`Arc)) -> set of ((unresolved DEFAULT`Action_id)))	get_nodes(p) ==({(a.source) | [a in set p]} union {(a.dest) | [a in set p]})before' ((unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Action_id) * set of ((unresolved DEFAULT`Arc)) -> bool)	before(x, z, p) ==((mk_Arc(x, z) in set p) or (exists [y in set get_nodes(p)] & (before(x, y, p) and before(y, z, p))))possibly_before' ((unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Action_id) * set of ((unresolved DEFAULT`Arc)) -> bool)	possibly_before(x, z, p) ==((x <> z) and (not before(z, x, p)))completion_of' ((unresolved DEFAULT`Bounded_Poset) * (unresolved DEFAULT`Bounded_Poset) -> bool)	completion_of(p, q) ==(forall x, y in set get_nodes(p) & (before(x, y, q) and before(x, y, p)))initposet' (() -> (unresolved DEFAULT`Bounded_Poset))	initposet() =={mk_Arc(mk_token("pinit"), mk_token("goal"))}add_node' ((unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Bounded_Poset) -> (unresolved DEFAULT`Bounded_Poset))	add_node(u, p) ==(p union {mk_Arc(mk_token("pinit"), u), mk_Arc(u, mk_token("goal"))})make_before' ((unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Bounded_Poset) -> (unresolved DEFAULT`Bounded_Poset))	make_before(u, v, p) ==(if (possibly_before(u, v, p) and ({u, v} subset get_nodes(p)))then (p union {mk_Arc(u, v)})else p)private newid((isa'set of ((unresolved DEFAULT`Action_id))))i'(unresolved DEFAULT`Action_id)	post (i not in set isa)achieve' ((unresolved DEFAULT`Action_instances) * (unresolved DEFAULT`Bounded_Poset) * (unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Goal_instance) -> bool)	achieve(Os, Ts, A, mk_(unresolved DEFAULT`Goal_instance)(p, O)) ==(before(A, O, Ts) and ((p in set (Os(A).add)) and (not (exists [C in set (dom Os)] & (possibly_before(C, O, Ts) and (possibly_before(A, C, Ts) and (p in set (Os(C).del))))))))declobber' ((unresolved DEFAULT`Action_instances) * (unresolved DEFAULT`Bounded_Poset) * (unresolved DEFAULT`Action_id) * (unresolved DEFAULT`Goal_instance) -> bool)	declobber(Os, Ts, NewA, mk_(unresolved DEFAULT`Goal_instance)(q, C)) ==(before(C, NewA, Ts) or ((not (q in set (Os(NewA).del))) or (exists [W in set (dom Os)] & (before(NewA, W, Ts) and (before(W, C, Ts) and (q in set (Os(W).add)))))))INIT((ppi'(unresolved DEFAULT`Planning_Problem)))	ext [wr pp'(unresolved DEFAULT`Planning_Problem), wr Os'(unresolved DEFAULT`Action_instances), wr Ts'(unresolved DEFAULT`Bounded_Poset), wr Ps'(unresolved DEFAULT`Goal_instances), wr As'(unresolved DEFAULT`Goal_instances)]	post ((pp = ppi) and ((Os = {mk_token("pinit") |-> mk_Action([mk_token("pinit")], {}, (ppi.I), {}), mk_token("goal") |-> mk_Action([mk_token("goal")], (ppi.G), {}, {})}) and ((Ts = initposet()) and ((Ps = {mk_Goal_instance(g, mk_token("goal")) | [g in set (ppi.G)]}) and (As = {})))))ACHIEVE_1((gi'(unresolved DEFAULT`Goal_instance)))	ext [rd Os'(unresolved DEFAULT`Action_instances), wr Ts'(unresolved DEFAULT`Bounded_Poset), wr Ps'(unresolved DEFAULT`Goal_instances), wr As'(unresolved DEFAULT`Goal_instances)]	pre (gi in set Ps)	post (exists [A in set (dom Os)] & (achieve(Os, Ts, A, gi) and (completion_of(Ts, Ts~) and ((Ps = (Ps~ \ {gi})) and (As = (As~ union {gi}))))))ACHIEVE_2((gi'(unresolved DEFAULT`Goal_instance)))	ext [rd pp'(unresolved DEFAULT`Planning_Problem), wr Os'(unresolved DEFAULT`Action_instances), wr Ts'(unresolved DEFAULT`Bounded_Poset), wr Ps'(unresolved DEFAULT`Goal_instances), wr As'(unresolved DEFAULT`Goal_instances)]	pre (gi in set Ps)	post let NewA = newid((dom Os~)) in (exists [A in set (pp.AS)] & ((Os = (Os~ ++ {NewA |-> A})) and (achieve(Os, Ts, NewA, gi) and (forall gj in set As~ & (declobber(Os, Ts, NewA, gj) and (completion_of(Ts, add_node(NewA, Ts~)) and ((Ps = ((Ps~ \ {gi}) union {mk_Goal_instance(p, NewA) | [p in set (A.pra)]})) and (As = (As~ union {gi})))))))))end DEFAULT
