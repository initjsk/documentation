RESULT:result:-1:-1,-1:module REALMimportsfrom TESTimport allexportsexport alldefinitionsstatic private max'nat = 10static private N = nat	inv n == (n < max)static private NPoint = compose NPoint of x'(unresolved REALM`N), y'(unresolved REALM`N) endstatic private NSeg = compose NSeg of pts'set of ((unresolved REALM`NPoint)) end	inv mk_(unresolved REALM`NSeg)(ps) == ((card ps) = 2)SelPoints' ((unresolved REALM`NSeg) +> ((unresolved REALM`NPoint) * (unresolved REALM`NPoint)))	SelPoints(mk_(unresolved REALM`NSeg)(pts)) ==let p in set pts in let q in set (pts \ {p}) in mk_(p, q)Points' ((unresolved REALM`NSeg) +> set of ((unresolved REALM`NPoint)))	Points(s) ==let mk_(p1, p2) = SelPoints(s) in {mk_NPoint(x, y) | [x in set DiffX(p1, p2), y in set DiffY(p1, p2)] & let p = mk_NPoint(x, y) in (RatEq(Slope(p, p1), Slope(p2, p)) or ((p = p1) or (p = p2)))}static private Rat = (int * int)Slope' ((unresolved REALM`NPoint) * (unresolved REALM`NPoint) +> (unresolved REALM`Rat))	Slope(mk_(unresolved REALM`NPoint)(x1, y1), mk_(unresolved REALM`NPoint)(x2, y2)) ==mk_((y2 - y1), (x2 - x1))RatEq' ((unresolved REALM`Rat) * (unresolved REALM`Rat) +> bool)	RatEq(mk_(x1, y1), mk_(x2, y2)) ==((x1 * y2) = (x2 * y1))DiffX' ((unresolved REALM`NPoint) * (unresolved REALM`NPoint) +> set of ((unresolved REALM`N)))	DiffX(mk_(unresolved REALM`NPoint)(x1, -), mk_(unresolved REALM`NPoint)(x2, -)) ==(if (x1 < x2)then {x1, ... ,x2}else {x2, ... ,x1})DiffY' ((unresolved REALM`NPoint) * (unresolved REALM`NPoint) +> set of ((unresolved REALM`N)))	DiffY(mk_(unresolved REALM`NPoint)(-, y1), mk_(unresolved REALM`NPoint)(-, y2)) ==(if (y1 < y2)then {y1, ... ,y2}else {y2, ... ,y1})On' ((unresolved REALM`NPoint) * (unresolved REALM`NSeg) +> bool)	On(p, s) ==(p in set Points(s))In' ((unresolved REALM`NPoint) * (unresolved REALM`NSeg) +> bool)	In(p, s) ==(On(p, s) and (p not in set (s.pts)))Meet' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Meet(mk_(unresolved REALM`NSeg)(pts1), mk_(unresolved REALM`NSeg)(pts2)) ==((card (pts1 inter pts2)) = 1)Parallel' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Parallel(s, t) ==let mk_(p1, p2) = SelPoints(s), mk_(p3, p4) = SelPoints(t) in (Slope(p1, p2) = Slope(p3, p4))Overlap' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Overlap(s1, s2) ==((card (Points(s1) inter Points(s2))) > 1)Aligned' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Aligned(s1, s2) ==(Coliner(s1, s2) and (not Overlap(s1, s2)))Intersect' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Intersect(s, t) ==let mk_(mk_(unresolved REALM`NPoint)(x11, y11), mk_(unresolved REALM`NPoint)(x12, y12)) = SelPoints(s), mk_(mk_(unresolved REALM`NPoint)(x21, y21), mk_(unresolved REALM`NPoint)(x22, y22)) = SelPoints(t) in let a11 = (x11 - x12), a12 = (x22 - x21), a21 = (y11 - y12), a22 = (y22 - y21), b1 = (x11 - x21), b2 = (y11 - y21) in let d1 = ((b1 * a22) - (b2 * a12)), d2 = ((b2 * a11) - (b1 * a21)), d = ((a11 * a22) - (a12 * a21)) in ((d <> 0) and let l = (d1 / d), m = (d2 / d) in ((0 < l) and ((l < 1) and ((0 < m) and (m < 1)))))Coliner' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Coliner(s, t) ==let mk_(p1, p2) = SelPoints(s), mk_(p3, p4) = SelPoints(t) in (RatEq(Slope(p1, p2), Slope(p3, p4)) and (RatEq(Slope(p1, p3), Slope(p1, p4)) or RatEq(Slope(p3, p1), Slope(p1, p4))))Disjoint' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) +> bool)	Disjoint(s1, s2) ==((s1 <> s2) and ((not Meet(s1, s2)) and (not Intersect(s1, s2))))Intersection' ((unresolved REALM`NSeg) * (unresolved REALM`NSeg) -> (unresolved REALM`NPoint))	Intersection(s, t) ==let mk_(mk_(unresolved REALM`NPoint)(x11, y11), mk_(unresolved REALM`NPoint)(x12, y12)) = SelPoints(s), mk_(mk_(unresolved REALM`NPoint)(x21, y21), mk_(unresolved REALM`NPoint)(x22, y22)) = SelPoints(t) in let a11 = (x11 - x12), a12 = (x22 - x21), a21 = (y11 - y12), a22 = (y22 - y21), b1 = (x11 - x21), b2 = (y11 - y21) in let d1 = ((b1 * a22) - (b2 * a12)), d = ((a11 * a22) - (a12 * a21)) in (if (d <> 0)then let x0 = ((x11 * d) + (d1 * (x12 - x11))), y0 = ((y11 * d) + (d1 * (y12 - y11))) in mk_NPoint(RoundToN((abs x0), (abs d)), RoundToN((abs y0), (abs d)))else (undefined))	pre Intersect(s, t)RoundToN' (nat * nat +> nat)	RoundToN(a, b) ==let mk_(z, aa) = (if (a >= b)then mk_((a div b), (a mod b))else mk_(0, a)) in (if ((aa = 0) or ((2 * aa) <= b))then zelse (z + 1))static private Realm = compose Realm of points'set of ((unresolved REALM`NPoint)), segs'set of ((unresolved REALM`NSeg)) end	inv mk_(unresolved REALM`Realm)(ps, ss) == ((forall mk_(unresolved REALM`NSeg)(pts) in set ss & (pts subset ps)) and ((forall s in set ss, p in set ps & (not In(p, s))) and (forall s1, s2 in set ss & ((s1 <> s2) => ((not Intersect(s1, s2)) and (not Overlap(s1, s2)))))))InsertNPoint' ((unresolved REALM`Realm) * (unresolved REALM`NPoint) +> (unresolved REALM`Realm))	InsertNPoint(mk_(unresolved REALM`Realm)(ps, ss), p) ==(if (p in set ps)then mk_Realm(ps, ss)elseif (forall s in set ss & (p not in set E(s)))then mk_Realm((ps union {p}), ss)else let s_env = {s | [s in set ss] & (p in set E(s))} in let ss1 = (dunion {{mk_NSeg({p1, p}), mk_NSeg({p, p2})} | [mk_(unresolved REALM`NSeg)({p1, p2}) in set s_env] & (p not in set {p1, p2})}) in mk_Realm((ps union {p}), ((ss union ss1) \ s_env)))	pre (not (exists [s in set ss] & In(p, s)))InsertNSegment' ((unresolved REALM`Realm) * (unresolved REALM`NSeg) +> (unresolved REALM`Realm))	InsertNSegment(mk_(unresolved REALM`Realm)(ps, ss), s) ==(if (s in set ss)then mk_Realm(ps, ss)elseif ((forall p in set ps & (p not in set (E(s) \ EndPoints(ss)))) and (forall t in set ss & ((not Intersect(s, t)) and (not Overlap(s, t)))))then mk_Realm(ps, (ss union {s}))else let p_env = ({p | [p in set (ps inter E(s))]} \ EndPoints(ss)), s_inter = {t | [t in set ss] & Intersect(s, t)} in let ss1 = ChopNPoints(p_env, {s}) in let mk_(new_ps, new_ss) = ChopNSegs(ss, s_inter, ss1, {}) in mk_Realm((ps union new_ps), new_ss))	pre ((s.pts) subset ps)ChopNPoints' (set of ((unresolved REALM`NPoint)) * set of ((unresolved REALM`NSeg)) +> set of ((unresolved REALM`NSeg)))	ChopNPoints(ps, ss) ==(if (ps = {})then sselse let p in set ps in let s_env = {s | [s in set ss] & ((p in set E(s)) and (p not in set (s.pts)))} in let s in set s_env in let mk_(p1, p2) = SelPoints(s) in ChopNPoints((ps \ {p}), ((ss \ {s}) union {mk_NSeg({p1, p}), mk_NSeg({p2, p})})))	pre (forall p in set ps & (exists [s in set ss] & ((p in set E(s)) and (p not in set (s.pts)))))ChopNSegs' (set of ((unresolved REALM`NSeg)) * set of ((unresolved REALM`NSeg)) * set of ((unresolved REALM`NSeg)) * set of ((unresolved REALM`NPoint)) +> (set of ((unresolved REALM`NPoint)) * set of ((unresolved REALM`NSeg))))	ChopNSegs(ss, s_inter, newss, ps) ==(if (s_inter = {})then mk_(ps, (ss union newss))else let t in set s_inter in let {s} = {s | [s in set newss] & Intersect(s, t)} in let p = Intersection(t, s) in let chop_s = {mk_NSeg({p, sp}) | [sp in set (s.pts)] & (p <> sp)}, chop_t = {mk_NSeg({p, tp}) | [tp in set (t.pts)] & (p <> tp)} in ChopNSegs(((ss \ {t}) union chop_t), (s_inter \ {t}), ((newss \ {s}) union chop_s), (ps union {p})))E' ((unresolved REALM`NSeg) +> set of ((unresolved REALM`NPoint)))	E(s) ==let mk_(p1, p2) = SelPoints(s) in {mk_NPoint(x, y) | [x in set DiffX(p1, p2), y in set DiffY(p1, p2)] & (((0 < y) and ((y < (max - 1)) and Intersect(mk_NSeg({mk_NPoint(x, (y - 1)), mk_NPoint(x, (y + 1))}), s))) or ((0 < x) and ((x < (max - 1)) and Intersect(mk_NSeg({mk_NPoint((x - 1), y), mk_NPoint((x + 1), y)}), s))))}EndPoints' (set of ((unresolved REALM`NSeg)) -> set of ((unresolved REALM`NPoint)))	EndPoints(ss) ==(dunion {pts | [mk_(unresolved REALM`NSeg)(pts) in set ss]})CycleCheck' (set of ((unresolved REALM`NSeg)) +> bool)	CycleCheck(ss) ==(exists [sl in set AllLists(ss)] & (forall i in set (inds sl) & (Meet(sl(i), sl((if (i = (len sl))then 1else (i + 1)))) and (forall j in set ((inds sl) \ {(if (i = 1)then (len sl)else (i - 1)), i, (if (i = (len sl))then 1else (i + 1))}) & (not Meet(sl(i), sl(j)))))))AllLists' (set of ((unresolved REALM`NSeg)) +> set of (seq of ((unresolved REALM`NSeg))))	AllLists(ss) ==(cases ss 'case {} -> {[]},case {s} -> {[s]}others (dunion {{([s] ^ l) | [l in set AllLists((ss \ {s}))]} | [s in set ss]})end)static private Cycle = set of ((unresolved REALM`NSeg))	inv ss == CycleCheck(ss)OnCycle' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> bool)	OnCycle(p, c) ==(exists [s in set c] & On(p, s))InsideCycle' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> bool)	InsideCycle(p, c) ==((not OnCycle(p, c)) and IsOdd(((card SR(p, c)) + (card SI(p, c)))))OutsideCycle' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> bool)	OutsideCycle(p, c) ==(not (OnCycle(p, c) or InsideCycle(p, c)))SR' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> set of ((unresolved REALM`NSeg)))	SR(p, ss) =={s | [s in set ss] & let mk_(p1, p2) = SelPoints(s) in ((((p.y) < (max - 1)) and ((not On(p1, SP(p))) and On(p2, SP(p)))) or (((p.y) < (max - 1)) and ((not On(p2, SP(p))) and On(p1, SP(p)))))}	pre CycleCheck(ss)SI' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> set of ((unresolved REALM`NSeg)))	SI(p, ss) =={s | [s in set ss] & (((p.y) < (max - 1)) and Intersect(s, SP(p)))}SP' ((unresolved REALM`NPoint) +> (unresolved REALM`NSeg))	SP(mk_(unresolved REALM`NPoint)(x, y)) ==mk_NSeg({mk_NPoint(x, y), mk_NPoint(x, (max - 1))})	pre (y < (max - 1))IsOdd' (nat +> bool)	IsOdd(n) ==((n mod 2) <> 0)Partition' ((((unresolved REALM`NPoint) * set of ((unresolved REALM`NSeg)) -> bool)) * (unresolved REALM`Cycle) +> set of ((unresolved REALM`NPoint)))	Partition(pred, ss) =={mk_NPoint(x, y) | [x in set {0, ... ,(max - 1)}, y in set {0, ... ,(max - 1)}] & pred(mk_NPoint(x, y), ss)}P' ((unresolved REALM`Cycle) +> set of ((unresolved REALM`NPoint)))	P(ss) ==(Partition(OnCycle, ss) union Partition(InsideCycle, ss))AreaInside' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	AreaInside(c1, c2) ==(P(c1) subset P(c2))EdgeInside' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	EdgeInside(c1, c2) ==(AreaInside(c1, c2) and ((c1 inter c2) = {}))VertexInside' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	VertexInside(c1, c2) ==(EdgeInside(c1, c2) and ((Partition(OnCycle, c1) inter Partition(OnCycle, c2)) = {}))AreaDisjoint' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	AreaDisjoint(c1, c2) ==(((Partition(InsideCycle, c1) inter P(c2)) = {}) and ((Partition(InsideCycle, c2) inter P(c1)) = {}))EdgeDisjoint' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	EdgeDisjoint(c1, c2) ==(AreaDisjoint(c1, c2) and ((c1 inter c2) = {}))VertexDisjoint' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	VertexDisjoint(c1, c2) ==((P(c1) inter P(c2)) = {})AdjacentCycles' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	AdjacentCycles(c1, c2) ==(AreaDisjoint(c1, c2) and ((c1 inter c2) <> {}))MeetCycles' ((unresolved REALM`Cycle) * (unresolved REALM`Cycle) +> bool)	MeetCycles(c1, c2) ==(EdgeDisjoint(c1, c2) and ((Partition(OnCycle, c1) inter Partition(OnCycle, c2)) <> {}))SAreaInside' ((unresolved REALM`NSeg) * (unresolved REALM`Cycle) +> bool)	SAreaInside(s, c) ==let mk_(p1, p2) = SelPoints(s) in (PAreaInside(p1, c) and PAreaInside(p2, c))SEdgeInside' ((unresolved REALM`NSeg) * (unresolved REALM`Cycle) +> bool)	SEdgeInside(s, c) ==let mk_(p1, p2) = SelPoints(s) in ((PAreaInside(p1, c) and PVertexInside(p2, c)) or (PAreaInside(p2, c) and PVertexInside(p1, c)))SVertexInside' ((unresolved REALM`NSeg) * (unresolved REALM`Cycle) +> bool)	SVertexInside(s, c) ==let mk_(p1, p2) = SelPoints(s) in (PVertexInside(p1, c) and PVertexInside(p2, c))PAreaInside' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> bool)	PAreaInside(p, c) ==(p in set P(c))PVertexInside' ((unresolved REALM`NPoint) * (unresolved REALM`Cycle) +> bool)	PVertexInside(p, c) ==(p in set Partition(InsideCycle, c))static private Face = compose Face of c'(unresolved REALM`Cycle), hs'set of ((unresolved REALM`Cycle)) end	inv mk_(unresolved REALM`Face)(c, hs) == ((forall h in set hs & EdgeInside(h, c)) and ((forall h1, h2 in set hs & ((h1 <> h2) => EdgeDisjoint(h1, h2))) and (forall ss in set (power (c union (dunion hs))) & (CycleCheck(ss) => (ss in set (hs union {c}))))))PAreaInsideF' ((unresolved REALM`NPoint) * (unresolved REALM`Face) +> bool)	PAreaInsideF(p, mk_(unresolved REALM`Face)(c, hs)) ==(PAreaInside(p, c) and (forall h in set hs & (not PVertexInside(p, h))))SAreaInsideF' ((unresolved REALM`NSeg) * (unresolved REALM`Face) +> bool)	SAreaInsideF(s, mk_(unresolved REALM`Face)(c, hs)) ==(SAreaInside(s, c) and (forall h in set hs & (not SEdgeInside(s, h))))FAreaInside' ((unresolved REALM`Face) * (unresolved REALM`Face) +> bool)	FAreaInside(mk_(unresolved REALM`Face)(c1, hs1), mk_(unresolved REALM`Face)(c2, hs2)) ==(AreaInside(c1, c2) and (forall h2 in set hs2 & (AreaDisjoint(h2, c1) or (exists [h1 in set hs1] & AreaInside(h2, h1)))))FAreaDisjoint' ((unresolved REALM`Face) * (unresolved REALM`Face) +> bool)	FAreaDisjoint(mk_(unresolved REALM`Face)(c1, hs1), mk_(unresolved REALM`Face)(c2, hs2)) ==(AreaDisjoint(c1, c2) or ((exists [h2 in set hs2] & AreaInside(c1, h2)) or (exists [h1 in set hs1] & AreaInside(c2, h1))))FEdgeDisjoint' ((unresolved REALM`Face) * (unresolved REALM`Face) +> bool)	FEdgeDisjoint(mk_(unresolved REALM`Face)(c1, hs1), mk_(unresolved REALM`Face)(c2, hs2)) ==(EdgeDisjoint(c1, c2) or ((exists [h2 in set hs2] & EdgeInside(c1, h2)) or (exists [h1 in set hs1] & EdgeInside(c2, h1))))end REALM, module TESTimportsfrom REALMimport allexportsexport alldefinitionsstatic private p1'(unresolved REALM`NPoint) = mk_REALM`NPoint(1, 1)static private p2'(unresolved REALM`NPoint) = mk_REALM`NPoint(5, 3)static private p3'(unresolved REALM`NPoint) = mk_REALM`NPoint(1, 9)static private p4'(unresolved REALM`NPoint) = mk_REALM`NPoint(2, 3)static private p5'(unresolved REALM`NPoint) = mk_REALM`NPoint(9, 5)static private p6'(unresolved REALM`NPoint) = mk_REALM`NPoint(6, 9)static private p7'(unresolved REALM`NPoint) = mk_REALM`NPoint(4, 5)static private p8'(unresolved REALM`NPoint) = mk_REALM`NPoint(4, 6)static private p9'(unresolved REALM`NPoint) = mk_REALM`NPoint(1, 6)static private p10'(unresolved REALM`NPoint) = mk_REALM`NPoint(5, 0)static private p11'(unresolved REALM`NPoint) = mk_REALM`NPoint(5, 1)static private p12'(unresolved REALM`NPoint) = mk_REALM`NPoint(6, 0)static private p13'(unresolved REALM`NPoint) = mk_REALM`NPoint(6, 1)static private s1'(unresolved REALM`NSeg) = mk_REALM`NSeg({p1, p2})static private s2'(unresolved REALM`NSeg) = mk_REALM`NSeg({p1, p3})static private s3'(unresolved REALM`NSeg) = mk_REALM`NSeg({p2, p4})static private s4'(unresolved REALM`NSeg) = mk_REALM`NSeg({p4, p3})static private s5'(unresolved REALM`NSeg) = mk_REALM`NSeg({p3, p2})static private s6'(unresolved REALM`NSeg) = mk_REALM`NSeg({p5, p4})static private s7'(unresolved REALM`NSeg) = mk_REALM`NSeg({p6, p1})static private s8'(unresolved REALM`NSeg) = mk_REALM`NSeg({p5, p3})static private s9'(unresolved REALM`NSeg) = mk_REALM`NSeg({p5, p7})static private s10'(unresolved REALM`NSeg) = mk_REALM`NSeg({p9, p3})static private s11'(unresolved REALM`NSeg) = mk_REALM`NSeg({p10, p8})static private s12'(unresolved REALM`NSeg) = mk_REALM`NSeg({p1, p5})static private s13'(unresolved REALM`NSeg) = mk_REALM`NSeg({p10, p13})static private s14'(unresolved REALM`NSeg) = mk_REALM`NSeg({p11, p12})static private r1'(unresolved REALM`Realm) = mk_REALM`Realm({p1, p2}, {s1})static private r2'(unresolved REALM`Realm) = mk_REALM`Realm({p5, p4}, {s6})static private r3'(unresolved REALM`Realm) = mk_REALM`Realm({p5, p4, p3}, {s6, s8})static private r4'(unresolved REALM`Realm) = mk_REALM`Realm({p1, p3, p4, p5, p6, p7, p8}, {s6, s8})static private r5'(unresolved REALM`Realm) = mk_REALM`Realm({p10, p13}, {s13})end TEST
