RESULT:result:-1:-1,-1:Proof Obligation 1' (Unproved)Alloc(ADDR, State), mem'' let be st existence obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 26'36(forall addr'ADDR, mk_State(mem, access, used)'State & (addr not in set used) =>  exists c'CON)Proof Obligation 2' (Unproved)Alloc(ADDR, State)' subtype obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 28'7(forall addr'ADDR, mk_State(mem, access, used)'State & (addr not in set used) =>  (let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = (mem ++ {addr |-> let c'CON in c}) in    inv_State(mk_State(mem', access, used'))))Proof Obligation 3' (Unproved)Alloc2(ADDR, State), mem'' let be st existence obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 35'40(forall addr'ADDR, mk_State(mem, access, used)'State & ((addr not in set used) and (addr in set access)) =>  exists c'CON)Proof Obligation 4' (Unproved)Alloc2(ADDR, State), mem'' map compatible obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 35'15(forall addr'ADDR, mk_State(mem, access, used)'State & ((addr not in set used) and (addr in set access)) =>  forall ldom1 in set dom mem, rdom2 in set dom {addr |-> let c'CON in c} &  ldom1 = rdom2 => mem(ldom1) = {addr |-> let c'CON in c}(rdom2))Proof Obligation 5' (Unproved)Alloc2(ADDR, State)' subtype obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 37'7(forall addr'ADDR, mk_State(mem, access, used)'State & ((addr not in set used) and (addr in set access)) =>  (let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = (mem munion {addr |-> let c'CON in c}) in    inv_State(mk_State(mem', access, used'))))Proof Obligation 6' (Unproved)Alloc20(ADDR, State)' subtype obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 46'7(forall addr'ADDR, mk_State(mem, access, used)'State & ((addr not in set used) and (addr in set access)) =>  (let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to ((<c0> | CON)) = (mem ++ {addr |-> <c0>}) in    inv_State(mk_State(mem', access, used'))))Proof Obligation 7' (Unproved)Alloc21(ADDR, State), mem'' let be st existence obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 54'29(forall addr'ADDR, mk_State(-, access, used)'State & ((addr not in set used) and (addr in set access)) =>  exists c'CON)Proof Obligation 8' (Unproved)Alloc21(ADDR, State)' subtype obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 56'7(forall addr'ADDR, mk_State(-, access, used)'State & ((addr not in set used) and (addr in set access)) =>  (let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = {addr |-> let c'CON in c} in    inv_State(mk_State(mem', access, used'))))Proof Obligation 9' (Unproved)Alloc3(ADDR, State, map (ADDR) to (CON))' post condition obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 61'1(forall addr'ADDR, mk_State(mem, access, used)'State, mem2'map (ADDR) to (CON) &  pre_Alloc3(addr, mk_State(mem, access, used), mem2) => post_Alloc3(addr, mk_State(mem, access, used), mem2, let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = (mem munion {addr |-> let c'CON in c}) in mk_State(mem', access, used')))Proof Obligation 10' (Unproved)Alloc3(ADDR, State, map (ADDR) to (CON))' let be st existence obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 70'39(forall addr'ADDR, mk_State(mem, access, used)'State, mem2'map (ADDR) to (CON) &  (((addr not in set used) and (addr in set access)) => let RESULT'State = let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = (mem munion {addr |-> let c'CON in c}) in mk_State(mem', access, used') in     exists c'CON))Proof Obligation 11' (Unproved)Alloc3(ADDR, State, map (ADDR) to (CON))' map compatible obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 70'14(forall addr'ADDR, mk_State(mem, access, used)'State, mem2'map (ADDR) to (CON) &  (((addr not in set used) and (addr in set access)) => let RESULT'State = let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = (mem munion {addr |-> let c'CON in c}) in mk_State(mem', access, used') in     forall ldom1 in set dom mem, rdom2 in set dom {addr |-> let c'CON in c} &    ldom1 = rdom2 => mem(ldom1) = {addr |-> let c'CON in c}(rdom2)))Proof Obligation 12' (Unproved)Alloc3(ADDR, State, map (ADDR) to (CON)), mem'' let be st existence obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 65'40(forall addr'ADDR, mk_State(mem, access, used)'State, mem2'map (ADDR) to (CON) & ((addr not in set used) and (addr in set access)) =>  exists c'CON)Proof Obligation 13' (Unproved)Alloc3(ADDR, State, map (ADDR) to (CON)), mem'' map compatible obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 65'15(forall addr'ADDR, mk_State(mem, access, used)'State, mem2'map (ADDR) to (CON) & ((addr not in set used) and (addr in set access)) =>  forall ldom1 in set dom mem, rdom2 in set dom {addr |-> let c'CON in c} &  ldom1 = rdom2 => mem(ldom1) = {addr |-> let c'CON in c}(rdom2))Proof Obligation 14' (Unproved)Alloc3(ADDR, State, map (ADDR) to (CON))' subtype obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 67'7(forall addr'ADDR, mk_State(mem, access, used)'State, mem2'map (ADDR) to (CON) & ((addr not in set used) and (addr in set access)) =>  (let used''set of (ADDR) = (used union {addr}), mem''map (ADDR) to (CON) = (mem munion {addr |-> let c'CON in c}) in    inv_State(mk_State(mem', access, used'))))Proof Obligation 15' (Unproved)AllocSafe(ADDR, State)' post condition obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 74'1(forall addr'ADDR, sta'State &  post_AllocSafe(addr, sta, (Safe(sta) => Safe(Alloc(addr, sta)))))Proof Obligation 16' (Unproved)AllocSafe(ADDR, State)' function apply obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 76'24(forall addr'ADDR, sta'State &  pre_Alloc(addr, sta))Proof Obligation 17' (Unproved)AllocSafe0(ADDR, State)' post condition obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 79'1(forall addr'ADDR, sta'State &  pre_AllocSafe0(addr, sta) => post_AllocSafe0(addr, sta, (Safe(sta) => Safe(Alloc(addr, sta)))))Proof Obligation 18' (Unproved)AllocSafe0(ADDR, State)' function apply obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 81'24(forall addr'ADDR, sta'State & (addr not in set (sta.used)) =>  pre_Alloc(addr, sta))Proof Obligation 19' (Unproved)AllocSafe2(ADDR, State)' post condition obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 85'1(forall addr'ADDR, sta'State &  pre_AllocSafe2(addr, sta) => post_AllocSafe2(addr, sta, (Safe(sta) => Safe(Alloc(addr, sta)))))Proof Obligation 20' (Unproved)AllocSafe2(ADDR, State)' function apply obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 87'24(forall addr'ADDR, sta'State & ((addr not in set (sta.used)) and (addr in set (sta.access))) =>  pre_Alloc(addr, sta))Proof Obligation 21' (Unproved)RunTest(), s' subtype obligation in 'Example3' (../../documentation/examples/VDM++/memoryproof/memory.vdmpp) at line 96'20inv_State(mk_State({<a0> |-> <c0>}, {<a0>, <a1>}, {<a0>}))
