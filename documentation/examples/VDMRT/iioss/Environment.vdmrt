\begin{vdm_al}
class Environment is subclass of IIOSSTYPES

types
	
	public InputTP   = Time * seq of inline;
	
	public outline = EventId * EventType * seq of char * nat; 
	public inline = EventId * EventType * PigId * [Position] * PigStyId * Time;

instance variables

	-- access to the VDMTools stdio
	io : IO := new IO();
	-- the input file to process
	inlines : seq of inline := [];
	-- the output file to print
	outlines : seq of outline := [];
	-- maintain a link to all sensors
	sensors : map nat to Sensor := {|->};
	--inv dom ranges = dom sensors;
	busy : bool := true;
	
	server : [Server] := nil;
	
	-- Amount of time we want to simulate
	simtime : nat; -- Time;

operations
	
	public Environment: seq of char ==> Environment
	Environment (fname) ==
	(
		def mk_(timeval,input) = mk_( 10000,
[
mk_( 1, <PIG_NEW>, 1, mk_Position( 1, 1 ), 1, 1000 ),
mk_( 2, <SHOW_PIG>, 1, nil, 1, 1500 ),
mk_( 3, <PIG_NEW>, 2, mk_Position( 2,2  ), 1, 2000 ),
mk_( 4, <PIG_NEW>, 3, mk_Position( 3, 3 ), 2, 2500 ),
mk_( 5, <PIG_NEW>, 4, mk_Position( 4, 4 ), 2, 3000 ),
mk_( 6, <PIG_NEW>, 5, mk_Position( 5, 5 ), 3, 3500 ),
mk_( 7, <PIG_NEW>, 6, mk_Position( 6, 6 ), 3, 4000 ),
mk_( 8, <PIG_NEW>, 7, mk_Position( 7, 7 ), 4, 4500 ),
mk_( 9, <PIG_NEW>, 8, mk_Position( 8, 8 ), 4, 5000 ),
mk_( 10, <SHOW_PIG>, 8, nil, 1, 5500 ),
mk_( 11, <SHOW_PIG>, 9, nil, 1, 6000 ),
mk_( 12, <PIG_MOVED>, 1, nil, 1, 6500 ),
mk_( 13, <SHOW_PIG>, 3, nil, 1, 6510 ),
mk_( 14, <PIG_NEW>, 1, nil, 2, 6520 ),
mk_( 15, <PIG_NEW>, 2, nil, 2, 6520 ),
mk_( 16, <SHOW_PIG>, 4, nil, 2, 8000 ) 
]
)--io.freadval[InputTP](fname) 
		in
	    (
			inlines := input;
			simtime := timeval;
	    );
	);
	
	public addServer : Server ==> ()
	addServer (pServer) == 
	(
		server := pServer;
	);
	
	public addSensor: Sensor ==> ()
	addSensor (psens) == 
	(
		dcl id : nat := card dom sensors + 1;
	    sensors := sensors munion {id |-> psens}
	);
	
	public getServer: () ==> Server
	getServer() == return server
	pre server <> nil;
	
	public getNoSensors: () ==> nat
	getNoSensors() == return card dom sensors;        
	
	private createSignal: () ==> () 
	createSignal () == 
	duration(10)
	(
		if len inlines > 0  then 
		(
			dcl curtime : Time := time, done : bool := false;
	        while not done do
	        (
	        	def mk_ (eventid, eventType, pigid, position, pigStyId, pt) = hd inlines in -- Next inline event
	            if pt <= curtime then 
	            (
	             	 if (eventType = <PIG_NEW>) then
	             	 (
	             	 	sensors(pigStyId).trip(eventType, pigid, position);
	             	 )
	             	 elseif (eventType = <PIG_MOVED>) then
	             	 (
	             	 	sensors(pigStyId).trip(eventType, pigid, nil);
	             	 )
	             	 elseif (eventType = <SHOW_PIG>) then
	             	 (
	             	 	server.PointAtPig(eventid,pigid);
	             	 );
	                 inlines := tl inlines;
	                 done := len inlines = 0;
	                 return;
	            ) 
	            else 
	            (	
	             	done := true;
	                return
	            )
	         )
	    )
		else 
		(
			busy := false;
			return;
		)
	  )
	  pre server <> nil and card dom sensors <> 0;
	
	
	public handleEvent: EventId * EventType *  seq of char * Time ==> ()
	handleEvent (eventID, eventType, text, eventTime) == 
	(
	   outlines := outlines ^ [mk_(eventID, eventType, text, eventTime)];
	);
	
	public showResult: () ==> ()
	showResult () ==
	(
		IIOSSTYPES`DebugPrint("---------------");
		IIOSSTYPES`DebugPrint("ShowResult");
		for outline in outlines do
		(
			IIOSSTYPES`DebugPrint(" "); 
            IO`print(outline);
		);		
		IIOSSTYPES`DebugPrint("---------------");
	);
	
	public isFinished : () ==> ()
	isFinished () == skip;

	public GetAndPurgeOutlines: () ==> seq of outline
GetAndPurgeOutlines() ==
  let res = outlines
  in
    (outlines := [];
     return res);
	
sync
	
	mutex (handleEvent);
	mutex(createSignal);
	per isFinished => not busy;
	
thread
	periodic (1000,10,900,0) (createSignal)


end Environment

\end{vdm_al}

\begin{rtinfo}
[TotalxCoverage]{vdm.tc}[Environment]
\end{rtinfo}