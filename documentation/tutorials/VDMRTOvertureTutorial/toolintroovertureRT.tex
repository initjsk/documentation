% $Revision: 1.28 $
\chapter{Overture Tool Support for VDM-RT: an Introductory Guide}\label{cha:toolbox}
% vppinput[guide/test1.vpp]
\initexercise

\section*{Preamble}

This is an introduction to the Overture Integrated Development
Environment (IDE) and its facilities for supporting modelling and
analysis in VDM-RT the VDM extended language for modelling real-time
systems, formerly known as VICE~(VDM in Constrained Environments). 
Since there is not yet a book on VDM-RT it
may be used as a substitute for Chapter 3 of ``Validated Designs for
Object-oriented Systems''\footnote{John Fitzgerald, Peter Gorm Larsen,
  Paul Mukherjee, Nico Plat and Marcel Verhoef. \emph{Validated
    Designs for Object-oriented Systems}, Springer, New York. 2005,
  ISBN 1-85233-881-4.} or as a free-standing guide. Additional material
is available on the book's web
site\footnote{\url{http://overturetool.org/publications/books/vdoos/}.}. Throughout this guide we will refer to
the textbook as ``the book'' and the book's web site simply as ``the
web site''.

We use examples based on an \emph{in-car navigation} case study and
VDM-RT model presented in Appendix~\ref{app:navigation}. 

We introduce the features of Overture that support the combination of
formal modelling in VDM++ with object-oriented design using UML. This
is done by providing a ``hands-on'' tour of Overture, providing enough
detail to allow you to use Overture for serious applications,
including the exercises in the book. However, this is by no means a
complete guide to Overture\footnote{Note that the Overture tool suite support three
  different VDM dialects; VDM-SL (Specification Language), VDM++ and
  VDM-RT (Real Time) so although this tutorial illustrate how to use
  Overture with VDM-RT models you will see multiple references to
  these dialects.}; more information can be obtained
from~\url{www.overturetool.org}.



\section{Introduction}

In this chapter, an in-car radio navigation system which supports the Traffic Message Channel (TMC) will used as example. 

The system is composed of three main clusters of functionality; 
\begin{itemize}
\item The Man-Machine Interface (MMI) takes care of user interaction such as handling key press input and graphical display output. 
\item The navigation is responsible for destination entry, route planning and turn-by-turn guidance. 
\item The radio is responsible for basic tuner and volume control as well as handling traffic information from the TMC.
\end{itemize}

Figure~\ref{fig:navigationoverview} gives an overview of the in-car navigation system. 

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=4.5in]{figures/CarNavigationOverview}
  \caption[labelInTOC]{Car Navigation System Overview}
  \label{fig:navigationoverview}
\end{center}
\end{figure}

The system must be able to support the following three use cases:

\begin{description}
\item[\textbf{Change Volume:}] The user turns the rotary button and expects near instant audible feedback from the system. Furthermore, the visual feedback
(the volume setting on the screen) should be timely and synchronized with the
audible feedback.
\item[\textbf{Address Look-up:}] Destination entry is supported by a smart ``typewriter'' style interface. By turning a knob the user can move from letter to letter; by pressing it the user will select the currently highlighted letter. The map database is searched for each letter that is selected and only those letters in the on-screen alphabet are enabled that are potential next letters in the list.
\item[\textbf{TMC Message Handling:}] Digital traffic information is important for in-car radio navigation systems. It enables features such as automatic re-planning of the planned route in case a traffic jam occurs ahead. It is also increasingly important to enhance road safety by warning the driver, for example when a ghost driver is spotted just ahead on the planned route. TMC is such a digital traffic information service.
\end{description}

When developing a Real-time model, it is adviced to create an object-oriented model first outside the real-time domain. This will enable the developer to focus on the structure of the system as well as eliminating any concurrency issues before moving on to the real-time domain. This proposed process is described in much more detail in \cite{Larsen&09b}.

The rest of this chapter has the following outline; Section~\ref{sec:install} describes how to obtain the Overture tools.
Section~\ref{sec:vdmsupport} provides an initial introduction to the
terminology used by Eclipse tools like Overture. 
%% This section may be
%% skipped by readers who are already familiar with using Eclipse
%% tools. 
Section~\ref{sec:fromUMLtoVDM} shows how VDM-RT models can be
connected to UML.
Section~\ref{sec:debugging} describes the process of testing and
debugging VDM-RT models using Overture.
Section~\ref{sec:testcov} follows up to show how test coverage
information from the testing carried out can be produced and displayed
directly in a pdf document generated using the \LaTeX\ text processing
system. 
Section~\ref{sec:CT} shows how parts of the test process can be
automated using Overture's combinatorial testing feature.
 Section~\ref{sec:RTLV} goes on
to show the Real-Time Log Viewer which gives a graphical presentation
of thread execution.
Section~\ref{sec:PO} demonstrates the automatic generation of the
additional checks (called \emph{proof obligations}) needed to ensure
that a model is consistent.  Finally, Section~\ref{sec:cmdline}
illustrates how parts of Overture's functionality can be accessed from
a command line.

\section{Obtaining the Overture Tools}\label{sec:install}

In order to run the examples and exercises presented in the book, it
is necessary to install two separate tools -- Overture and Modelio.
% or
%Enterprise
%Architect, the latter being license-controlled.
\begin{description}
\item[\textbf{Overture:}] This
 is an open source tool, developed by volunteers and built on
the Eclipse platform. The project is managed on
GitHub\footnote{\url{https://github.com/overturetool/}}.
The best way to run Overture is to download a special version of
Eclipse with the Overture functionality already pre-installed. If you
go to:
  \begin{quote}
  \texttt{http://overturetool.org/download/}
  \end{quote}
  \noindent you will find pre-installed versions of Overture for
  Windows, Linux and Mac\footnote{It is planned to develop an update
    facility, allowing updates to be applied directly from within the
    Overture tools without requiring a reinstallation. However, this
    can be a risky process because of the dependencies on non-Overture
    components and so is not yet supported.}.

\item[\textbf{Modelio:}] This is a tool that is both available in a commercial version as well as in an open source setting from a
  company called Softeam. Just like Overture this tool is built on top of the Eclipse platform. The product can be
  obtained from
\begin{quote}
\texttt{http://www.modelio.org/}.
\end{quote}
\end{description}

A library of sample VDM-RT models is available and can be imported.  Finally, the web site
\texttt{http://overturetool.org/download/examples/} contains all the examples used in this book
as plain text files but these are also all present as importable examples. Finally, in order to make use of the
test coverage feature described in Section~\ref{sec:testcov} it is
necessary to have the text processing system called \LaTeX\ and its
\texttt{pdflatex} feature. This can for example be obtained from:
\begin{quote}
\url{http://miktex.org/2.9/}
\end{quote}

\paragraph{Note for \vdmtools$^{\mbox{\small\textbf{{\textregistered}}}}$ users.} 
Overture provides a new open source VDM tool set, but it can also work
in conjunction with the
\vdmtools$^{\mbox{\small\textbf{{\textregistered}}}}$
tool set originally developed by IFAD A/S and now maintained and
developed by SCSK~(see
\url{http://www.vdmtools.jp/en/}). From Overture it is also possible
automatically to transfer a project over to \vdmtools.
 
\section{Using the Overture Perspective}\label{sec:vdmsupport}

Eclipse is an open source platform based on a \emph{workbench} that
provides a common look and feel for a large collection of extension
products. Thus if a user is familiar with one Eclipse-based product,
it will generally be easy to start using a different product on the
same workbench. The Eclipse workbench consists of several panels
called \emph{views}, such as the VDM Explorer view at the top left
of Figure~\ref{fig:userguide:OverturePerspective}. A particular
collection of panels designed to assist a specific activity is called a
\emph{perspective}. For example
Figure~\ref{fig:userguide:OverturePerspective} shows the standard
Overture perspective which contains views for managing Overture
projects, and viewing and editing files. As we shall show later,
several other perspectives are available in Overture.

The \emph{VDM Explorer view} helps you create, select, and delete
Overture projects and navigate between the files in these
projects. Start by importing the car navigation project from the
book's web site. This can be done by right clicking the project view
and selecting \emph{Import}, followed by \emph{Overture} $\rightarrow$
\emph{Overture Examples}.  

The panel to the right of the Explorer is the \emph{editor area}. An
editor customised to the dialect of VDM being used in the project will
appear here.

\begin{figure}[!htb]
\begin{center}
  \includegraphics[width=4.5in]{figures/OverturePerspectiveRT}
  \caption[labelInTOC]{The Overture Perspective}
  \label{fig:userguide:OverturePerspective}
\end{center}
\end{figure}

The \emph{Outline view}, to the right of the editor (see
Figure~\ref{fig:userguide:OutlineView}), displays an outline of the
file selected in the editor. It shows all declared classes, their
instance variables, values, types, functions, operations and traces.
Figure~\ref{fig:userguide:OverturePerspective} shows the outline view
on the right hand side. Clicking on an operation or function in the
outline will move the cursor in the editor view to its definition. At
the top of the outline view there is a button to~(optionally) display
the items in the outline view in alphabetical order.

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=4.5in]{figures/OutlineViewRT}
  \caption[labelInTOC]{The Outline View}
  \label{fig:userguide:OutlineView}
\end{center}
\end{figure}

The \emph{Problems view} presents information about the projects you
are working on, including warnings and error messages. In
Figure~\ref{fig:userguide:OverturePerspective} the problems view is
shown at the bottom.

In the standard Overture perspective there is a \emph{VDM Quick
  Interpreter} view in a pane in the same area as the problems
view. This can be used for evaluation of standard VDM expressions
independent of all VDM projects incorporated in your Overture
IDE. This can be very convenient to gain understanding of the
different VDM operators. In Figure~\ref{fig:QuickIntView} it is
possible to see how a couple of expressions (typed in at the box at
the botton of the view) are evaluated\footnote{If errors appear in
  this evaluation the current version of the Overture IDE simply yield
  a \texttt{Fatal error} where it is anticipated that later releases
  will provide more helpful run-time errors to the users.}. Note that
in order to get a console where you are able to make use of
definitions you need to use the console launch mode as described in
Section~\ref{sec:debugconfig} below. 

\begin{figure}[!htb]
\begin{center}
  \includegraphics[width=4.5in]{figures/quickinterpreter}
  \caption[labelInTOC]{The VDM quick interpreter view}
  \label{fig:QuickIntView}
\end{center}
\end{figure}

Most of the other features of the workbench, such as the menus and
toolbars, are similar to other Eclipse applications, though for
newcomers to Eclipse it is worth noting that there is a special menu
with Overture-specific functionality. One convenient feature is a
toolbar of shortcuts to switch between different perspectives that
appears on the right side of the screen; these vary dynamically
according to context and history.

When making corrections to the model, you can use the Overture IDE
templates. When you hit the key combination \textit{CTRL+space} after
entering the initial characters of the template needed, Overture will
offer possible completions. For example, if you type ''op'' followed by
\textit{CTRL+space}, Overture will propose the use of an implicit or
explicit operation template.

\begin{figure}
	\begin{center}
	\includegraphics[width=4in]{figures/OperationTemplateRT}
	\caption{Explicit operation template}
	\label{fig:userguide:operationTemplate}
	\end{center}
\end{figure}

The Overture IDE supports many templates for language constructs
including cases statements, classes, quantified expressions, functions
(explicit/implicit), operations (explicit/implicit) and many
more\footnote{It is possible to see and enhance the complete list of
  these by selecting \emph{Window} $\rightarrow$ \emph{Preferences}
  $\rightarrow$ \emph{VDM}  $\rightarrow$ \emph{Templates}.}. 
Further templates can easily be added in the future. The use of
templates makes it more concenient to write VDM models without
detailed prior knowledge of the language syntax.

When editing a VDM model, the Overture IDE parses the content of the
editor buffer continuously as changes are made. If there are any
syntax errors, these will be reported in the problems view, as well as
being highlighted in the editor. See the bottom of
Figure~\ref{fig:userguide:OverturePerspective}. Each time a
VDM-RT model file is saved the editor type checks the model and reports
any errors or warnings. Note also that the suggestions made about
missing characters in the
error messages may not always be entirely the action you may wish to
take when correcting the source since the tool cannot guess what you
intended to write.

%Most of the imported files in the car navigation project should be
%syntactically correct, but the \texttt{World.vdmrt} file contains one
%deliberate syntax error. The error in this case is a common one: a
%semicolon separating the different definitions has been forgotten.

%\begin{myhardexercise}\label{ex:type-errors}
%Correct all the errors discovered by the type checker and syntax and
%type check your corrected files until no errors appear.
%\textbf{Hint:} Consult the model presented in 
%Appendix~\ref{app:navigation}
%to see how values (note using ``\vdmstyle{=}'' rather than
%``\vdmstyle{:=}''), types and constructors should be defined and how
%access modifiers should be used.
%\end{myhardexercise}


\section{Mapping Between UML and  VDM}\label{sec:fromUMLtoVDM}\label{sec:syntaxcheck}
\label{sec:typecheck}

In order to map the UML class diagram created in Modelio
to VDM, a new project must be created in the Overture IDE to receive
it. This is done by right-clicking in the \emph{VDM Explorer} view,
and creating a new VDM-RT project and for example naming it
\texttt{CarRadioNavUML}. If the desired language dialect (say a VDM-RT 
project) is not directly available in the right-click menu, please choose
\emph{Project} or 
\emph{Other} and browse to the VDM-RT project. By right-clicking the new 
project root in the \emph{VDM Explorer}, \emph{UML Transformation} can 
be chosen, followed by \emph{Import XMI}. Now browse to the XMI/XML file
exported from Modelio called \texttt{carradnavuml.uml} and open this.

%The three classes from the Alarm system will be converted to VDM++ format
%(\texttt{.vdmpp}), one file per class.

%When editing a model, it can be useful to navigate to a specific
%operation in the file, instead of reaching for the mouse, this can be
%done using a shortcut (\textit{Ctrl+O})) which opens a small pop-up. This
%pop-up allows the user to navigate to a given location in the model
%simply by filling out the name of an field, operation, function or
%type. The use of intellisense furthermore ensures that the user does
%not have to write out the full name of the desired location. Figure
%\ref{fig:quickOutline} shows the quick outline.

%\begin{figure}
%	\begin{center}
%	\includegraphics[width=300px]{figures/quickOutline}
%	\caption[Quick Outline]{Quick Outline}
%	\label{fig:quickOutline}
%	\end{center}
%\end{figure}

%% The transformation from UML to VDM is not entirely automated right now. For
%% example, any custom types are transformed to VDM++ definitions using
%% machine-generated identifiers since custom types are not named in
%% UML. As a result, you have to expect to make minor modifications to
%% the generated VDM files. 

%\subsection{Mapping VDM to UML}

It is possible to automatically transform all the classes from the car
radio navigation project to UML. To do this, simply right
click the project root and choose \emph{UML Transformation} $
\rightarrow $ \emph{Export XMI} (i EMF UML3.0.0 format som \texttt{.uml} 
format). The UML/XMI file can subsequently be
imported in Modelio, enabling the user to get an overview
of the complete model.

Note that state charts, activity
diagrams, sequence diagrams, objects charts, package charts are not
used in the UML mapping. It is essentially only the information used
statically inside classes and their usage in class diagrams that is
used.

\section{Debugging}\label{sec:debugging}

This section describes how to debug a model by testing it using the
Overture IDE. The model can be exercised by running the operations
\emph{RunScenario1} or \emph{RunScenario2} in the \emph{World} class:

\begin{lstlisting}
class World

types
  
public perfdata = nat * nat * real

instance variables

static public envTasks : map seq of char 
                         to EnvironmentTask := {|->};

operations

addEnvironmentTask: seq of char * EnvironmentTask ==> ()
addEnvironmentTask (pnm, penv) ==
( envTasks := envTasks munion { pnm |-> penv };
  penv.Run() );

public RunScenario1 : () ==> map seq of char 
                             to perfdata
RunScenario1 () ==
( addEnvironmentTask("VolumeKnob", 
                     new VolumeKnob(10));
  addEnvironmentTask("TransmitTMC", 
                     new TransmitTMC(10));
  return { name |-> envTasks(name).getMinMaxAverage() 
         | name in set dom envTasks } );
...
end World
\end{lstlisting}

\subsection{The Debug Configuration}\label{sec:debugconfig}

Before you start to debug a model in Overture, you need to set up a
\emph{debug configuration}. Right click the project and choose
\emph{Debug As} $ \rightarrow $ \emph{Debug configuration}.
%\footnote{Note that the
%  \emph{Run As} functionality existing Eclipse users are used to is
%  not supported in the current version of Overture. In the current
%  version of Overture debugging of VDM-RT models in general does not
%  work very well because of the scheduling done internally in the
%  interpreter. This is currently being redesigned and it is expected
%  that in the next stable release this will be fully operational.}. 
The debug configuration
dialog have 3 different launch modes:

\begin{description}
\item[Entry Point:] This is the standard Eclipse approach where one
  decides before debugging which operation/function to call.
\item[Remote Console:] This is an anvanced option that enables remote
  control of the interpreter and this is described in the Overture
  user manual~\cite{Larsen&10d}.
\item[Console:] This will simply start up a console where the user
  interactive can debug different operations/functions defined in the
  selected project\footnote{For VDMTools users this will be a familiar
    console corresponding to a VDM model that has been initialised in
    VDMTools' interpreter.}.
\end{description}

Here we will start with using 
the traditional Eclipse approach with an ``Entry Point'' launch
configuration which 
requires the project name, the class, the operation/function used as
the entry point of the test and the source file containing the entry
point definition.  As an example,
Figure~\ref{fig:userguide:debugConfiguration} shows the debug
configuration for the car navigation model. The class and
operation/function name can be chosen from a Browse dialog. If the
operation or function has arguments, these must be typed in manually
between the brackets of the entry point function/operation.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/debugConfigurationRT}
  \caption{The debug configuration dialog}
  \label{fig:userguide:debugConfiguration}
\end{center}
\end{figure}

Once the configuration is ready, the model can be debugged. The
Overture IDE will change to the \emph{Debug perspective} which
contains the views needed for debugging in VDM. Breakpoints can easily
be set by double clicking in the left margin of the editor view. When
the debugger reaches a breakpoint, evaluation suspends and the user
can inspect the values of different variables and step through the VDM
model line by line.
 
\subsection{The Debug Perspective}

The Debug perspective is illustrated on figure~\ref{fig:userguide:DebuggingVDM}
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4.5in]{figures/DebuggingVDMRT}
  \caption[Debugging perspective]{Debugging perspective}
  \label{fig:userguide:DebuggingVDM}
\end{center}
\end{figure}
The \emph{Debug view} in the upper left corner of the Debug
perspective shows all running models and their call stacks. It also
shows whether a given model is stopped, suspended or running. All
threads are also shown, along with their running status. It is
possible to switch between threads from the Debug view.

\begin{table}
\begin{center}
\caption{Overture debugging buttons\label{tab:debugButtons}}
\begin{tabular}{|l|l|}\hline \hline
\textbf{Button} & \textbf{Explanation} \\ \hline
\includegraphics[width=0.03\textwidth]{figures/resume} & Resume debugging \\
\includegraphics[width=0.03\textwidth]{figures/suspend} & Suspend debugging\\
\includegraphics[width=0.03\textwidth]{figures/terminate} & Terminate debugging\\
\includegraphics[width=0.03\textwidth]{figures/stepinto} & Step into\\
\includegraphics[width=0.03\textwidth]{figures/stepover} & Step over \\
\includegraphics[width=0.03\textwidth]{figures/stepreturn} & Step return\\
\includegraphics[width=0.03\textwidth]{figures/stepbystep} & Use step filters\\
\hline \hline
\end{tabular}
\end{center}
\end{table}

At the top of the view are standard Eclipse buttons (see
Table~\ref{tab:debugButtons}) for controlling debugging, allowing you
to stop, step into, step over and resume.

The \emph{Variables view} in the upper right corner of the Debug
perspective shows all the variables in a given context, when a
breakpoint is reached. The variables and their displayed values are
automatically updated when stepping through a model.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/BreakpointViewRT}
  \caption{Breakpoint View}
  \label{fig:userguide:BreakpointView}
\end{center}
\end{figure}

\subsection{Breakpoints}

The \emph{Breakpoints view} gives an overview of all breakpoints
set~(see Figure~\ref{fig:userguide:BreakpointView}). From this view
the user can easily navigate to the location of a given breakpoint,
disable or delete them, or set their properties.
 
%Conditional breakpoints are supported. These are a powerful tool for
%the developer since they allow a condition to be specified which has
%to be true in order for the debugger to stop at the given
%breakpoint. The condition can either be a boolean expression using
%variables in scope at the breakpoint, or it can be a hit count after
%which the breakpoint should become active.

%\begin{figure}[htp]
%\begin{center}
%  \includegraphics[width=4in]{figures/Breakpointconditional}
%  \caption{Conditional breakpoint options}
%  \label{fig:userguide:BreakpointConditional}
%\end{center}
%\end{figure}

%You can make a simple breakpoint conditional by right clicking on the
%breakpoint mark in the left margin of the editor and selecting the option
%\emph{Breakpoint properties}. This opens a dialog shown in
%figure~\ref{fig:userguide:BreakpointConditional}.

The \emph{Expressions view} allows the user to enter \emph{watch}
expressions whose values are automatically displayed and updated when
stepping. Watch expressions can be added manually or created by
selecting \emph{create watch expression} from the Variables view. It
is possible to edit existing expressions.  Like the Breakpoints view,
this view is hidden in the upper right hand corner in
Figure~\ref{fig:userguide:DebuggingVDM}.

%While the Overture Expressions view allows you to easily inspect
%values, the functionality is somewhat limited. For more thorough
%inspections in Overture, the \emph{Interactive Console view} is
%provided. Here commands can be executed in a given context, i.e.\ when
%the debugger is at a breakpoint. The Interactive Console keeps a
%command history, so that previously executed commands can be run again
%easily. The interactive console can be seen at the bottom of
%Figure~\ref{fig:userguide:DebuggingVDM}.

\section{Test coverage}\label{sec:testcov}

It is often useful to know how much of a model has been exercised by a
set of tests\footnote{Note that this feature is not yet supported for
  models using unicode characters such a Japanese identifiers.}. 
This gives some insight into the thoroughness of a test
suite and may also help to identify parts of the model that have not
been assessed, allowing new tests to be devised to cover these. When
any evaluation is performed on a VDM-RT model, the interpreter records
the lines of the VDM-RT model that are executed. This permits the line
coverage to be examined after a test to identify the parts of the
VDM++ model that have not yet been exercised -- coverage is
cumulative, so a set of tests can be executed and their total coverage
examined at the end.

In our simple example, the different tests in the exercise above does
cause the majority of the VDM-RT model to be executed, but for
demonstration purposes let us start by cleaning the model (right click
on the project and select \texttt{Clean}). Let us evaluate the
\texttt{RunScenario1} and \texttt{RunScenario2} operations where the
\texttt{Generate coverage} option is selected. 
Remember that whenever test coverage
information is desired the \texttt{Generate Coverage} option
must be selected as shown in Figure~\ref{fig:userguide:debugConfiguration}. 
 Once the debugger
has completed and the result is written out in the \texttt{console} it
is possible to right click on the \texttt{CarRadioNavi} project and
select the \emph{Latex} $ \rightarrow $ \emph{Latex coverage} the
coverage information that have been gathered in any expressions that
have been debugged since the last change to a file have been saved or
the project have been cleaned will be turned into a pdf file. The
\texttt{CarRadioNavi.pdf} file is placed in the
\texttt{generated/latex} directory. Note that whenever the model is
adjusted or it is cleaned so it gets type checked again all the files
in the \texttt{generated} directory are deleted.

The coverage information is provided in a way where uncovered
expressions are shown in red in the generated pdf file. In addition
after the content of each VDM-RT source file a table with coverage
overview is provided in tabular form. So for example for the
\texttt{MMI} class this looks like:

\begin{longtable}{|l|r|r|}
\hline
Function or operation & Coverage & Calls \\
\hline
\hline
HandleKeyPress & 90.0\% & 36 \\
\hline
UpdateScreen & 87.0\% & 65 \\
\hline
\hline
mmi.vdmrt & 88.0\% & 101 \\
\hline
\end{longtable}

\noindent where the \texttt{ExpertIsOnDuty} and \texttt{ExpertToPage}
operations are fully covered by just one call (due to the fact that
its body is simply one line) whereas the \texttt{PlantInv} operation
is called twice\footnote{Note that the coverage from the combinatorial
  testing feature described in Section~\ref{sec:CT} is not taken into
  account in the current version of the Overture IDE, but this will be
  enabled in a later release.}.

\section{Combinatorial Testing}\label{sec:CT}

The previous sections have shown how to manually test and debug models
that use an executable subset of VDM-RT. However, Overture also
contains a feature enabling more automation in the testing process. It
is possible to write regular expressions, as \emph{traces}, that one
would like to expand into a large set of individual tests. When new
traces are incorporated in a VDM project you may need to press the
\textsf{Refresh} button
(\includegraphics[width=0.02\textwidth]{figures/refresh}) in the
\emph{CT Overview} view.

In order to illustrate how this can be used, we have introduced a
\texttt{Test} class which only in introduced in this example for
illustration purposes.

In order to do the automation, Overture needs to know about the
combinations of operation calls that you would like to have carried
out, so it is necessary to write a kind of regular expression called a
\emph{trace}. VDM-RT has been extended such that traces can be written
directly as a part of a VDM-RT model. In our case, inside the \texttt{Test}
class one can find:

\begin{lstlisting}
traces

TT: let x in set {1,2,3}
    in
      ((mmi.HandleKeyPress(x,x) | 
        mmi.UpdateScreen(x,x) | 
        radio.AdjustVolume(x) |
        radio.HandleTMC(x) |
        nav.DatabaseLookup(x) |
        nav.DecodeTMC(x));
       EnvironmentTask`IsFinished())
 \end{lstlisting}

\noindent The let-be statements in the trace called
\texttt{TT} yield all possible combinations of the variable
bindings to \texttt{x} (whereas manual debugging will select an
arbitrary binding here). This is followed by the call of 6 different
operations seperated by an alternative operator (\texttt{|}). The
selected \texttt{x} value is then used as argument t each of these
operations so in total this generates 18 (3 times 6) test cases. 
Inside this combinatorial testing view you can
select the \texttt{CarRadNav} project, right click it and 
choose the \textsf{Full
  Evaluation} option as shown in Figure~\ref{fig:CToptions}. 
Now Overture expands
and executes all 18 test cases one after each other. The results of these
executions are illustrated with green check marks and red crosses, meaning that
the tests passed or failed respectively (see Figure~\ref{fig:tracesradnav}). Note
that in the Combinatorial Testing perspective, the view in the lower region is
able to show the individual steps of a selected test case, along with the
corresponding results from its four operation calls.

Note that here \texttt{IsFinished} have been defined in the
\texttt{EnvironmentTask} class as:

\begin{lstlisting}
public static IsFinished: () ==> ()
IsFinished() == skip;

sync

  per IsFinished => #fin(logSysToEnv) > 0;
\end{lstlisting}
This is necessary because the operations being tested are all defined
as being asynchronous and thus the execution would complete before the
system had a change to do its work if the \texttt{IsFinished}
operation was not used.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=1.5in]{figures/CToptions}
\caption{Invoking the combinatorial testing feature\label{fig:CToptions}}
\end{center}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{figures/tracesradnav}
\caption{Using Combinatorial Testing for the Radio Navigation VDM-RT model\label{fig:tracesradnav}}
\end{center}
\end{figure}

The syntax for traces also enables operation sequencing and repetition to be
specified, but these were not needed for this simple case. Using the full power
of traces it is possible to efficiently generate and execute very large test
suites. Naturally, this is most likely to find inconsistencies when the model
attempts to define its essential predicates (invariants, pre and post-conditions).

\section{Realtime Log Viewer}\label{sec:RTLV}

When a VDM-RT model is being executed a textual logfile with
information about the time of the generation is created in
a folder called ''\texttt{generated/logs/debugconfig}'' with the
\emph{.logrt} extension. Note that \texttt{debugconfig} here will be
the name of the launch configuration that the user have created so if
several launch confugurations are used these will be separated in
different directories. This logfile can be viewed in the build-in
RealTime Log Viewer, by double-clicking the file in the project
view. The viewer allows you to explore system execution in different
ways. In Figure~\ref{fig:userguide:ArchitecturalOverview} the
architectural overview of the system is given, describing the
distributed nature of the model.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ArchitectureOverview}
  \caption{Architectural overview}
  \label{fig:userguide:ArchitecturalOverview}
\end{center}
\end{figure}

The RealTime Log Viewer also enables the user to get an overview of
the model execution on a system level -- this can be seen in
Figure~\ref{fig:userguide:ExecutionOverview}. This view shows how the
different CPUs communicate via the BUSes of the system.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ExecutionOverview}
  \caption{Execution overview}
  \label{fig:userguide:ExecutionOverview}
\end{center}
\end{figure}

Since the complete execution of the model cannot be shown in a normal
sized window, you have the option of jumping to a certain time
using the \emph{Go to time} button. It is also possible to export all
the generated views to \emph{JPG} format using the \emph{Export Image}
button. All the generated pictures will be placed in the ''log''
folder.

In addition to the execution overview, the RealTime Log Viewer can
also give an overview of all executions on a single CPU. This view
gives a detailed description of all operations and functions invoked
on the CPU as well as the scheduling of concurrent processes. This can
be seen in Figure~\ref{fig:userguide:ExecutionCPU}.

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ExecutionCPU}
  \caption{Execution on single CPU}
  \label{fig:userguide:ExecutionCPU}
\end{center}
\end{figure}

\section{Proof Obligations}\label{sec:PO}

The Overture tool is also able to generate \emph{Proof Obligations}
automatically for VDM-RT models. Proof obligations are boolean
expressions that describe constraints to be met at various points in
the model in order to ensure that the model is internally consistent
(i.e.\ no run-time errors will occur while debugging if these are all
satisfied). Proof obligations are generated to ensure, for example,
that operations will always respect invariants on instance
variables. Each proof obligation generated from a model should
evaluate to \emph{true}2.3.0.

The proof obligation generator is invoked by right clicking on the
project in the \emph{Explorer view} and then selecting the \emph{Proof
  Obligations} \texttt{->} \emph{Generate Proof Obligations}
entry. This will start up a proof obligation perspective with a
special \emph{PO view}. For the alarm example this view takes the form
shown in Figure~\ref{fig:POview}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{figures/poviewRT}
\caption{The Proof Obligation view for the Car Navigation VDM-RT model\label{fig:POview}}
\end{center}
\end{figure}

One of the first proof obligations listed for this example is related
to the \texttt{RunScenario1} operation, which is defined as:

\begin{lstlisting}
public RunScenario1 : () ==> map seq of char to perfdata
RunScenario1 () ==
 (addEnvironmentTask("VolumeKnob", new VolumeKnob(10));
  addEnvironmentTask("TransmitTMC", new TransmitTMC(10));
  return { name |-> envTasks(name).getMinMaxAverage() 
         | name in set dom envTasks } );
\end{lstlisting}

The proof obligation records the constraint that the mapping
application \texttt{envTasks(name)} is indeed defined (i.e.\ that the
\texttt{name} is in the domain of the mapping \texttt{envTasks}). This is described as a proof
obligation in the following form:

\begin{lstlisting}
forall name in set (dom envTasks) &
  name in set dom envTasks
\end{lstlisting}
Proof obligations represent checks that should be made on a model in
order to gain confidence in its consistency. At present, proof
obligations have to be checked by manual inspection of the model
code. Tools are being developed for Overture to check as many as
possible of the proof obligations automatically, but there are always
likely to be some that have to be checked manually. 


\section{A Command-Line Interface}\label{sec:cmdline}

So far only the graphical user interface of Overture has been
presented but the core of Overture also
provides a simple command line interface.  This is useful for the
automatic batch execution of tests, though the command line also
provides a full set of interactive execution and debugging commands
which can be useful when examining batch tests. 

Overture is written in Java, and so to run it from the command line, the
Overture jar file\footnote{See the Overture documentation at
  \url{http://overturetool.org/documentation/manuals.html} for the location of the
  \texttt{jar} file or use the script or windows \texttt{bat} file incorporating this.}  
should be executed with a Java JRE (version 7 or later):

\lstset{style=tool,language=}
\begin{lstlisting}
java -jar Overture-2.3.0.jar
\end{lstlisting}

\noindent If the jar file is executed with no further options like this, it will
print a list of available options and exit. The most important option is the VDM
dialect that the tool should use. In the case of our alarm example, we want to
use VDM-RT for which the option is \verb|-vdmrt|. After this, we can simply
specify the names of the VDM-RT model files to load, or the name of a directory
in which all the files reside:

\begin{lstlisting}
java -jar Overture-2.3.0.jar -vdmrt CarNaviRadio
\end{lstlisting}

\noindent That will perform a syntax and type check of all the VDM-RT model
files in the directory called \verb|CarNaviRadio|, producing any errors and warning
messages on the console, before terminating:

\begin{lstlisting}
Parsed 10 classes in 0.187 secs. No syntax errors
Type checked 12 classes in 0.094 secs. No type errors
\end{lstlisting}

\noindent In the case of our example, there are no syntax or type checking
errors. Warnings can be suppressed using the \verb|-w| option.

If a VDM-RT model has no type checking errors, it can either be given an
expression to evaluate as an option on the command line, or the user can enter
an interactive mode to evaluate expressions and debug their execution.

To evaluate an expression from the command line, the \verb|-e| option is used,
followed by a VDM expression to evaluate. You may also find the \verb|-q|
option useful, as this suppresses the informational messages about the parsing
and type checking:

\begin{lstlisting}
java -jar Overture-2.3.0.jar -vdmrt -w -q -e 
    "new World().RunScenario1()" CarNaviRadio
\end{lstlisting}

\noindent This produces a single line of output for the evaluation, since the
parsing and checking messages are suppressed, as are the warnings:

\begin{lstlisting}
{"TransmitTMC" |-> mk_(118187598, 118187598, 118187598), 
 "VolumeKnob" |-> mk_(36490730, 140915746, 6.2612283777777776E7)}
\end{lstlisting}

Clearly a batch of test evaluations could be performed automatically by running
a series of similar commands and saving the output results for comparison
against expected results.

To run the command line interpreter interactively, the \verb|-i| command line
option must be given. Instead of terminating after the type check, this will
cause Overture to enter its interactive mode, and give the interactive \verb|>|
prompt:

\begin{lstlisting}
Parsed 10 classes in 0.172 secs. No syntax errors
Type checked 12 classes in 0.14 secs. No type errors
Initialized 12 classes in 0.109 secs.
Interpreter started
>
\end{lstlisting}

\noindent From this prompt, various interactive commands can be given to
evaluate expressions, debug their evaluation, or examine the VDM-RT model environment.
The \verb|help| command lists the commands available. The \verb|quit| command
leaves the interpreter.

For example, the following session illustrates the creation of a test object,
followed by an evaluation of its \verb|RunScenario2| operation, and a debug
session with a breakpoint at the start of the same operation:

\begin{lstlisting}
> create world := new World()
> p world.RunScenario2()
= {"InsertAddress" |-> mk_(71646789, 71646789, 71646789), 
   "TransmitTMC" |-> mk_(118187598, 118187598, 118187598)}
Executed in 0.655 secs.

> break World`addEnvironmentTask
Created break [1] in 'World' (CarNaviRadio\World.vdmrt) 
at line 12:5
12:      ( envTasks := envTasks munion { pnm |-> penv };

> p world.RunScenario2()
Stopped break [1] in 'World' (CarNaviRadio\World.vdmrt) 
at line 12:5
12:      ( envTasks := envTasks munion { pnm |-> penv };
[MainThread-164]> print penv
penv = InsertAddress{#77, max_stimuli:=10, e2s:={|->},
 s2e:={|->},EnvironmentTask{#76, max_stimuli:=10, num:=0,
 e2s:={|->},s2e:={|->}}}
[MainThread-164]> continue
Runtime: Error 4021: Duplicate map keys have different 
values:
    "InsertAddress" in 'World' (CarNaviRadio\World.vdmrt) 
at line 12:28
Stopped in 'World' (CarNaviRadio\World.vdmrt) 
at line 12:28
12:      ( envTasks := envTasks munion { pnm |-> penv };
\end{lstlisting}

\noindent Notice that the \verb|print| command is available at the breakpoint
to examine the runtime state of the system. In the example, we show the value
of the \verb|penv| variable. Continuing from this point, the VDM-RT model
raises a runtime error because the previous execution's results are still in
the (static) \verb|envtasks| map. The VDM-RT model can be re-initialized
between runs with the \verb|init| command to avoid this.

The \verb|help| command is context sensitive, and will list the extra debugging
commands available at a breakpoint, such as \verb|continue|, \verb|step|,
\verb|stack|, \verb|list| and so on. The full set of commands is described in the
Overture User Guide\footnote{Supplied with the Overture documentation.}.

\lstset{style=mystyle}

\lstset{style=mystyle,language=VDM++}

\section{Summary}\label{sec:toolintrosummary}

This chapter has introduced the following major features of tool
support for VDM-RT:
\begin{itemize}
%\item using Enterprise Architect with class diagrams\sindex{Enterprise
%  Architect@\tool{Enterprise Architect$^{\mbox{\small\textbf{{\textregistered}}}}$}};
%\item mapping back and forth between Enterprise Architect and Overture;
%\item configuration of selected VDM++ files;
\item syntax checking of VDM-RT models;
\item type checking of VDM-RT models;
%\item the notion of error messages;
\item executing and debugging VDM-RT models;
%\item a command-line interface;
%\item pretty printing VDM++ models with test coverage information;
\item combinatorial testing enabling automation of parts of the
  testing process; 
\item proof obligation generation and
\item a command-line interface enabling access to test coverage.
\end{itemize}
