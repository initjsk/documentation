\documentclass{overturerepchap}
%**********************************************************
%
% Bibliography support
%
%**********************************************************
%\def\@reportno{YY--NN}		% default report no.
%\def\reportno#1{\gdef\@reportno{#1}}
\usepackage{fancyhdr}
\usepackage{longtable}
\newcommand{\bthisbibliography}[1]{\chapter*{References}%
   \begin {list} {}%
     {\settowidth {\labelwidth} {[#1]XX}%
      \setlength {\leftmargin} {\labelwidth}%
      \addtolength{\leftmargin} {\labelsep}%
      \setlength {\parsep} {1ex}%
      \setlength {\itemsep} {2ex}%
     }
  }
\newcommand{\ethisbibliography}{\end{list}}
\newcommand{\refitem}[2]
  {\bibitem[#1]{#2}}

\newcommand{\back}{$\setminus$}
\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}
\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index
    
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\sf #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt #1}\makebox[\kwlen][l]{\sf
    #1}}
\newcommand{\keyw}[1]{{\sf #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{alltt}\input{#1}\end{alltt}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\kw{map }#1\kw{ to }#2}
\newcommand{\INMAP}[2]{\kw{inmap }#1\kw{ to }#2}
\newcommand{\SEQ}[1]{\kw{seq of }#1}
\newcommand{\NSEQ}[1]{\kw{seq1 of }#1}
\newcommand{\SET}[1]{\kw{set of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{$#1 \To #2$}
\newcommand{\FUN}[2]{#1 \To #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}

\pagestyle{fancy}
\fancyhead{}
\fancyhead[LO]{\leftmark}
\fancyhead[RE]{Overture VDM-10 Tool Support: User Guide}
\fancyhead[RO,LE]{\resizebox{0.05\textwidth}{!}{\includegraphics{OMLlogoattempt.jpg}}}
\fancyfoot[C]{\thepage}

\usepackage{makeidx}

\usepackage{graphicx, color}

% definition of VDM++, JavaCC, JJTree, JTB, ANTLR and SableCC for listings
\newcommand{\NL}{\mbox{}\\ \vspace*{-5mm}}
\usepackage{listings}
\newcommand{\url}[1]{\texttt{#1}}
\usepackage{vdmsl-2e}
\usepackage{hyperref}

\usepackage{times}
\usepackage{color}
\include{customlangdef}
% define the layout for listings
\lstdefinestyle{tool}{basicstyle=\ttfamily,
                         frame=trBL, 
			 showstringspaces=false, 
			 frameround=ffff, 
			 framexleftmargin=0mm, 
			 framexrightmargin=0mm}
\lstdefinestyle{mystyle}{basicstyle=\footnotesize\ttfamily,
                         frame=trBL, 
%                         numbers=left, 
%			 gobble=0, 
%			 basewidth=0.51em,
                         showstringspaces=false, 
%			 linewidth=\textwidth, 
			 frameround=fttt, 
			 aboveskip=2mm,
			 belowskip=2mm,
			 framexleftmargin=0mm, 
			 framexrightmargin=0mm}
%\lstdefinestyle{mystyle}{basicstyle=\sffamily\small,
%			 frame=tb,
%                         numbers=left,
%			 gobble=0,
%			 showstringspaces=false,
%			 linewidth=345pt,
%			 frameround=ffff,
%			 framexleftmargin=8mm,
%			 framexrightmargin=8mm,
%			 framextopmargin=1mm,
%			 framexbottommargin=1mm,
%			 aboveskip=7mm,
%			 belowskip=5mm,
%			 xleftmargin=10mm,}

\lstset{style=mystyle}
\lstset{language=VDM++}
%\lstset{alsolanguage=Java}
% The command below enables you to escape into normal LaTeX mode inside your 
% VDM chunks by starting with a `!' character and ending with a `!'
\lstset{escapeinside=!!}

%This file has been converted to use LaTeX2e
%\documentstyle[overture]{article}
%
% any "\include{...}" statements go here
%
\include{ifad}
\include{graphics}
\usepackage{cite}
\usepackage{alltt}
%\usepackage{fancyhdr}
\renewcommand{\topfraction}{0.9}
\renewcommand{\textfraction}{0.05}
\renewcommand{\floatpagefraction}{0.9}
\makeindex

\begin{document}
\title{Overture VDM-10 Tool Support: User Guide}
\author{Peter Gorm Larsen, Kenneth Lausdahl, Augusto Ribeiro and Sune Wolff \\ 
Engineering College of Aarhus\\
Dalgas Avenue 2, DK-8000 \AA{}rhus C, Denmark\\[3mm]
Nick Battle\\
Fujitsu Services\\
Lovelace Road, Bracknell, \\
Berkshire. RG12 8SN, UK}

\date{May 2010}

\reportno{TR-002}     

\maketitle


\textbf{Document history}

\begin{tabular}{|l|l|l|l|}\hline
Month   & Year & Version & Version of Overture.exe \\ \hline
January & 2010 &         & 0.1.5 \\ \hline
March   & 2010 &         & 0.2   \\ \hline
May     & 2010 & 1       & 0.2   \\ \hline
December& 2010 & 2       & 1.0   \\ \hline
\end{tabular}

\tableofcontents

\begin{abstract}
This document is a user manual for the Overture Integrated Development
Environment (IDE) open source tool for
VDM. It can serve as a reference for anybody wishing to make use of
this tool with one of the VDM dialects (VDM-SL, VDM++ and VDM-RT).
This tool support is build on top of the Eclipse platform. The
objective of the Overture open source initiative is to create and support a
platform that can be used for both experimentation of new subsets or
supersets of VDM dialects as well as new features analysing such VDM
models in different ways. The tool is entirely open source so anybody
can join the development team and influence the future
developments. The long term target is to ensure that stable
versions of the tool suite can be used for large scale industrial
applications of the VDM technology.
\end{abstract}

\chapter{Introduction}

The Vienna Development Method (VDM) is one of the longest established
model-oriented formal methods for the development of computer-based
systems and software
\cite{Bjorner&78,Jones90a,Fitzgerald&08c}. It consists of a
group of mathematically well-founded languages for expressing system
models during early design stages, before expensive implementation
commitments are made. The construction and analysis of the model using
Overture help to identify areas of incompleteness or ambiguity in
informal system specifications, and provide some level of confidence
that a valid implementation will have key properties, especially those
of safety or security. VDM has a strong record of industrial
application, in many cases by practitioners who are not specialists in
the underlying formalism or logic
\cite{Larsen&95b,Clement&99,Kurita&09}. Experience with the method
suggests that the effort expended on formal modeling and analysis can
be recovered in reduced rework costs arising from design errors.

VDM models can be expressed in a specification language (VDM-SL) which
supports the description of data and functionality
\cite{ISOVDM96a,Fitzgerald&98b,Fitzgerald&09}. Data are defined by
means of types built using constructors that define structured data
and collections such as sets, sequences and mappings from basic values
such as Booleans and natural numbers. These types are very abstract, allowing
the user to add any relevant constraints as data type
invariants. Functionality is defined in terms of operations over these
data types. Operations can be defined implicitly by preconditions and
postconditions that characterize their behavior, or explicitly by
means of specific algorithms. An extension of VDM-SL, called VDM++,
supports object-oriented structuring of models and permits direct
modeling of concurrency \cite{Fitzgerald&05}. An additional extension
to VDM++ is called VDM Real Time (VDM-RT) (formerly called VDM In a
Constrained Environment (VICE)) \cite{Mukherjee&00,Verhoef&06b}. All
these different dialects are supported by the unified tool called Overture.

Since the VDM modeling languages have a formal mathematical semantics,
a wide range of analyses can be performed on models, both to check
internal consistency and to confirm that models have emergent
properties. Analyses may be performed by inspection, static analysis,
testing or mathematical proof. To assist in this process, Overture
supply tool support for building models in collaboration with other
modeling tools, to execute and test models and to carry out different
forms of static analysis \cite{Larsen&10a}. It can be seen as an open
source version of the commercial tool called VDMTools
\cite{Elmstrom&94,Larsen01,Fitzgerald&08a} although features to
generate executable code in high-level programming languages are
not yet available in Overture.

This guide explains how to use the Overture IDE for developing models
for different VDM dialects. This user manual starts with an explanation
of how to get hold of the software in
Chapter~\ref{sec:install}. This is followed in
Chapter~\ref{sec:vdmsupport} with an introduction to the concepts used
in the different Overture perspectives based on Eclipse
terminology. In Chapter~\ref{sec:projects} it is explained how
projects are managed in the Overture IDE. In Chapter~\ref{sec:editVDM}
the features supported when editing VDM models are explained. This is
followed in Chapter~\ref{sec:debug} with an explanation of the
interpretation and debugging capabilities in the Overture
IDE. Chapter~\ref{sec:testcoverage} then illustrates how test coverage
information can be gathered when models are interpreted. Afterwards,
Chapter~\ref{sec:prettyprint} shows how models with and without test
coverage information can be generated to the text processing system
\LaTeX\ and automatically converted to \texttt{pdf} format if one have
\texttt{pdflatex} installed on the computer. Afterwards, from
Chapter~\ref{sec:POmanagement} to Chapter~\ref{sec:showlog} different
VDM specific features are explained. In Chapter~\ref{sec:POmanagement}
the use of the notion for proof obligations and its support in
Overture is explained. In Chapter~\ref{sec:testing} a notion of
combinatorial testing and the automation support for that in Overture
is presented. In Chapter~\ref{sec:vdmuml} support for mapping between
object-oriented VDM models and UML models is presented. In
Section~\ref{sec:ToVDMRT} it is illustrated how a VDM++ project can be 
changed into a new VDM-RT project. In Chapter~\ref{sec:showlog} it
is shown how to analyse and display logs from executing
such VDM-RT models. After these sections the main part of the user
manual is completed in Chapter~\ref{sec:commandline} with an
explanation of the features from Overture which are also available from
a command-line interface. Appendix~\ref{app:templates} provide a list
of all the standard templates built into Overture. 
From Appendix~\ref{app:internalerrors}
to~\ref{app:POcategories} complete lists of different kinds of errors,
warnings and proof obligations are provided and further explanation
are provided where it is judged necessary.
Finally, in
Appendix~\ref{sec:index} an index of significant terms used in this
user manual can be found. 


\chapter{Getting Hold of the Software}\label{sec:install}

Overture is an open source tool, developed by a community of volunteers 
and is built on top of the Eclipse platform. The project to develop the tools 
is managed using SourceForge.  The best way to run Overture is to download 
a special version of Eclipse with the Overture functionality already pre-installed. If you go to:
  \begin{quote}
  \url{http://sourceforge.net/projects/overture}
  \end{quote}
  \noindent you can use the \textit{Download Now} button to
  automatically download a pre-installed versions of Overture for your
  operating system.  Supported systems are: Windows, Linux and
  Mac\footnote{It is planned to develop an update facility, allowing
    updates to be applied directly from within the generic Eclipse
    platform without requiring a re-installation. However, this can be
    a risky process because of the dependencies on non-Overture
    components and so is not yet supported.}.
Note that when you have extracted all files from the zip file with the
Overture executable for your selected operating system you will find
the first time you start it up it will ask you for selecting a
workspace. Here we simply recommend you to chose the default one proposed 
by Overture and tick off the box for ``use this as the default and do
not ask again''. A welcome screen will introduce you to the overall 
mission of the Overture open source initiative. 

Large libraries of sample VDM-SL, VDM++ and VDM-RT models is available
and can be downloaded from SourceForge under the
\texttt{files/Examples} section using the URL\footnote{The library
  files are created to be used with Eclipse, but can be opened with
  file compression programs like \texttt{Winrar} on Windows}:
\begin{quote}
\url{https://sf.net/projects/overture/files/Examples/}
\end{quote}
Such existing projects can be imported as described in
section~\ref{subsec:importproj}. 

\chapter{Using the Overture Perspective}\label{sec:vdmsupport}

\section{Getting into the Eclipse Terminology}

Eclipse is an open source platform based around a
\emph{workbench}\index{workbench} that provides a common look and feel
to a large collection of extension products. Thus, if a user is
familiar with one Eclipse product, it will generally be easy to start
using a different product on the same workbench. The Eclipse workbench
consists of several panels known as \emph{views}\index{view}, such as
the VDM Explorer view at the top left of
Figure~\ref{fig:userguire:OverturePerspective}. A collection of panels
is called a \emph{perspective}\index{perspective}, for example
Figure~\ref{fig:userguire:OverturePerspective} shows the standard
Overture perspective. This consists of a set of views for managing
Overture projects and viewing and editing files in a
project. Different perspectives are available in Overture as will be
described later, but for the moment think of a perspective as a
useful composition of views for conducting a particular task.

\begin{figure}[!h]
\begin{center}
  \includegraphics[width=\textwidth]{figures/OverturePerspective}
  \caption[labelInTOC]{The Overture Perspective}
  \label{fig:userguire:OverturePerspective}
\end{center}
\end{figure}

The \emph{VDM Explorer view}\index{explorer} lets you create, select, 
and delete Overture projects and navigate between the files in these 
projects, as well as adding new files to existing projects.

Depending upon the dialect of VDM used in a given project,
a corresponding Overture editor will be available here. A new VDM
project is created choosing the \emph{File} $ \rightarrow$ \emph{New}
$\rightarrow$ \emph{Project} resulting in
Figure~\ref{fig:userguide:newOvertureProjectSL}. Here select
the desired VDM dialect and press \emph{Next}. Finally, a name needs 
to be given to the project and then simply select \texttt{Finish}. 


\begin{figure}[!h]
\begin{center}
  \caption[labelInTOC]{Creating a New VDM Project}
  \label{fig:userguide:newOvertureProjectSL}
  \includegraphics[width=2.5in]{figures/newovertureSLproject}
\end{center}
\end{figure}


The \emph{Outline view}\index{outline}, on the right hand side of 
Figure~\ref{fig:userguire:OverturePerspective}, presents an outline of the file selected
in the editor. The outline displays any declared VDM definitions such as
their state components, values, types, functions and operations. In
case of a flat VDM-SL model the module is called {\ttfamily{DEFAULT}}.\index{DEFAULT}
% and traces.
Figure~\ref{fig:userguide:OutlineView} shows a closeup of the outline view. 
Clicking on an operation or function will move the cursor in
the editor to the definition of the operation. At the top of the outline view there
is a button to sort what is displayed in the outline view, for instance it is possible to hide variables.


\begin{figure}[!htb]
\begin{center}
  \includegraphics[width=2.5in]{figures/OutlineView}
  \caption[labelInTOC]{The Outline View}
  \label{fig:userguide:OutlineView}
\end{center}
\end{figure}

The \emph{Problems view}\index{problems} at the bottom of 
Figure~\ref{fig:userguire:OverturePerspective} gathers 
information messages about the projects you are
working on. This includes information generated by Overture, such as
warnings and errors. Please use the suggested corrections with caution,
since the tool cannot guess what you intended to write.

Most of the other features of the workbench, such as the menus and
toolbars, are similar to other Eclipse applications, with the exception 
of a special menu with Overture specific functionality. One
convenient feature is a toolbar of shortcuts to switch between
different perspectives that appears on the right side of the screen;
these vary dynamically according to context and history.

\section{Additional Eclipse Features Applicable in Overture}

\subsection{Opening and Closing Projects}

In order not to take up too much space and computing power it may be
advantageously to close projects that are not used currently. This can
be done by right clicking such projects and then selecting the
\emph{Close Project} entry in the menu.
%menu as shown in Figure~\ref{fig:closeproject}. 
For such closed projects it is possible
to open them again in the same fashion using the \emph{Open project}
entry in the same right click
menu.\index{project!open}\index{project!close} 
 
%\begin{figure}[!htb]
%\begin{center}
%  \includegraphics[width=2in]{screenDumps/closeproject}
%  \caption[labelInTOC]{Closing a Project}
%  \label{fig:closeproject}
%\end{center}
%\end{figure}

\subsection{Adding Additional VDM File Extensions}

If one would like to use additional file types to be associated with a
particular VDM editor instead of the standard {\ttfamily vdmsl},
{\ttfamily vdmpp} and {\ttfamily vdmrt} file types this is possible in
Overture. This is done using the \emph{Window} $\rightarrow$
\emph{Preferences} menu point. Here one can start typing {\ttfamily
  content types} which will result in a menu similar to
Figure~\ref{fig:ContentsTypes}. Here one can press the {\ttfamily Add}
button for the appropriate content type that one wishes to add
additional types of file extensions.\index{file extension}

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=0.6\textwidth]{screenDumps/contentstypes}
\caption{Adding Additional Contents Types\label{fig:ContentsTypes}}
\end{center}
\end{figure}

\subsection{Remove Directories without Source Files}

In case the directory with the VDM source files includes
subdirectories without source files it may be convenient to remove
this additional noise from the \emph{Explorer} view. This can be
accomplished by pressing the small downward pointing arrow at the top
right-most corner of the \emph{Explorer} view. Then the menu shown in
Figure~\ref{fig:filteringfiles} will pop up and here \emph{Filters...}
is selected and then different parts can be filtered away including
directories that have no source files.

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=0.4\textwidth]{screenDumps/filteringfiles}
\caption{Filtering Directories without source files\label{fig:filteringfiles}}
\end{center}
\end{figure}

\subsection{Including line numbers in the Editor}

In case line numbers\index{line number} are desired in the Overture
editor it is possible to to right click in the left-hand-side margin
of the editor and then select \texttt{show line numbers} as shown in
Figure~\ref{fig:linenumbers}.\index{line numbers} 

\begin{figure}[!htb]
\begin{center}
\includegraphics[width=0.4\textwidth]{screenDumps/linenumbers}
\caption{Adding Line Numbers in Editor\label{fig:linenumbers}}
\end{center}
\end{figure}

\subsection{Adding external plug-ins to Overture IDE}

The Overture IDE is build as a RCP\footnote{Rich Client Platform} and
there no update manager is included -- external plug-ins can
still be manually installed though. To install a plug-in there are two
things which needs to be done:
\begin{enumerate}
\item Copy the plug-in jar or jars into the plugin folder of the Overture IDE installation; and
\item Add the plug-in jar file names to the \texttt{osgi.bundles} in the config.ini file which is found under the folder configuration.
\end{enumerate}

After the steps above have been performed, the IDE can be started and the new plug-ins will be available. (Remember to include all depended plug-ins which is not already a part of the Overture IDE).

For example, in order to add SVN support to the Overture IDE you simply have to:
\begin{enumerate}
\item Fetch the update site jars from \url{http://subclipse.tigris.org/} under \emph{Download and Install} and select \emph{Zipped downloads}. The latest version demonstrated in this guide is site-1.6.10.zip.
\item Copy the features and plugins folders into the Overture IDE folder, merging them with the ones of Overture. 
\item Then add the plugins to the \texttt{osgi.bundles} in the \texttt{confi.ini} file separated by comma.
\begin{itemize}
\item \url{org.tigris.subversion.clientadapter}
\item \url{org.tigris.subversion.clientadapter\_1.6.10.jar}
\item \url{org.tigris.subversion.clientadapter.javahl}
\item \url{org.tigris.subversion.clientadapter.javahl\_1.6.9.3.jar}
\item \url{org.tigris.subversion.clientadapter.javahl.win32}
\item \url{org.tigris.subversion.clientadapter.javahl.win32\_1.6.9}
\item \url{org.tigris.subversion.subclipse.core}
\item \url{org.tigris.subversion.subclipse.core\_1.6.10.jar}
\item \url{org.tigris.subversion.subclipse.doc}
\item \url{org.tigris.subversion.subclipse.doc\_1.3.0.jar}
\item \url{org.tigris.subversion.subclipse.graph}
\item \url{org.tigris.subversion.subclipse.graph\_1.0.7.jar}
\item \url{org.tigris.subversion.subclipse.ui}
\item \url{org.tigris.subversion.subclipse.ui\_1.6.10.jar}
\end{itemize}
When the steps above are completed the Overture IDE can be started and SVN support will be available.
\end{enumerate}

\chapter{Managing Overture Projects}\label{sec:projects}

\section{Importing Overture VDM Projects}\label{subsec:importproj}

It is possible to import Overture VDM projects by
right-clicking the explorer view and selecting \emph{Import}, followed
by \emph{General} $\rightarrow$ \emph{Existing Projects into
  Workspace}.  In this way the projects from \texttt{.zip} files
mentioned in Chapter~\ref{sec:install} can be imported very
easily.\index{project!import}  

\section{Creating a New Overture Project}

Follow these steps in order to create a new Overture project:

\begin{enumerate}
	\item Create a new project by choosing \emph{File}
          $\rightarrow$ \emph{New} $\rightarrow$ \emph{Project}
          $\rightarrow$ \emph{Overture}; \index{project!create};
	\item Select the VDM dialect you wish to use (VDM-SL, VDM-PP
          or VDM-RT);\index{VDM dialect};
	\item Press \emph{Next};
         \item Type in a project name;
	\item Chose whether you would like the contents of the new
          project to be in your workspace or outside from existing
          source files (browse to the appropriate directory); and
         \item Click
	the finish button (see Figure~\ref{fig:CreateProjectWizard}).
\end{enumerate}

\begin{figure}[!htb]
	\begin{center}
	  \includegraphics[scale=0.8]{figures/CreateProjectWizard}
	  \caption[Create Project Wizard]{Create Project Wizard}
	  \label{fig:CreateProjectWizard}
	\end{center}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%  Creating a new file
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Creating Files}

Switching to the Overture perspective will change the layout of the user
interface to focus on the VDM development. To change perspective go to the menu 
\emph{window} $\rightarrow$ \emph{open perspective} $\rightarrow$ \emph{other}\ldots and choose the
Overture perspective.
When the developer is in the Overture Perspective the user can create files
using one of the following methods:

\begin{enumerate}
  \item Choose \emph{File} $\rightarrow$ \emph{New} $\rightarrow$
    \emph{VDM-SL Module}\index{creating!VDM-SL module} or 
    \emph{VDM-PP Class}\index{creating!VDM++ class} or 
    \emph{VDM-RT Class}\index{creating!VDM-RT class} or
  \item Right click on the Overture project where you would like to
    add a new file and then choose \emph{New} $\rightarrow$ 
    \emph{VDM-SL Module} or \emph{VDM-PP Class} or \emph{VDM-RT Class}.
\end{enumerate}

In both cases one needs to choose a file name and optionally choose a
directory if one does not want to place the file in the directory of
the chosen Overture project. Then a new file with the appropriate file
extension according to the chosen dialect (\texttt{vdmsl},
\texttt{vdmpp} or \texttt{vdmrt})\index{vdm file extension} can be
created in the selected directory. This file will use the appropriate
module/class template to get the user started with defining the
module/class meant to be placed in this new file. Naturally, keywords 
not used can be deleted.

\section{Setting Project Options}\label{subsec:options}

For each Overture VDM project it is possible to set various VDM
specific settings. One can get access to these by selecting a project
in the \emph{Explorer view} and then right clicking and selecting
\emph{properties}. Here, a VDM specific settings property which
looks like in Figure~\ref{fig:VDMSettings} is shown. The options 
that can be set for each VDM project are:\index{project!options}

\begin{figure}[!hbt]
\begin{center}
  \includegraphics[width=\textwidth]{screendumps/projectsettings}
  \caption[Overture Project Settings]{Overture Project Settings}
  \label{fig:VDMSettings}
\end{center}
\end{figure}

\begin{description}
\item[Language version:] Here the standard is to use the
  \emph{classic} version that is similar to what is used in the
  VDMTools version. Alternatively one can select VDM-10 which
  is a new improved (but not necessarily backwards compatible) version of
  different VDM dialects developed by the Overture Language Board. 
\item[Suppress type checking warnings:] This flag is per default not
  set but if one would like to switch off such warning the flag can be
  set here.
\item[Dynamic type checks:] This is an option to the interpreter (default on) 
  for continuously type checking the values
  during interpretation of a VDM model. It is possible to switch off
  the check here.
\item[Invariant checks:] This is an option to the interpreter (default on) 
  for continuously checking both state and type invariants of the values
  during interpretation of a VDM model. It is possible to switch off
  this check here but note that option requires dynamic type
  checking also to be switched on.
\item[Pre condition checks:] This is an option to the interpreter (default on) 
  for continuously checking pre-conditions for all functions and operations
  during interpretation of a VDM model. It is possible to switch off
  this check here.
\item[Post condition checks:] This is an option to the interpreter (default on) 
  for continuously checking post-conditions for all functions and operations
  during interpretation of a VDM model. It is possible to switch off
  this check here.
\end{description}

In addition to these project settings it is possible to chose to have
a main \LaTeX\ file where one can incorporate the explanations outside
the \texttt{vdm\_al} environment and decide the order in which the
different VDM source files shall be included.

\chapter{Editing VDM models}\label{sec:editVDM}

\section{VDM Dialect Perspectives}

Whenever one wishes to edit parts of a VDM model it can be done in the
editor view. In general it is recommended to make use of the VDM
dialect perspective when one wishes to carry out the editing, since
browsing in the VDM model is supported both by the editor view as well
as by the Outline view. Whenever editing is carried out in the edit
view syntax checking is carried out continuously (even before the
files are saved). Once files are saved the syntax checking is
accompanied by type checking of the entire VDM model if no syntax
errors are found. As a result new
problems (errors and/or warnings) can be found. These will be
displayed both in the problems view as well as with small icons in the
editor view at the lines where the problems have been identified.

\section{Using Templates}

Templates can be particularly useful when modifying VDM models of all 
three dialects (SL, PP and RT). If you hit
the key combination \textit{CTRL+space} after the initial characters
of the template needed, Overture triggers a proposal. For example, if
you type ''fun'' followed by \textit{CTRL+space}, the Overture IDE
will propose the use of an implicit or explicit function template as
shown in Figure~\ref{fig:functionTemplate}. The Overture IDE
supports several types of template: cases, quantifications, functions
(explicit/implicit), operations (explicit/implicit) and many
more. The use
of templates makes it much easier for users not familiar
with the VDM syntax to nevertheless construct models.

\begin{figure}
\begin{center}
\includegraphics[width=4in]{figures/FunctionTemplate}
\caption{Explicit function template}
\label{fig:functionTemplate}
\end{center}
\end{figure}

It is possible to adjust and add to the templates enabled inside the
Overture editor. This can be done by selecting the menu called
\emph{Window} $\rightarrow$ \emph{Preferences}. By starting to type
\emph{template} the Overture specific preferences for templates will
become visible. In Figure~\ref{fig:Templatepreferences} it can be seen
how the template for cases expressions is defined in Overture. Note
that new templates can be added and the already defined ones can be
adjusted by selecting the \emph{Edit} button. It is also possible to
remove templates using the \emph{Remove} button. A full list of the
standard defined templates is available in Appendix~\ref{app:templates}.

\begin{figure}
\begin{center}
\includegraphics[width=4in]{screendumps/templatesRT}
\caption{Adjusting templates for Overture}
\label{fig:Templatepreferences}
\end{center}
\end{figure}

\chapter{Interpretation and Debugging in Overture}\label{sec:debug}

This section describes how to debug a model using the Overture IDE. 

\section{Debug configuration}

Debugging the model under development is done by creating a debug configuration
\index{debug configuration}
from the menu \emph{Run} $\rightarrow $ \emph{Debug configuration}
\ldots 
The debug
configuration dialog requires the following information as input to start the
debugger: the project name, the class and the starting operation/function.
Figure~\ref{fig:userguide:debugConfiguration} shows a debug configuration.
Clicking one of the browse buttons will open a dialog which give the user a list
of choices. The class and operation/function are chosen from the dialog with the
list of expandable classes, if the operation or function have arguments these
must be typed in manually. Alternatively one can get to the
\emph{Debug Configuration} by right clicking on a project in the
Explorer view and then selecting the \emph{Debug As} $\rightarrow$
\emph{debug Configuration}. Finally it is also possible to get to the
\emph{Debug Configuration} by using the small downwards pointing arrow
next to the debug icon
(\includegraphics[width=0.03\textwidth]{icons/debuggericon}) at the
top of the Overture tool. 

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=380px]{figures/debugConfiguration}
  \caption{The debug configuration dialog}
  \label{fig:userguide:debugConfiguration}
\end{center}
\end{figure}

\section{Debug Perspective}

The Debug Perspective\index{debug perspective} contains the views
needed for debugging in VDM. Breakpoints can easily be set at desired
places in the model, by double clicking in the left margin. When the
debugger reaches the location of the breakpoint, the user can inspect
the values of different identifiers and step through the VDM model
line by line.\index{perspective!debug}
 
The debug perspective shows the VDM model in an editor as the one used in the
Overture Perspective, but with additional views useful during
debugging. The features provided in the debug perspective are described below.
The Debug Perspective is illustrated on Figure~\ref{fig:userguide:DebuggingVDM}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=380px]{figures/DebuggingVDM}
  \caption[Debugging perspective]{Debugging perspective}
  \label{fig:userguide:DebuggingVDM}
\end{center}
\end{figure}

%The \emph{Debug view} is located in the upper left corner in the Debug
%perspective. The Debug view shows all running models and the call stacks
%belonging to them. It also shows whether a given model is stopped, suspended or
%running. All threads are also shown, along with their running status. It is
%possible to switch between threads from the Debug view.

\begin{table}
\begin{center}
\caption{Overture debugging buttons\label{tab:debugButtons}}
\begin{tabular}{|l|l|}\hline \hline
\textbf{Button} & \textbf{Explanation} \\ \hline
\includegraphics[width=0.03\textwidth]{figures/resume} & Resume
debugging\index{icon!resume debugging} \\
\includegraphics[width=0.03\textwidth]{figures/suspend} & Suspend
debugging\index{icon!suspend debugging}\\
\includegraphics[width=0.03\textwidth]{figures/terminate} & Terminate
debugging\index{icon!terminate debugging}\\
\includegraphics[width=0.03\textwidth]{figures/stepinto} & Step
into\index{icon!step into}\\
\includegraphics[width=0.03\textwidth]{figures/stepover} & Step
over\index{icon!step over} \\
\includegraphics[width=0.03\textwidth]{figures/stepreturn} & Step
return\index{icon!step return}\\
\includegraphics[width=0.03\textwidth]{figures/stepbystep} & Use step
filters\index{icon!use step filters}\\
\hline \hline
\end{tabular}
\end{center}
\end{table}

\subsection{Debug View}

The \emph{Debug view} is located in the upper left corner in the Debug Perspective -
see Figure~\ref{fig:userguide:DebuggingVDM}. The \emph{Debug view} shows all running
models and the call stack belonging to them. It also displays whether a given model is
stopped, suspended or running. In the top of the view buttons
for debugging such as; stop, step into, step over, resume, etc.\ are located.
All threads are also shown, along with their running status. It is possible to
switch between threads from the \emph{Debug view}.

At the top of the view are buttons for controlling debugging such as; stop, step
into, step over and resume. These are standard Eclipse debugging
buttons (see Table~\ref{tab:debugButtons}).

\subsection{Variables View}
 
This view shows all the variables in a given context, to be examined after a breakpoint has been
reached. The variables and their values displayed are automatically updated when
stepping through a model. The \emph{Variables view} is by default located in the upper
right hand corner in the \emph{Debug perspective}. It is also possible to inspect complex variables,
expanding nested structures and so forth.

\subsection{Breakpoints View}

Breakpoints can be added both from the edit perspective and the \emph{Debug perspective}
from the editor view. In the debug perspective however, there is a \emph{Breakpoints
view} that shows all breakpoints. From the \emph{Breakpoints view} the user can easily
navigate to the location of a given breakpoint, disable, delete or set the hit
count or a break condition. In Figure~\ref{fig:userguide:DebuggingVDM} the
\emph{Breakpoints view} is hidden behind the \emph{Variables view} in the upper right hand 
corner in a tabbed notebook. 

\subsection{Conditional breakpoints}
\label{sec:userguide:breakpoints}

Conditional breakpoints can also be defined. These are a powerful tool for the
developer since it allows specifying a condition for one or more variables which
has to be true in order for the debugger to stop at the given breakpoint. Apart
from specifying a break condition depending on variables, a hit count can also be
defined. A conditional breakpoint with a hit count lets the user specify a given
number of calls to a particular place at which the debugger should break.

Making a breakpoint conditional is done by right clicking on the breakpoint
mark in the left margin and select the option \emph{Breakpoint properties}\ldots This
opens a dialog like the one shown in
Figure~\ref{fig:userguide:BreakpointConditional}. It is possible to choose
between two different conditional breakpoints, a hit count condition and one
based on an expression defined by the user. 

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=.6\textwidth]{figures/Breakpointconditional}
  \caption{Conditional breakpoint options}
  \label{fig:userguide:BreakpointConditional}
\end{center}
\end{figure}

\subsection{Expressions View}

The \emph{Expressions view} allows the user to write expressions used for inspecting
values of the model. As for the \emph{Variables view}, the expressions are 
automatically updated when stepping through the model.
Watch expressions can be added manually or created by selecting \emph{create watch
expression} from the \emph{Variables view}. It is of course possible to edit existing
expressions. Like the \emph{Breakpoints view} this view is hidden in the upper right
hand corner.

%\subsection{Interactive Console View}

%While the \emph{Expressions view} allows to easily inspect values, the functionality is
%somewhat limited compared to the functionality provided by VDMTools. For more
%thorough inspections the \emph{Interactive console view} is more suited. Here commands
%can be executed on the given context, i.e.\ where the debugger is at a
%breakpoint. The \emph{Interactive console} keeps a command history, so that already
%executed commands can be run again without actually typing in the command all
%over. Figure~\ref{fig:userguide:interactiveConsole} shows the interactive
%console.

%\begin{figure}[htp]
%\begin{center}
%  \includegraphics[width=300px]{figures/InteractiveConsole}
%  \caption{The interactive console}
%  \label{fig:userguide:interactiveConsole}
%\end{center}
%\end{figure}

\chapter{Collecting Test Coverage Information}\label{sec:testcoverage}

When a VDM model is being interpreted it is possible to automatically
collect test coverage information. 
Test coverage measurement helps you to see
how well a given test suite\index{Test Coverage!Test suite} covers the
VDM model. This is done by collecting information in a special
test coverage file about which statements and expressions are
evaluated during the execution of the test suite.

In order to enable collection of test coverage data, go to the \emph{Debug 
configuration} and select the \emph{Generate Latex coverage}. After running a 
debug configuration, a new file with the \emph{cov} extension will be created for 
each file in the project. All these files are put into a folder named
\texttt{generated/coverage/yyyy\_mm\_dd\_hh\_mm\_ss}. From these generated files,
a \emph{pdf} file containing the entire model with color coded test coverage data 
can be generated by right clicking on the project name and choosing
\emph{Latex} $\rightarrow$ \emph{Latex Coverage}. All parts of the model \emph{not}
covered by the test, is colored red.

\chapter{Pretty Printing to \LaTeX}\label{sec:prettyprint}

Include {\ttfamily overture.tex} which among other things makes use of
the {\ttfamily times.cls} and {\ttfamily listings.cls} style
classes. This enables the use of the standard {\ttfamily lstlisting}
environment for type setting source text and display it in a tele-type
proportional font where all VDM keyword are typeset in a bold
font. Per default the listings will be inserted into boxes but it is
easy to adjust (using the parameters to the {\ttfamily lstlisting}
environment) if no boxes are desired.

It is possible to use literate programming/specification
\cite{Johnson96} just as inside VDMTools. Then one needs to use the
\LaTeX\ text processing system with plain VDM models mixed with
textual documentation.  The 
VDM model parts must be enclosed within ``\verb+\begin{vdm_al}+''
and ``\verb+\end{vdm_al}+''. The text-parts outside the specification
blocks are ignored by the parser (but used by the pretty-printer).

\chapter{Managing Proof Obligations}\label{sec:POmanagement}

In the different VDM dialects it is possible to identify places where
run-time errors potentially could occur if the model was to be
executed. In essence these can be considered as additional to the
existing type checking performed. Just like almost all other computer
based languages it is not possible to automatically statically check
if such places indeed could result in a run-time error or not. Thus
Overture provides so-called ``proof obligations''\index{proof
  obligation} for all places where such run-time errors ``could''
occur. Each \emph{Proof Obligation} (PO) is formulated as a predicate
that must hold on a particular place of the VDM model and thus it may
have particular context information associated with it. These POs can
be considered as constraints that will guarantee the internal integrity
of the VDM models if they are all correct. In the long term it will be
possible to prove these constraints by a proof component in Overture
but this is not yet working as well as we wish. 

It takes a little time for newcomers to VDM to get used to the form
of these so it may be worthwhile to elaborate a bit on the form of the
proof obligations. POs can be divided into different
categories\index{proof obligation!categories}
depending upon their nature. These can be found in
Appendix~\ref{app:POcategories} along with a short explanation for
each of them.

The proof obligation generator is invoked either on a VDM project (and
then POs for all the VDM model files will be generated) or only for a
selected VDM file. One can right click in the \emph{Explorer} view and
then select the \emph{Proof Obligations} $\rightarrow$ \emph{Generate Proof
  Obligations} menu item. Overture will then change into a special
\emph{Proof Obligations Perspective}\index{proof
  obligation!perspective} as shown in
Figure~\ref{fig:POview}.\index{perspective!proof obligations}  

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=\textwidth]{figures/POview}
\caption{The Proof Obligation perspective\label{fig:POview}}
\end{center}
\end{figure}

Note that in the \emph{Proof Obligation Explorer} view each proof
obligation have a number of components:
\begin{itemize}
\item A unique number in the list shown;
\item The name of the definition in which the proof obligation is
  generated from;
\item The proof obligation category (type); and
\item A status field indicating whether the proof obligation is
  trivially correct or would have to be proved by a normal proof
  engine.
\end{itemize}

At the top of the \emph{Proof Obligation Explorer} it is
possible to filter away all the proof obligations that are trivially
correct pressing the \emph{Filter proved} button at the top of this
view.\index{filter proved} 

\chapter{Combinatorial Testing}\label{sec:testing}

In order to automate parts of the testing process a notion of
\emph{traces} have been introduced into VDM++ (note that this is 
only available for VDM-SL models if the VDM-10 language version has been selected). 
Such traces conceptually correspond
to regular expressions that can be expanded to a collection of test
cases. Each such test case is then composed as a sequence of operation
calls. If a user defines such traces it is possible to make use of a
special combinatorial testing perspective that enables the automatic
unfolding of the traces and automatic execution of each of the test
cases. Subsequently, the results of running all these can be inspected
and erroneous test cases can easily be found. The user can then fix 
the problem and reuse the same traces definitions.

\section{Using the Combinatorial Testing GUI}

The syntax for trace definitions are defined in the VDM-10 language
manual.\index{traces}
If one have used the {\bf\ttfamily traces} syntax described above it
is possible to go to the \emph{Combinatorial testing}
perspective\index{combinatorial testing}. An example of using that
perspective can be seen in
Figure~\ref{fig:tracesalarm}.\index{perspective!combinatorial testing}

Different icons are used to illustrate the verdict in a test
case. These are:
\begin{description}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/unknownWhiteBG.png}}:]
  This icon is used to indicate that the test case has not yet been
  executed.
\index{icon!not yet executed}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/okBigWhiteBG.png}}:] This icon is used to indicate that the test case has a pass
  verdict.\index{icon!pass verdict}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/undeterminedBigWhiteBG.png}}:] This icon is used to indicate that the test case has an inconclusive
  verdict.\index{icon!inconclusive verdict}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{icons/faildBigWhiteBG.png}}:]
This icon is used to indicate that the test case has a fail
verdict.\index{icon!fail verdict}
\item[\hspace{-1.8mm}
\raisebox{-0.8mm}{\includegraphics[height=10pt]{screenDumps/skippedIndication.png}}:] 
If test cases result in a run-time error other test cases with the
same prefix will be filtered away and thereby skipped by in the test
execution. The number of skipped test cases is indicated after number
of test cases for the trace definition name.\index{icon!skipped test case}
\end{description}


\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{screenDumps/tracesalarm}
\caption{Using Combinatorial Testing\label{fig:tracesalarm}}
\end{center}
\end{figure}

\chapter{Mapping VDM++ back and forth to UML}\label{sec:vdmuml}

For VDM++ and VDM-RT projects it is
possible to move automatically back and forth between a VDM model
and its corresponding UML model\footnote{In the current version of
  Overture this feature is somewhat unstable.}. 
Essentially these can be considered
as different views of the same model. The UML model is typically used
as a graphical overview of the model using class diagrams and the
sequence diagrams can be used to indicate the desired test scenarios
that a user would like to perform. The VDM++ model is typically used
as the model where the details for each definition can be found and
used for detailed semantic analysis. The exchange between VDM++ and
UML is done using the XML formal called XMI\index{XMI}. At the moment
only the UML tool Enterprise Architect\index{Exterprise Architect} is
supported. Export from EA is done by selecting the \emph{Project} menu
and selecting \emph{Import/Export} $\rightarrow$ \emph{Export Package
  to XMI}. This is illustrated in Figure~\ref{fig:exportfromUML}.

\begin{figure}[htbp]
\begin{center}
\includegraphics[width=4.5in]{screenDumps/exportfromUML}
\caption{Exporting UML definitions from EA\label{fig:exportfromUML}}
\end{center}
\end{figure}

Mapping back and forth between a VDM++ model and a UML model is in
practice done from the \emph{Explorer} view where right-clicking
the project will result in a menu with
entries for \emph{UML transformation}\index{UML transformation}. If this
is selected it is either possible to \emph{Import XMI}\index{import
  XMI} if one wish to import UML definitions from UML or to
\emph{Export XMI}\index{Export XMI} if one wish to go from VDM++ to
UML.

At the class diagram at the UML level additional classes will be
generated for standard VDM++ basic types. When such UML models are
mapped back to VDM++ such additional classes are ignored. 

\chapter{Moving from VDM++ to VDM-RT}\label{sec:ToVDMRT}

In the methodology for the development of distributed real-time
embedded systems using the VDM technology a step is described where one
moves from a VDM++ model to a VDM-RT model \cite{Larsen&09b}. This
step is supported by the Overture tool suite where it is possible to
copy a VDM++ project into the starting point for a VDM-RT
project. This is done by right clicking on the VDM++ project to be
converted in this fashion in the Project Explorer view followed by 
selecting the \emph{Overture Utility}
$\rightarrow$ \emph{Create Real Time Project}.\index{create real time
  project} As a consequence a new VDM-RT project is
created.\index{create!VDM-RT project} It will be called exactly the
same as the VDM++ project with \texttt{RT} appended to the project
name. Inside the project all the \texttt{vdmpp} files will instead
have the \texttt{vdmrt} extension. The original VDM++ project is not
changed at all. Thus this is simply a quick and easy way to get to the
starting point for a VDM-RT model. One then manually need to
create a {\bf\ttfamily system} with appropriate declarations of
\texttt{CPU}s and \texttt{BUS}ses.
 
\chapter{Analysing and Displaying Logs from VDM-RT Executions}\label{sec:showlog}

When a VDM-RT model is being executed a textual logfile is created in
a ''\texttt{logs/debugconfig}'' folder with the \emph{.logrt} extension. The
file name for the logfile indicates the time at which it has been
written so it is possible to store multiple of these. This logfile can be
viewed in the build-in \emph{RealTime Log Viewer},\index{RealTime Log viewer}
by double-clicking the file in the project view. The viewer enables
the user to explore system execution in various perspectives. In
Figure~\ref{fig:userguide:ArchitecturalOverview} the architectural
overview of the system is given, describing the distributed nature of
the model.\index{architecture overview}

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ArchitectureOverview}
  \caption{Architectural overview}
  \label{fig:userguide:ArchitecturalOverview}
\end{center}
\end{figure}

The \emph{RealTime Log Viewer} also enables the user to get an overview of
the model execution\index{model execution overview} on a system level -- this can be seen in
Figure~\ref{fig:userguide:ExecutionOverview}. This view shows how the
different CPUs\index{CPU} communicate via the BUSes\index{BUS} of the system. 

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ExecutionOverview}
  \caption{Execution overview}
  \label{fig:userguide:ExecutionOverview}
\end{center}
\end{figure}

Since the complete execution of the model cannot be shown in a normal
sized window, the user has the option of jumping to a certain time
using the \emph{Go to time} button.\index{Go to time button} It is
also possible to export all the generated views to \emph{JPG} format
using the \emph{Export Image} button.\index{export image button} All
the generated pictures will be placed in the ''\texttt{logs}'' folder.

In addition to the execution overview, the \emph{RealTime Log Viewer} can
also give an overview of all executions on a single CPU. This view
gives a detailed description of all operations and functions invoked
on the CPU as well as the scheduling of concurrent processes. This can
be seen in Figure~\ref{fig:userguide:ExecutionCPU}.\index{single CPU overview} 

\begin{figure}[htp]
\begin{center}
  \includegraphics[width=4in]{figures/ExecutionCPU}
  \caption{Execution on single CPU}
  \label{fig:userguide:ExecutionCPU}
\end{center}
\end{figure}

\chapter{Defining Your Own Java Libraries to be used from Overture}\label{sec:javalibs}

VDM models are not appropriate for describing everything it is common to have existing legacy code that a user may not
wish to spend time modeling in VDM but would like to make use of
from a VDM model. Hence, a feature enabling a combination of a VDM
model and a library with functionality in a standard \texttt{jar} file
has been enabled. Using this feature it is possible 
to call functionality provided by the jar file from a VDM model. This functionality
corresponds to DL modules/classes in a VDMTools context \cite{DLMan}.

The external libraries which can be defined for VDM is coupled to the
\texttt{is not yet specified} statements/ expressions. Only operations
or functions of modules or classes can be delegated to an external
jar. The look up for a delegate java class is done based on the
module/class name where an underscore (``\_'') is replaced with a dot
(``.''): \texttt{remote\_lib\_sensor} becomes
\texttt{remote.lib.sensor} in java. The look up is only done once and
only when a \texttt{is not yet specified} body is
reached. The jar with the compiled remote library must be places in
the project in a folder named \texttt{lib} it will then be put in the
class-path of the interpreter when debugging. To compile a library jar
for VDM the VDMJ jar needs to be in the class-path. It can be fund in
the Overture IDE installation under
\texttt{plugins/org.overture.ide.generated.vdmj\_2.0.1/lib}.

\section{Remote library example}

In this example a remote sensor will be defined which can read a
value from a real sensor. The VDM model interface of the sensor can be
seen in listing~\ref{remoteSensorVdm} where as the Java class
implementing it can be seen in listing~\ref{remoteSensorJava}. The
values that are to be exchanged between the Overture IDE and the jar
file needs to be the values used in VDMJ. Documentation about these
can be found in the VDMJ user manual \cite{Battle09}.

\begin{lstlisting}[language=VDM++,label=remoteSensorVdm,caption=Remote sensor VDM class,captionpos=b]
class remote_lib_sensor

operations

public getValue : int ==> int
getValue (id) == is not yet specified;

end remote_lib_sensor
\end{lstlisting}


\begin{lstlisting}[language=JAVA,label=remoteSensorJava,caption=Remote sensor Java class,captionpos=b]
package remote.lib;

import org.overturetool.vdmj.runtime.ValueException;
import org.overturetool.vdmj.values.IntegerValue;
import org.overturetool.vdmj.values.Value;

public class sensor
{
	public Value getValue(Value id) throws ValueException
	{
		int intId = new Long(id.intValue(null)).intValue();
		return new IntegerValue(intId);
	}
}
\end{lstlisting}

\chapter{Enabling Remote Control of the Overture
  Interpreter}\label{sec:remote}

In some situations it may also be valuable to be able to establish a
front end (for example with a GUI) for interpreting different aspects
of a VDM model. This is enabled in a fashion similar to the approach described in the 
previous section using a java jar file. This functionality corresponds
to the CORBA based API from VDMTools \cite{APIMan}.

A VDM model can be remotely controlled by the use of the java interface
\texttt{RemoteControl}. Remote control should be understood as a
delegation of control of an interpretation, which means that the remote
controller is in charge of the debug session, and is responsible for taking
action and executing parts of the VDM model. When finished it should
return and the debug session will stop. When a Remote controller is
used the debugger continues working normally, so for example breakpoints can be
used. Launching a debugging session with the use of a remote
controller can be done by placing the jar with the remote controller
in a folder \texttt{lib} inside the project. The full
qualified name of the remote controller must then be specified in the launch configuration
under the \textit{Remote Control} group.  To compile a remote control
jar for VDM the VDMJ jar file needs to be in the class-path. It can be found
in the Overture IDE installation
under\\ \texttt{plugins/org.overture.ide.generated.vdmj\_2.0.1/lib}.

\section{Example of a Remote Control class}

In this example we have a VDM class \texttt{A} which just returns the input. As
seen in listing~\ref{remoteControllerJava} it is possible to call
\texttt{execute} on the interpreter which is parsed to the remote
controller which then returns a string with the result. A more
advanced \texttt{valueExecute} also exists which returns the internal
Value type of the interpreter which is useful for more advanced
types. The
values that are to be exchanged between the Overture IDE and the jar
file needs to be the values used in VDMJ. Documentation about these
can be found in the VDMJ user manual \cite{Battle09}.

\begin{lstlisting}[language=JAVA,label=remoteControllerJava,caption=Remote Controller Java class,captionpos=b]
import org.overturetool.vdmj.debug.RemoteControl;
import org.overturetool.vdmj.debug.RemoteInterpreter;

public class RemoteController implements RemoteControl
{
	public void run(RemoteInterpreter interpreter) throws Exception
	{
		System.out.println("Remote controller run");
		System.out.println("The answer is " + 
			interpreter.execute("1 + 1")); 
		System.out.println("The answer is " + 
			interpreter.execute("new A().op(123)")); 
		System.out.println("The answer is " + 
			interpreter.execute("new A().op(1 + 3)")); 
	}
}
\end{lstlisting}

\chapter{A Command-Line Interface to VDMJ}\label{sec:commandline}

A central part of the Overture tool is a Java application
called VDMJ that provides a command-line interface that may be valuable
for users outside the Eclipse interface of Overture.\index{VDMJ}

\section{Starting VDMJ}

VDMJ\index{VDMJ} is contained entirely within one jar file. The jar
file contains a MANIFEST that identifies the main class to start the
tool, so the minimum command line invocation is as follows:

\lstset{style=tool,language=}
\begin{lstlisting}
$ !\textbf{java -jar vdmj-2.0.0.jar}!
VDMJ: You must specify either -vdmsl, -vdmpp or -vdmrt
Usage: VDMJ <-vdmsl | -vdmpp | -vdmrt> [<options>] [<files>]
\end{lstlisting}
\lstset{style=mystyle}
\lstset{language=VDM++}

So the first parameter indicates the VDM dialect used and then
various extra options can be used. These are:

\begin{description}
\item[\texttt{-r}:] This will indicate the VDM release number.
\item[\texttt{-w}:] This will suppress all warning messages.
\item[\texttt{-q}:] This will suppress all information messages, such as
 the number of source files processed etc.
\item[\texttt{-i}:] This will start the interpreter if the VDM
  model is successfully parsed and type checked, otherwise the errors discovered
  will be listed.
\item[\texttt{-p}:] This will generate all proof obligations for the
  VDM model (if it is syntax and type correct) and then 
  stop.
\item[\texttt{-e <exp>}:] This will evaluate the \texttt{<exp>} print
  the result and stop.
\item[\texttt{-c <charset>}:] This will select a file character set. This is to
allow a specification written in languages other than the default for your system
to be used. 
\item[\texttt{-t <charset>}:] This will select a console character set. The output
terminal can use a different character set to the specification files.
\item[\texttt{-o <filename>}:] This will save the internal
  representation of a parsed and type checked spe\-ci\-fication. Such files are
effectively libraries, and can be can be re-loaded without the
parsing/checking overhead. If files are sufficiently large, this may be faster.
\item[\texttt{-pre}:] This will disable all pre-condition checks.
\item[\texttt{-post}:] This will disable all post-condition checks.
\item[\texttt{-inv}:] This will disable type/state invariant checks.
\item[\texttt{-dtc}:] this will disable all dynamic type checking.
\item[\texttt{-measures}:] this will disable recursive measure checking.
\item[\texttt{-log}:] This will enable VDM-RT real-time event logging. These
  are useful with the Overture Eclipse GUI, which has a plugin to
  display timing diagrams (see Chapter~\ref{sec:showlog}).
\item [\texttt{-remote}:] This enables remote control of the VDMJ executable.
\end{description}

%Notice that the error indicates that the tool must be invoked with either the \texttt{-vdmsl}, \texttt{-vdmpp} or \texttt{-vdmrt}
%option to indicate the VDM dialect and parser required.

Normally, a VDM model will be loaded by identifying all of the VDM source files to include. At least
one source file must be specified unless the -i option is used, in which case the interpreter can be
started with no specification. If a directory is specified rather than a file, then VDMJ will load
all files in that directory with a suffix that matches the dialect (eg. *.vdmpp files for VDM++).
Files and directory arguments can be mixed.

If no \texttt{-i} option is given, the tool will only parse and type check
the VDM model files, giving any errors and warnings on
standard output, then stop. 
%Warnings can be suppressed with the \texttt{-w}
%option. The \texttt{-q} option can be used to suppress the various
%information messages printed (this does not include errors and
%warnings).

The \texttt{-p} option will run the proof obligation generator and
then stop, assuming the specification has no type checking errors.

For batch execution, the \texttt{-e} option can be used to identify a
single expression to evaluate in the context of the loaded
specification, assuming the specification has no type checking errors.

%The \texttt{-c} and \texttt{-t} options allow the file and console character sets to be defined, respectively. 

%The \texttt{-o} option allows a parsed and type checked specification to be saved to a file.
%The \texttt{-pre}, \texttt{-post}, \texttt{-inv} and \texttt{-dtc} options can be used to disable precondition, postcondition, invariant and
%dynamic type checking, respectively. By default, all these checks are performed.
%The \texttt{-log} option is for use with \texttt{-vdmrt}, and causes real-time events from the model to be written to the
%file name given. 

%If flat.vdmsl contains a simple VDM-SL specification of the factorial
%function, called ``\texttt{fac}'', the following
%illustrate ways to test the specification, with user input shown in bold:

%\begin{lstlisting}
%functions
%fac: int -> int
%fac(a) == if a < 2 then 1 else a * fac(a-1)
%pre a > 0
%\end{lstlisting}
\lstset{style=tool,language=}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl flat.vdmsl}!
%Parsed 1 module in 0.202 secs. No syntax errors
%Warning 5012: Recursive function has no measure in (flat.vdmsl) at 
%line 3:1
%Type checked 1 module in 0.016 secs. No type errors and 1 warning
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -q -w flat.vdmsl}!
%<quiet>
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -w -e "fac(10)" flat.vdmsl}!
%Parsed 1 module in 0.28 secs. No syntax errors
%Type checked 1 module in 0.031 secs. No type errors, 
%suppressed 1 warning
%Initialized 1 module in 0.031 secs.
%3628800
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -e "fac(10)" -q -w flat.vdmsl}!
%3628800
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -i -w flat.vdmsl}!
%Parsed 1 module in 0.202 secs. No syntax errors
%Type checked 1 module in 0.016 secs. No type errors, 
%suppressed 1 warning
%Initialized 1 module in 0.031 secs.
%Interpreter started
%> !\textbf{print fac(10)}!
%= 3628800
%Executed in 0.0 secs.
%> !\textbf{quit}!
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -p -w flat.vdmsl}!
%Parsed 1 module in 0.218 secs. No syntax errors
%Type checked 1 module in 0.015 secs. No type errors, 
%suppressed 1 warning
%Generated 1 proof obligation:
%Proof Obligation 1:
%fac: function apply obligation in 'DEFAULT1' (flat.vdmsl) at 
%line 4:38
%(forall a:int & (a > 0) =>
%(not (a < 2) =>
%pre_f((a - 1))))
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -w -e "fac(0)" -w flat.vdmsl}!
%Parsed 1 module in 0.203 secs. No syntax errors
%Type checked 1 module in 0.015 secs. No type errors, 
%suppressed 1 warning
%Initialized 1 module in 0.016 secs.
%Execution: Error 4055: Precondition failure: pre_f in (flat.vdmsl) 
%at line 5:11
%   a = 0
%   fac = (int -> int)
%   pre_fac = (int +> bool)
%In root context of fac(a) in 'DEFAULT1' (console) at line 1:1
%In root context of interpreter in 'DEFAULT1' (flat.vdmsl) at 
%line 3:1
%In root context of global environment
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -w -pre -e "fac(0)" 
%-w flat.vdmsl}!
%Parsed 1 module in 0.218 secs. No syntax errors
%Type checked 1 module in 0.016 secs. No type errors, 
%suppressed 1 warning
%Initialized 1 module in 0.015 secs.
%1
%Bye
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -w -o flat.lib flat.vdmsl}!
%Parsed 1 module in 0.203 secs. No syntax errors
%Type checked 1 module in 0.016 secs. No type errors, 
%suppressed 1 warning
%Saved 1 module to flat.lib in 0.093 secs.
%\end{lstlisting}

%\begin{lstlisting}
%$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl flat.lib -e "fac(10)"}!
%Loaded 1 module from flat.lib in 0.187 secs
%Initialized 1 module in 0.0 secs.
%3628800
%Bye
%\end{lstlisting}

\section{Parsing, Type Checking, and Proof Obligations}

All specification files loaded by VDMJ are parsed and type checked
automatically. There are no type checking options; the type checker
always uses ``possible'' semantics. If a specification does not parse
and type check cleanly, the interpreter cannot be started and proof
obligations cannot be generated (though warnings are allowed).

All warnings and error messages are printed on standard output, even
with the \texttt{-q} option.  A source file may contain VDM embedded
in a LaTeX file using \verb|vdm_al| environments (see
Chapter~\ref{sec:prettyprint}); the markup is ignored by the parser,
though reported line numbers will be correct.

The Java process will return with an exit code of zero if the
specification is clean (ignoring warnings).  Parser or type checking
errors result in an exit code of 1. The interpreter and PO generator
always exit with a code of zero.

\section{The Interpreter with Debugging Fuctionality}

Assuming a specification does not contain any parse or type checking errors, the interpreter can be
started by using the \texttt{-i} command line option.
The interpreter is an interactive command line tool that allows expressions to be evaluated in the
context of the specification loaded. For example, to load and interpret a
VDM-SL specification from a single file called \texttt{shmem.vdmsl},
the following options would be used:

\begin{lstlisting}
$ !\textbf{java -jar vdmj-2.0.0.jar -vdmsl -i shmem.vdmsl}!
Parsed 1 module in 0.266 secs. No syntax errors
Type checked in 0.047 secs. No type errors
Interpreter started
\end{lstlisting}

The interpreter prompt is ``\texttt{>}''. The 
interactive interpreter commands are as follows (abbreviated forms are
permitted for some, shown in square brackets): 
% (explanation below. The shmem source
%model is in Appendix A):

\begin{description}
\item[\texttt{modules}:] This command lists the loaded module names in
  a VDM-SL specification. In case of a flat VDM-SL model the name
  \texttt{DEFAULT} is used. The default module will be indicated in
  the list displayed.\index{modules}\index{command!modules}
\item[\texttt{classes}:] This command lists the loaded class names in
  both VDM++ and VDM-RT specifications. The default class will be indicated in
  the list displayed.\index{classes}\index{command!classes}
\item[\texttt{default <module/class>}:] This command sets the default
  module/class name as the prime scope for which the lookup of
  identifiers appear (i.e.\ names in the default module
do not need to be qualified, so you can say ``\texttt{print xyz}'' rather than
``\texttt{print M`xyz}'').\index{default}\index{command!default}
\item[\texttt{create <id> := <exp>}:] This command is only available
  for the VDM++ and VDM-RT dialects. It creates a global variable that
  can be used subsequently in the interpreter. It is mostly used for
  creating global instances of classes.\index{create}\index{command!create} 
\item[\texttt{log [<file> | off]}:] This command can only be used in
  VDM-RT models. It starts to log real-time events to the file indicated. By
  default, event logging is turned off, but logging can be enabled to
  the console by using log with no arguments, or to a file using \texttt{log
  <filename>}. Logging can subsequently be turned off again by using
  \\texttt{log off}. The events logged include requests, activations and
  completions of all functions and operations, as well as all creation
  of instances of classes, creation of CPUs and BUSses, deployment of objects
  to specific CPUs and the swapping in an out of threads.\index{log}\index{command!log}  
\item[\texttt{state}:] This command can only be used for the VDM-SL
  dialect and shows the default module state.\index{state}\index{command!state}  
  The value of the state can be changed by operations called.
\item[\texttt{[p]rint <expression>}:] This command evaluates the
  expression provided in the current
  context.\index{print}\index{command!print}     
\item[\texttt{runtrace <name>}:] This command runs the trace called
  \texttt{<name>}. This will carry out the combinatorial
  test by expanding all the regular expressions and executing the resulting
  operation sequences. \index{combinatorial testing}
\item[\texttt{assert <file>}:] This command runs assertions from the
  file provided. The assertions in the file must be Boolean
  expressions, one per line. This command evaluates each assertion in
  turn, raising an error for any which is false.\index{assert}\index{command!assert}  
\item[\texttt{init}:] This command re-initializes the global
  environment. Thus all state components will be initialised to their
  initial value again, created variables are lost and code coverage
  is reset.\index{init}\index{command!init} 
\item[\texttt{env}:] This command lists the value of all global symbols
  in the default environment. This will show the signatures for all
  functions and operations as well as the values assigned to
  identifiers from value definitions and global state definitions (in VDM++
  terminology, public static instance variables). Note that this includes invariant,
  initialization and pre/postcondition functions. In the VDM++ and
  VDM-RT dialects the identifiers created using the \texttt{create}
  command will also be included.\index{env}\index{command!env} 
\item[\texttt{pog}:] This command generates a list of all proof
  obligations for the VDM model that is
  loaded.\index{pog}\index{command!pog}  
\item[\texttt{break [<file>:]<line\#> [<condition>]}:] This command
  create a breakpoint at a specific file and line and optionally makes
  it a conditional breakpoint.\index{break}\index{command!break}  
\item[\texttt{break <function/operation> [<condition>]}:] This command
  creates a breakpoint at the start of a function or an operation and
  optionally makes it a conditional breakpoint. 
\item[\texttt{trace [<file>:]<line\#> [<exp>]}:] This command creates a
  tracepoint for a specific line inside one of the source files. A
  tracepoint is similar to a breakpoint but with an implcit continue
  after it. This creates a trace of the expression given
  whenever the tracepoint is reached. \index{trace}\index{command!trace} 
\item[\texttt{trace <function/operation> [<exp>]}:] This command
  create a tracepoint at the start of a function or operation.
  See \texttt{trace} above for an explanation of tracepoints.
\item[\texttt{remove <breakpoint\#>}:] This command removes a
  trace/breakpoint by referring to its number (given by the
  \texttt{list} command). \index{remove}\index{command!remove} 
\item[\texttt{list}:] This command provides a list of all current
  trace/breakpoints by number.\index{list}\index{command!list}  
\item[\texttt{coverage [<file>|clear]}:] This command displays/clears
  file line test coverage. The coverage command displays the source
  code of the loaded VDM model (by default, all source files are
  listed), with ``+'' and ``-'' signs in the left hand column indicating
  lines which have been executed or not, respectively. Finally, the
  percentage coverage of each source file is
  displayed.\index{coverage}\index{command!coverage}  
\item[\texttt{latex|latexdoc [<files>]}:] This command generates LaTeX
  line coverage files. These are \LaTeX\ versions of the source files
  with parts of the
  specification highlighted where they have not been executed. The
  \LaTeX\ output also contains a table of percentage cover by
  module/class and the number of times functions and operations were
  hit during the execution. The \texttt{latexdoc} command is the same,
  except that output files are wrapped in LaTeX document headers. The
  output files are written to the same directory as the source files, one
  per source file, with the extension \texttt{.tex}. Coverage
  information is reset when a specification is loaded, when an \texttt{init}
  command is given, or when the
  command \\texttt{coverage clear} is executed, otherwise coverage is
  cumulative. If several files are loaded, the coverage for just one
  source file can be listed with \texttt{coverage <file>} or
  \texttt{latex <file>}. \index{latex}\index{command!latex} 
  \index{latexdoc}\index{command!latexdoc} 
\item[\texttt{files}:] This command list all source files loaded.
  \index{files}\index{command!files} 
\item[\texttt{reload}:] This command will re-parse and type check the
  VDM model files currently loaded. Note that if there are any errors
  in the parse or type check of the files, the interpreter will exit
  after reload.\index{reload}\index{command!reload} 
\item[\texttt{load <files>}:] This command replace current loaded VDM
  model files. Note that if there are any errors in the parse or type
  check of the files, the interpreter will exit after
  load.\index{load}\index{command!load}  
\item[\texttt{[q]uit}:] This command leave the
  interpreter.\index{quit}\index{command!quit}  
\end{description}

%\begin{lstlisting}
%> !\textbf{modules}!
%M (default)
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{state}!
%M`Q4 = [mk_M(<FREE>, 0, 9999)]
%M`rseed = 87654321
%M`Memory = mk_Memory(87654321, [mk_M(<FREE>, 0, 9999)],
%                               [mk_M(<FREE>, 0, 9999)])
%M`Q3 = [mk_M(<FREE>, 0, 9999)]
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{print rand(100)}!
%= 71
%Executed in 0.0 secs.
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{print rand(100)}!
%= 44
%Executed in 0.0 secs.
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{state}!
%M`Q4 = [mk_M(<FREE>, 0, 9999)]
%M`rseed = 566044643
%M`Memory = mk_Memory(566044643, [mk_M(<FREE>, 0, 9999)], 
%                                [mk_M(<FREE>, 0, 9999)])
%M`Q3 = [mk_M(<FREE>, 0, 9999)]
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{init}!
%Global context initialized
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{state}!
%M`Q4 = [mk_M(<FREE>, 0, 9999)]
%M`rseed = 87654321
%M`Memory = mk_Memory(87654321, [mk_M(<FREE>, 0, 9999)],
%                               [mk_M(<FREE>, 0, 9999)])
%M`Q3 = [mk_M(<FREE>, 0, 9999)]
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{print rand(100)}!
%= 71
%Executed in 0.0 secs.
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{print rand(100)}!
%= 44
%Executed in 0.0 secs.
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{env}!
%M`fragments = (M`Quadrant -> nat)
%M`combine = (M`Quadrant -> M`Quadrant)
%M`tryBest = (nat ==> nat)
%M`seed = (nat1 ==> ())
%M`reset = (() ==> ())
%M`bestfit = (nat1 * M`Quadrant -> nat1)
%M`add = (nat1 * nat1 * M`Quadrant -> M`Quadrant)
%M`firstFit = (nat1 ==> bool)
%M`rand = (nat1 ==> nat1)
%M`tryFirst = (nat ==> nat)
%M`main = (nat1 * nat1 ==> seq of (<SAME> | <BEST> | <FIRST>))
%M`MAXMEM = 10000
%M`delete = (M`M * M`Quadrant -> M`Quadrant)
%M`inv_M = (M`M +> bool)
%M`CHUNK = 100
%M`bestFit = (nat1 ==> bool)
%M`least = (nat1 * nat1 -> nat1)
%M`fits = (nat1 * M`Quadrant -> nat1)
%M`init_Memory = (M`Memory +> bool)
%M`pre_add = (nat1 * nat1 * M`Quadrant +> bool)
%\end{lstlisting}

%\begin{lstlisting}
%> !\textbf{pog}!
%Generated 36 proof obligations:
%Proof Obligation 1:
%M`fits: cases exhaustive obligation in 'M' (shmem.vdm) at 
%line 40:5
%(forall size:nat1, Q:Quadrant &
%Q = [] or Q = [h] ^ tail)
%...
%Proof Obligation 35:
%M`tryBest: sequence apply obligation in 'M' (shmem.vdm) at 
%line 176:27
%rand((len Q4)) in set inds Q4
%Proof Obligation 36:
%M`tryBest: subtype obligation in 'M' (shmem.vdm) at line 166:1
%RESULT >= 0
%\end{lstlisting}

%This example shows a VDM-SL specification called \texttt{shmem.vdmsl} being
%loaded. The help command lists the interpreter commands
%available. Note that several of them regard the setting of
%breakpoints, which is covered in the next section.

%The modules command lists the names of the modules loaded from the
%specification. In this example there is only one, called ``M''. One of
%the modules is identified as the default; names in the default module
%do not need to be qualified (so you can say print xyz rather than
%print M`xyz). The default module can be changed with the default
%command.

%The state command lists the content of the default module's
%state. This can be changed by operations, as can be seen by the two
%calls to rand which change the rseed value in the state (a
%pseudo-random number generator). The {\ttfamily{\bf init}} command will re-initialize
%the state to its original value, illustrated by the fact that two
%subsequent calls to rand return the same results as the first two did.

%The {\ttfamily{\bf print}}\index{print} command can be used to
%evaluate any expression.  The {\ttfamily{\bf env}}\index{env} command
%lists all the values in the global environment of the default
%module. This shows the functions, operations and constant values
%defined in the module. Note that it includes invariant, initialization
%and pre/postcondition functions.  The {\ttfamily{\bf pog}} command (proof obligation
%generator) generates a list of proof obligations for the
%specification.

%The assert command\index{assert} (illustrated below) can take a list of assertions
%from a file, and execute each of them in turn, raising an error for
%any assertion which is false. The assertions in the file must be
%simple boolean expressions, one per line:

When the interpretation of a VDM model is stopped at a
breakpoint, there are additional commands that can be used. These are:

\begin{description}
\item[\texttt{[s]tep}:] This command steps forward until the
  current expression/statement is on a new line.\index{step}\index{command!step} 
\item[\texttt{[n]ext}:] This command is similar to \\texttt{step} except
 function and operation calls are stepped over.\index{next}\index{command!next}  
\item[\texttt{[o]ut}:] This command runs to the return of the current
  function or operation. \index{out}\index{command!out} 
\item[\texttt{[c]ontinue}:] This command resumes execution and continues
  until the next breakpoint or completion of the thread that is being
  debugged.\index{continue}\index{command!continue} 
\item[\texttt{stack}:] This command displays the current stack frame
  context (i.e.\ the call stack).\index{stack}\index{command!stack} 
\item[\texttt{up}:] This command moves the stack frame context up one
  frame to allow variables to be seen.\index{up}\index{command!up}  
\item[\texttt{down}:] This command moves the stack frame context down
  one frame.\index{down}\index{command!down}  
\item[\texttt{source}:] This command lists VDM source around the
  current breakpoint. \index{source}\index{command!source} 
\item[\texttt{stop}:] This command terminate the execution
  immediately.\index{stop}\index{command!stop}  
\item[\texttt{threads}:] This command can only be used for the VDM++
  and VDM-RT dialects. It lists the active threads with status
  information for each thread.\index{threads}\index{command!threads} 
\end{description}

\appendix
\newpage

\bibliographystyle{nnewalpha}

\bibliography{bib/UserGuide,dan}
\addcontentsline{toc}{section}{\protect\numberline{}{References}}

\newpage
\chapter{Templates in Overture}\label{app:templates}

Inside Overture there are a number of different templates that are
supported initially. You can add your own as well. The keys and
descriptions of the ones that are pre-defined are:

\begin{longtable}{| l| p{9cm}| }\hline
Key & Description\\\hline
% ALL 
caseExpression            & Case Expression\\
dclStatement              & Declare\\
defExpression             & def pattern = expression1 in expression2\\
exists                    & exists bindList \& predicate\\
forall                    & forall bind list \& predicate\\
forallLoop                & for identifier = expression1 to expression2 do statement\\
forallinset               & forall in set\\
functions                 & Function block\\
ifthen                    & if predicate then expression1 else expression2\\
let                       & let pattern = expression1 in expression2\\
operations                & Operation block\\
while                     & while predicate do statement\\

% VDM-SL 
functionExplicit          & Explicit function\\
functionImplicit          & Implicit function\\
module                    & Module\\
moduleSkeleton            & Module Full skeleton of a module\\
operationExplicit         & Explicit Operation\\
operationImplicit         & Implicit operation\\

% VDM-PP 
act                       & The number of times that operation name operation has been activated\\
active                    & The number of operation name operations that are currently active.\\
class                     & Class Definition\\
classSkeleton             & Class Definition full skeleton\\
fin                       & The number of times that the operation name operation has been completed\\
functionExplicit          & Explicit function\\
functionImplicit          & Implicit function\\
instancevariables         & Instance Variables block\\
isnotyetspecified         & is not yet specified\\
isofbaseclass             & Test if an object is of a specific base class\\
isofclass                 & Test if an object is of class\\
issubclassof              & Is subclass of\\
issubclassresponsibility  & Is subclass responsibility\\
mutex                     & Mutex operation\\
operationExplicit         & Explicit Operation\\
operationImplicit         & Implicit operation\\
per                       & Permission predicate for an operation, history counters can be used: \#fin, \#act, \#active, \#req, \#waiting\\
req                       & The number of requests that has been issued for the operation name operation\\
samebaseclass             & Test if two objects are of the same type\\
self                      & Get a reference to the current object\\
sync                      & Synchronization block\\
values                    & Values block\\
waiting                   & The number of outstanding requests for the operation name operation\\

% VDM-RT 
act                       & The number of times that operation name operation has been activated\\
active                    & The number of operation name operations that are currently active.\\
bus                       & BUS (Priority <CSMACD>, capacity,set of connected CPUs)\\
class                     & Class Definition\\
classSkeleton             & Class Definition full skeleton\\
cpu                       & CPU (Priority <FP/FCFS>, capacity)\\
cycle                     & Cycles(number of cycles)statement\\
duration                  & Duration(time in milliceconds)statement\\
fin                       & The number of times that the operation name operation has been completed\\
functionExplicit          & Explicit function\\
functionImplicit          & Implicit function\\
instancevariables         & Instance Variables block\\
isnotyetspecified         & is not yet specified\\
isofbaseclass             & Test if an object is of a specific base class\\
isofclass                 & Test if an object is of class\\
issubclassof              & Is subclass of\\
issubclassresponsibility  & Is subclass responsibility\\
mutex                     & Mutex operation\\
operationExplicit         & Explicit Operation\\
operationImplicit         & Implicit operation\\
per                       & Permission predicate for an operation, history counters can be used: \#fin, \#act, \#active, \#req, \#waiting\\
periodic                  & periodic(periode,jitter,delay,offset)(operation name)\\
req                       & The number of requests that has been issued for the operation name operation\\
samebaseclass             & Test if two objects are of the same type\\
self                      & Get a reference to the current object\\
sync                      & Synchronization block\\
system                    & System skeleton\\
time                      & Get the current time\\
values                    & Values block\\
waiting                   & The number of outstanding requests for the operation name operation\\\hline
\end{longtable}

\newpage
\chapter{Internal Errors}\label{app:internalerrors}

This appendix provides a list of the internal errors used in Overture
and an explanantion, for each of them, the circumstances under which the
internal error can be expected. Most of these errors should
never be seen by an ordinary user, so if they appear please report it
to the SourceForge bug reporting utility
(\url{https://sourceforge.net/tracker/?group_id=141350&atid=749152}). 

\input{../../core/vdmj/documentation/MESSAGES_Internal}

\newpage
\chapter{Lexical Errors}\label{app:lexerr}

When a VDM model is parsed, the first phase is to gather the single
characters into tokens that can be used in the further
processing. This is called a lexical analysis and errors in this area
can be as follows:

\input{../../core/vdmj/documentation/MESSAGES_Lexical}

\newpage
\chapter{Syntatic Errors}\label{app:synerr}

If the syntax of the file you have provided does not live up to the
syntax rules for the VDM dialect you wish to use, syntax errors will be
reported. These can be as follows:

\input{../../core/vdmj/documentation/MESSAGES_Syntax}

\newpage
\chapter{Type Errors and Warnings}\label{app:typeerr}

If the syntax rules are satisfied, it is still possible to get type
errors from additional type checking. The errors here can be as
follows:

\input{../../core/vdmj/documentation/MESSAGES_TypeChecking}

Warnings from the type checker include:

\input{../../core/vdmj/documentation/MESSAGES_Warnings}

\newpage
\chapter{Run-Time Errors}\label{app:runtimeerr}

When using the interpreter/debugger it is possible to get run-time
errors indicating that a problem with the VDM model analysed have been
detected. This includes the following kinds of errors:

\input{../../core/vdmj/documentation/MESSAGES_Runtime}

\newpage
\chapter{Categores of Proof Obligations}\label{app:POcategories}

This appendix provide a list of the different proof obligation
categories used in Overture and an explanantion for each of them the
circumstances under which the PO category can be expected.

\begin{description}
\item[map apply:] Whenever a map application is used it needs to be
  ensured that the argument is indeed in the domain of the mapping.
\item[function apply:] Whenever a function application is used it needs to be
  ensured that the list of arguments to the function are all of the
  types expected by the function signature as well as satisfy the
  pre-condition of the function in case such a predicate is present.
\item[sequence apply:] Whenever a sequence application is used it needs to be
  ensured that the argument is indeed in the indices of the sequence.
\item[post condition:]
\item[function satisfiability:] For all implicit function definitions
  this proof obligation will be generated to ensure that it will be
  possible to find a result satisfying the post-condition for all
  arguments of the function input types satisfying the pre-conditions.
\item[function parameter patterns:]
\item[let be st existence:] Whenever a let-be-such-that
  expression/statement is used it needs to be guranteed that the set
  to selecte from is non-empty.
\item[unique existence binding:] The {\bf\ttfamily iota} expression
  requires a unique binding to be present and that is guranteed by
  proof obligations from this category.
\item[function iteration:] 
\item[map iteration:]
\item[function compose:]
\item[map compose:]
\item[non-empty set:] This kind of proof obligations are used whenever
  non-empty sets are required.
\item[non-empty sequence:] This kind of proof obligations are used whenever
  non-empty sequences are required.
\item[non-zero:] This kind of proof obligations are used whenever zero
  cannot be used (e.g.\ in division).
\item[finite map:] If a type binding to a type that potentially have
  infinitely many elements is used inside a map comprehension this
  proof obligation will be generated because all mappings in VDM are finite.
\item[finite set:] If a type binding to a type that potentially have
  infinitely many elements is used inside a set comprehension this
  proof obligation will be generated because all sets in VDM are finite.
\item[map compatible:] Mappings in VDM represent a unique relationship
  between the domain values and the corresponding range values. Proof
  obligations in this category are meant to ensure that such a unique
  relationship is guranteed.
\item[map sequence compatible:]
\item[map set compatible:] 
\item[sequence modification:]
\item[tuple selection:] This proof obligation category is used
  whenever a tuple selection expression is used and it must be
  guranteed that the length of the tuple at least is as long as the
  selector used.
\item[value binding:] 
\item[subtype:] This proof obligation category is used whenever it is
  not possible to statically detect that the given expression indeed
  falls into the subtype required in the actual use of it.
\item[cases exhaustive:] If a cases expression does not have an
  {\bf\ttfamily others} clause it is necessary to ensure that the
  different case alternatives are exhaustive over the type of the
  expression used in the case choice.
\item[type invariant:] Proof obligations from this category are used
  to ensure that invariants for elements of a particular type are satisfied.
\item[recursive function:] This proof obligation makes use of the
  {\bf\ttfamily measure} construct to ensure that a recursive function
  will terminate. 
\item[state invariant:] If a state (including instance variables in
  VDM++) have an invariant this proof obligation will be generated
  whenever assignment is made to a part of the state all the places
  where the invariant shall be satisfied.
\item[while loop termination:] This kind of proof obligation is a
  reminder to ensure that a while loop is terminating. However, for
  embedded systems that is typically not desirable and thus in those
  cases there is no need to satisfy this proof obligation.
\item[operation post condition:] Whenever an explicit operation has a
  post-condition there is an implicit proof obligation generated to
  remind the user that one would have to ensure that the explicit body
  of the operation for all possible input satisfy the post-condition.
\item[operation parameter patterns:] 
\item[operation satifiability:] For all implicit operation definitions
  this proof obligation will be generated to ensure that it will be
  possible to find a result satisfying the post-condition for all
  arguments of the operation input types satisfying the pre-conditions. 
\end{description}

\newpage
\chapter{Index}\label{sec:index}
\printindex
\addcontentsline{toc}{section}{\protect\numberline{}{Index}}



\end{document}
